{"profile_info":{"profile_id":"xccdf_org.ssgproject.content_profile_stig","description":"This profile contains configuration checks that align to the\nDISA STIG for Canonical Ubuntu 22.04 LTS V2R3.","title":"Canonical Ubuntu 22.04 LTS Security Technical Implementation Guide (STIG) V2R3"},"scan_result":{"title":"OSCAP Scan Result","identity":"root","profile_id":"xccdf_org.ssgproject.content_profile_stig","target":"c079ae73c388","cpe_platforms":["#service_disabled_rsyslog","#package_libpwquality","cpe:/o:canonical:ubuntu_linux:22.04::~~lts~~~"],"scanner":"OpenSCAP","scanner_version":"1.4.2","benchmark_url":"#scap_org.open-scap_comp_ssg-ubuntu2204-xccdf.xml","benchmark_id":"xccdf_org.ssgproject.content_benchmark_UBUNTU_22-04","benchmark_version":"0.1.78","start_time":"2025-11-28T16:31:25+00:00","end_time":"2025-11-28T16:31:25+00:00","test_system":"cpe:/a:redhat:openscap:1.4.2","score_system":"urn:xccdf:scoring:default","score":92.59259,"score_max":100,"target_addresses":{"MAC":["00:00:00:00:00:00"],"IPv4":["127.0.0.1"],"IPv6":["::1"]},"guid":"1cd58492-2fe7-4be6-8ace-862fabd63d70","target_name":"soteriasoft.jfrog.io/openrmfpro/prometheus:2.53.5-jammy-rfcurated@sha256:22ecbb9e52bed77fc02d420bfc6da871e4e66095d72b569a1f8041caea3f7b77","rfcat_version":"1.25.9"},"rules":{"xccdf_org.ssgproject.content_rule_package_aide_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_aide_installed","title":"Install AIDE","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R76","R79"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.3.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","2","3","5","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.10.1.3"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","BAI01.06","BAI02.01","BAI03.05","BAI06.01","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS01.03","DSS03.05","DSS04.07","DSS05.02","DSS05.03","DSS05.05","DSS05.07","DSS06.02","DSS06.06"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.4.3.2","4.3.4.3.3","4.3.4.4.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.1","SR 3.3","SR 3.4","SR 3.8","SR 4.1","SR 6.2","SR 7.6"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["1034","1288","1341","1417"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.12.1.2","A.12.2.1","A.12.4.1","A.12.5.1","A.12.6.2","A.14.1.2","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.14.2.7","A.15.2.1","A.8.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-7","PR.DS-1","PR.DS-6","PR.DS-8","PR.IP-1","PR.IP-3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000445-GPOS-00199"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-11.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["11.5.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-651010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260582r958944_rule"]}],"description":"The <code>aide</code> package can be installed with the following command:\n<pre>\n$ apt-get install aide</pre>\n         ","rationale":"The AIDE package must be installed if it is to be available for integrity checking.","oval_definition_id":"oval:ssg-package_aide_installed:def:1","remediations":[{"remediation_id":"package_aide_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_aide_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_aide\n\nclass install_aide {\n  package { 'aide':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_aide_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"aide\"\nversion = \"*\"\n"},{"remediation_id":"package_aide_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651010\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_aide_installed\n\n- name: Ensure aide is installed\n  ansible.builtin.package:\n    name: aide\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651010\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_aide_installed\n"}],"vuln_id":"SV-260582","stig_id":"UBTU-22-651010"},"xccdf_org.ssgproject.content_rule_aide_build_database":{"rule_id":"xccdf_org.ssgproject.content_rule_aide_build_database","title":"Build and Test AIDE Database","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R76","R79"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.3.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","2","3","5","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.10.1.3"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","BAI01.06","BAI02.01","BAI03.05","BAI06.01","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS01.03","DSS03.05","DSS04.07","DSS05.02","DSS05.03","DSS05.05","DSS05.07","DSS06.02","DSS06.06"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.4.3.2","4.3.4.3.3","4.3.4.4.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.1","SR 3.3","SR 3.4","SR 3.8","SR 4.1","SR 6.2","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.12.1.2","A.12.2.1","A.12.4.1","A.12.5.1","A.12.6.2","A.14.1.2","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.14.2.7","A.15.2.1","A.8.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-7","PR.DS-1","PR.DS-6","PR.DS-8","PR.IP-1","PR.IP-3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000445-GPOS-00199"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-11.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["11.5.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-651015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260583r958944_rule"]}],"description":"Run the following command to generate a new database:\n\n<pre>$ sudo aideinit</pre>\n\nBy default, the database will be written to the file\n\n<code>/var/lib/aide/aide.db.new</code>.\n\nStoring the database, the configuration file <code>/etc/aide.conf</code>, and the binary\n<code>/usr/bin/aide</code>\n(or hashes of these files), in a secure location (such as on read-only media) provides additional assurance about their integrity.\nThe newly-generated database can be installed as follows:\n\n<pre>$ sudo cp /var/lib/aide/aide.db.new /var/lib/aide/aide.db</pre>\n\nTo initiate a manual check, run the following command:\n<pre>$ sudo /usr/bin/aide --check</pre>\nIf this check produces any unexpected output, investigate.","rationale":"For AIDE to be effective, an initial database of &quot;known-good&quot; information about files\nmust be captured and it should be able to be verified against the installed files.","oval_definition_id":"oval:ssg-aide_build_database:def:1","remediations":[{"remediation_id":"aide_build_database","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\nAIDE_CONFIG=/etc/aide/aide.conf\nDEFAULT_DB_PATH=/var/lib/aide/aide.db\n\n# Fix db path in the config file, if necessary\nif ! grep -q '^database=file:' ${AIDE_CONFIG}; then\n    # replace_or_append gets confused by 'database=file' as a key, so should not be used.\n    #replace_or_append \"${AIDE_CONFIG}\" '^database=file' \"${DEFAULT_DB_PATH}\" '@CCENUM@' '%s:%s'\n    echo \"database=file:${DEFAULT_DB_PATH}\" >> ${AIDE_CONFIG}\nfi\n\n# Fix db out path in the config file, if necessary\nif ! grep -q '^database_out=file:' ${AIDE_CONFIG}; then\n    echo \"database_out=file:${DEFAULT_DB_PATH}.new\" >> ${AIDE_CONFIG}\nfi\n\n/usr/sbin/aideinit -y -f\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"aide_build_database","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Ensure AIDE Is Installed\n  ansible.builtin.apt:\n    name: aide\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Check if DB Path in /etc/aide/aide.conf Is\n    Already Set\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database=)(.*)$\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: database_replace\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Check if DB Out Path in /etc/aide/aide.conf\n    Is Already Set\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database_out=)(.*)$\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: database_out_replace\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Fix DB Path in Config File if Necessary\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database)(\\s*)=(\\s*)(.*)$\n    line: \\2\\3=\\4file:/var/lib/aide/aide.db\n    backrefs: true\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - database_replace.found > 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Fix DB Out Path in Config File if Necessary\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database_out)(\\s*)=(\\s*)(.*)$\n    line: \\2\\3=\\4file:/var/lib/aide/aide.db.new\n    backrefs: true\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - database_out_replace.found > 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Ensure the Default DB Path is Added\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    line: database=file:/var/lib/aide/aide.db\n    create: true\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - database_replace.found == 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Ensure the Default Out Path is Added\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    line: database_out=file:/var/lib/aide/aide.db.new\n    create: true\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - database_out_replace.found == 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Build and Test AIDE Database\n  ansible.builtin.command: /usr/sbin/aideinit -y -f\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651015\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260583","stig_id":"UBTU-22-651015"},"xccdf_org.ssgproject.content_rule_aide_check_audit_tools":{"rule_id":"xccdf_org.ssgproject.content_rule_aide_check_audit_tools","title":"Configure AIDE to Verify the Audit Tools","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.11"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-9(3)","AU-9(3).1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000278-GPOS-00108"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-651030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260586r1044779_rule"]}],"description":"The operating system file integrity tool must be configured to protect the integrity of the audit tools.","rationale":"Protecting the integrity of the tools used for auditing purposes is a\ncritical step toward ensuring the integrity of audit information. Audit\ninformation includes all information (e.g., audit records, audit settings,\nand audit reports) needed to successfully audit information system\nactivity.\n\nAudit tools include but are not limited to vendor-provided and open-source\naudit tools needed to successfully view and manipulate audit information\nsystem activity and records. Audit tools include custom queries and report\ngenerators.\n\nIt is not uncommon for attackers to replace the audit tools or inject code\ninto the existing tools to provide the capability to hide or erase system\nactivity from the audit logs.\n\nTo address this risk, audit tools must be cryptographically signed to\nprovide the capability to identify when the audit tools have been modified,\nmanipulated, or replaced. An example is a checksum hash of the file or\nfiles.","oval_definition_id":"oval:ssg-aide_check_audit_tools:def:1","remediations":[{"remediation_id":"aide_check_audit_tools","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\n\n\n\n\n\n\n\nif grep -i '^.*/usr/sbin/auditctl.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/auditctl.*#/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/auditd.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/auditd.*#/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/ausearch.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/ausearch.*#/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/aureport.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/aureport.*#/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/autrace.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/autrace.*#/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/augenrules.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/augenrules.*#/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"aide_check_audit_tools","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-651030\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure AIDE to Verify the Audit Tools - Gather List of Packages\n  tags:\n  - DISA-STIG-UBTU-22-651030\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  ansible.builtin.package_facts:\n    manager: auto\n  when: '\"linux-base\" in ansible_facts.packages'\n\n- name: Ensure aide is installed\n  ansible.builtin.package:\n    name: '{{ item }}'\n    state: present\n  with_items:\n  - aide\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-651030\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure AIDE to Verify the Audit Tools - Gather the package facts\n  ansible.builtin.package_facts:\n    manager: auto\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-651030\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set audit_tools fact\n  ansible.builtin.set_fact:\n    audit_tools:\n    - /usr/sbin/auditctl\n    - /usr/sbin/auditd\n    - /usr/sbin/augenrules\n    - /usr/sbin/aureport\n    - /usr/sbin/ausearch\n    - /usr/sbin/autrace\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-651030\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure existing AIDE configuration for audit tools are correct\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^{{ item }}\\s\n    line: '{{ item }} p+i+n+u+g+s+b+acl+xattrs+sha512'\n    create: true\n  with_items: '{{ audit_tools }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"aide\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-651030\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure AIDE to properly protect audit tools\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    line: '{{ item }} p+i+n+u+g+s+b+acl+xattrs+sha512'\n    create: true\n  with_items: '{{ audit_tools }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"aide\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-651030\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260586","stig_id":"UBTU-22-651030"},"xccdf_org.ssgproject.content_rule_aide_disable_silentreports":{"rule_id":"xccdf_org.ssgproject.content_rule_aide_disable_silentreports","title":"Configure AIDE To Notify Personnel if Baseline Configurations Are Altered","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000363-GPOS-00150","SRG-OS-000447-GPOS-00201"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-651020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260584r958794_rule"]}],"description":"The operating system file integrity tool must be configured to notify designated personnel of any changes to configurations.","rationale":"Detecting changes in the system can help avoid unintended, and negative consequences\nthat could affect the security state of the operating system","oval_definition_id":"oval:ssg-aide_disable_silentreports:def:1","remediations":[{"remediation_id":"aide_disable_silentreports","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif [ -e \"/etc/default/aide\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*SILENTREPORTS=/Id\" \"/etc/default/aide\"\nelse\n    touch \"/etc/default/aide\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/default/aide\"\n\ncp \"/etc/default/aide\" \"/etc/default/aide.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"SILENTREPORTS=no\" >> \"/etc/default/aide\"\n# Clean up after ourselves.\nrm \"/etc/default/aide.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"aide_disable_silentreports","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-651020\n  - aide_disable_silentreports\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Configure AIDE To Notify Personnel if Baseline Configurations Are Altered\n  block:\n\n  - name: Check for duplicate values\n    ansible.builtin.lineinfile:\n      path: /etc/default/aide\n      create: true\n      regexp: (?i)^\\s*SILENTREPORTS=\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: dupes\n\n  - name: Deduplicate values from /etc/default/aide\n    ansible.builtin.lineinfile:\n      path: /etc/default/aide\n      create: true\n      regexp: (?i)^\\s*SILENTREPORTS=\n      state: absent\n    when: dupes.found is defined and dupes.found > 1\n\n  - name: Insert correct line to /etc/default/aide\n    ansible.builtin.lineinfile:\n      path: /etc/default/aide\n      create: true\n      regexp: (?i)^\\s*SILENTREPORTS=\n      line: SILENTREPORTS=no\n      state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-651020\n  - aide_disable_silentreports\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260584","stig_id":"UBTU-22-651020"},"xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking":{"rule_id":"xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking","title":"Configure Periodic Execution of AIDE","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R76"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.3.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","2","3","5","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.10.1.3"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","BAI01.06","BAI02.01","BAI03.05","BAI06.01","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS01.03","DSS03.05","DSS04.07","DSS05.02","DSS05.03","DSS05.05","DSS05.07","DSS06.02","DSS06.06"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.4.3.2","4.3.4.3.3","4.3.4.4.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.1","SR 3.3","SR 3.4","SR 3.8","SR 4.1","SR 6.2","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.12.1.2","A.12.2.1","A.12.4.1","A.12.5.1","A.12.6.2","A.14.1.2","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.14.2.7","A.15.2.1","A.8.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","SI-7","SI-7(1)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-7","PR.DS-1","PR.DS-6","PR.DS-8","PR.IP-1","PR.IP-3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000363-GPOS-00150","SRG-OS-000446-GPOS-00200","SRG-OS-000447-GPOS-00201"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-11.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["11.5.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-651025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260585r958946_rule"]}],"description":"At a minimum, AIDE should be configured to run a weekly scan.\nTo implement a daily execution of AIDE at 4:05am using cron, add the following line to <code>/etc/crontab</code>:\n<pre>05 4 * * * root /usr/bin/aide --config /etc/aide/aide.conf --check</pre>\nTo implement a weekly execution of AIDE at 4:05am using cron, add the following line to <code>/etc/crontab</code>:\n<pre>05 4 * * 0 root /usr/bin/aide --config /etc/aide/aide.conf --check</pre>\nAIDE can be executed periodically through other means; this is merely one example.\nThe usage of cron&#x27;s special time codes, such as  <code>@daily</code> and\n<code>@weekly</code> is acceptable.","rationale":"By default, AIDE does not install itself for periodic execution. Periodically\nrunning AIDE is necessary to reveal unexpected changes in installed files.\n<br>\n          <br>\nUnauthorized changes to the baseline configuration could make the system vulnerable\nto various attacks or allow unauthorized access to the operating system. Changes to\noperating system configurations can have unintended side effects, some of which may\nbe relevant to security.\n<br>\n          <br>\nDetecting such changes and providing an automated response can help avoid unintended,\nnegative consequences that could ultimately affect the security state of the operating\nsystem. The operating system&#x27;s Information Management Officer (IMO)/Information System\nSecurity Officer (ISSO) and System Administrators (SAs) must be notified via email and/or\nmonitoring system trap when there is an unauthorized modification of a configuration item.","oval_definition_id":"oval:ssg-aide_periodic_cron_checking:def:1","remediations":[{"remediation_id":"aide_periodic_cron_checking","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\n\n# AiDE usually adds its own cron jobs to /etc/cron.daily. If script is there, this rule is\n# compliant. Otherwise, we copy the script to the /etc/cron.weekly\nif ! grep -Eq '^(\\/usr\\/bin\\/)?aide(\\.wrapper)?\\s+' /etc/cron.*/*; then\n    cp -f /usr/share/aide/config/cron.daily/aide /etc/cron.weekly/\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"aide_periodic_cron_checking","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure AIDE is installed\n  ansible.builtin.package:\n    name: aide\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Install cron\n  ansible.builtin.package:\n    name: cron\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Periodic Execution of AIDE\n  ansible.builtin.cron:\n    name: run AIDE check\n    minute: 5\n    hour: 4\n    weekday: 0\n    user: root\n    job: /usr/bin/aide --check\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-22-651025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260585","stig_id":"UBTU-22-651025"},"xccdf_org.ssgproject.content_rule_is_fips_mode_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_is_fips_mode_enabled","title":"Verify '/proc/sys/crypto/fips_enabled' exists","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["SC-12(2)","SC-12(3)","SC-13"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000396-GPOS-00176","SRG-OS-000478-GPOS-00223"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-671010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260650r987791_rule"]}],"description":"On a system where FIPS 140-2 mode is enabled, <code>/proc/sys/crypto/fips_enabled</code> must exist.\nTo verify FIPS mode, run the following command:\n<pre>cat /proc/sys/crypto/fips_enabled</pre>\n        ","rationale":"Use of weak or untested encryption algorithms undermines the purposes of utilizing encryption to\nprotect data. The operating system must implement cryptographic modules adhering to the higher\nstandards approved by the federal government since this provides assurance they have been tested\nand validated.","warnings":[{"text":"To configure the OS to run in FIPS 140-2 mode, the kernel parameter &quot;fips=1&quot; needs to be added during its installation.\nEnabling FIPS mode on a preexisting system involves a number of modifications to it. Refer to the vendor installation\nguidances.","category":"general"},{"text":"System Crypto Modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this, the system has to have cryptographic software provided by\na vendor that has undergone this certification. This means providing\ndocumentation, test results, design information, and independent third\nparty review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.","category":"regulatory"}],"platforms":["#not_osbuild_and_system_with_kernel"],"oval_definition_id":"oval:ssg-is_fips_mode_enabled:def:1","vuln_id":"SV-260650","stig_id":"UBTU-22-671010"},"xccdf_org.ssgproject.content_rule_encrypt_partitions":{"rule_id":"xccdf_org.ssgproject.content_rule_encrypt_partitions","title":"Encrypt Partitions","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["13","14"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","BAI02.01","BAI06.01","DSS04.07","DSS05.03","DSS05.04","DSS05.07","DSS06.02","DSS06.06"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.13.16"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(b)(1)","164.310(d)","164.312(a)(1)","164.312(a)(2)(iii)","164.312(a)(2)(iv)","164.312(b)","164.312(c)","164.312(d)","164.314(b)(2)(i)"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.4","SR 4.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R4.2","CIP-007-3 R5.1"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-9(3)","CM-6(a)","SC-13","SC-28","SC-28(1)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.DS-1","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000185-GPOS-00079","SRG-OS-000404-GPOS-00183","SRG-OS-000405-GPOS-00184"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-231010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260484r958552_rule"]}],"description":"Ubuntu 22.04 natively supports partition encryption through the\nLinux Unified Key Setup-on-disk-format (LUKS) technology. The easiest way to\nencrypt a partition is during installation time.\n<br>\n        <br>\nFor manual installations, select the <code>Encrypt</code> checkbox during\npartition creation to encrypt the partition. When this\noption is selected the system will prompt for a passphrase to use in\ndecrypting the partition. The passphrase will subsequently need to be entered manually\nevery time the system boots.\n\n<br>\n        <br>\nDetailed information on encrypting partitions using LUKS or LUKS ciphers can be found on\nthe Ubuntu 22.04 Documentation web site:<br>\n        <a href=\"https://help.ubuntu.com/community/Full_Disk_Encryption_Howto_2019\">https://help.ubuntu.com/community/Full_Disk_Encryption_Howto_2019</a>\n.","rationale":"The risk of a system&#x27;s physical compromise, particularly mobile systems such as\nlaptops, places its data at risk of compromise.  Encrypting this data mitigates\nthe risk of its loss if the system is lost.","oval_definition_id":"oval:ssg-encrypt_partitions:def:1","vuln_id":"SV-260484","stig_id":"UBTU-22-231010"},"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_idle_delay":{"rule_id":"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_idle_delay","title":"Set GNOME3 Screensaver Inactivity Timeout","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-11(a)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000029-GPOS-00010","SRG-OS-000031-GPOS-00012"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.8"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.2","8.2.8"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-271025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260538r958402_rule"]}],"description":"The idle time-out value for inactivity in the GNOME3 desktop is configured via the <code>idle-delay</code>\nsetting must be set under an appropriate configuration file(s) in the <code>/etc/dconf/db/local.d</code> directory\nand locked in <code>/etc/dconf/db/local.d/locks</code> directory to prevent user modification.\n<br>\n         <br>\nFor example, to configure the system for a 15 minute delay, add the following to\n<code>/etc/dconf/db/local.d/00-security-settings</code>:\n<pre>[org/gnome/desktop/session]\nidle-delay=uint32 900</pre>\n        ","rationale":"A session time-out lock is a temporary action taken when a user stops work and moves away from\nthe immediate physical vicinity of the information system but does not logout because of the\ntemporary nature of the absence. Rather than relying on the user to manually lock their operating\nsystem session prior to vacating the vicinity, GNOME3 can be configured to identify when\na user&#x27;s session has idled and take action to initiate a session lock.","oval_definition_id":"oval:ssg-dconf_gnome_screensaver_idle_delay:def:1","remediations":[{"remediation_id":"dconf_gnome_screensaver_idle_delay","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'gdm3' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/session/idle-delay$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|local.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/desktop/session/idle-delay$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/desktop/session/idle-delay$\" /etc/dconf/db/local.d/\nthen\n    echo \"/org/gnome/desktop/session/idle-delay\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\n\ninactivity_timeout_value='900'\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/session\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|local.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*idle-delay\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)idle-delay(\\s*=)/#\\1idle-delay\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/desktop/session\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/desktop/session]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"uint32 ${inactivity_timeout_value}\")\"\nif grep -q \"^\\\\s*idle-delay\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*idle-delay\\\\s*=\\\\s*.*/idle-delay=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/session\\\\]|a\\\\idle-delay=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260538","stig_id":"UBTU-22-271025"},"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_delay":{"rule_id":"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_delay","title":"Set GNOME3 Screensaver Lock Delay After Activation Period","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.8.5"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-11(a)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000029-GPOS-00010","SRG-OS-000031-GPOS-00012"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.8"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.2","8.2.8"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-271025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260538r958402_rule"]}],"description":"To activate the locking delay of the screensaver in the GNOME3 desktop when\nthe screensaver is activated, add or set <code>lock-delay</code> to <code>uint32 0\n         </code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/desktop/screensaver]\nlock-delay=uint32 0\n         </pre>\nAfter the settings have been set, run <code>dconf update</code>.","rationale":"A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity\nof the information system but does not want to logout because of the temporary nature of the absense.","oval_definition_id":"oval:ssg-dconf_gnome_screensaver_lock_delay:def:1","remediations":[{"remediation_id":"dconf_gnome_screensaver_lock_delay","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'gdm3' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/screensaver/lock-delay$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|local.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/desktop/screensaver/lock-delay$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/desktop/screensaver/lock-delay$\" /etc/dconf/db/local.d/\nthen\n    echo \"/org/gnome/desktop/screensaver/lock-delay\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\n\nvar_screensaver_lock_delay='0'\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|local.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*lock-delay\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)lock-delay(\\s*=)/#\\1lock-delay\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/desktop/screensaver]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"uint32 ${var_screensaver_lock_delay}\")\"\nif grep -q \"^\\\\s*lock-delay\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*lock-delay\\\\s*=\\\\s*.*/lock-delay=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/screensaver\\\\]|a\\\\lock-delay=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260538","stig_id":"UBTU-22-271025"},"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_enabled","title":"Enable GNOME3 Screensaver Lock After Idle Period","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.8.4"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000028-GPOS-00009","SRG-OS-000030-GPOS-00011"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.8"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.2","8.2.8"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-271020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260537r958400_rule"]}],"description":"\nTo activate locking of the screensaver in the GNOME3 desktop when it is activated,\nadd or set <code>lock-enabled</code> to <code>true</code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/desktop/screensaver]\nlock-enabled=true\n</pre>\nOnce the settings have been added, add a lock to\n<code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/desktop/screensaver/lock-enabled</pre>\nAfter the settings have been set, run <code>dconf update</code>.","rationale":"A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity\nof the information system but does not want to logout because of the temporary nature of the absense.","oval_definition_id":"oval:ssg-dconf_gnome_screensaver_lock_enabled:def:1","remediations":[{"remediation_id":"dconf_gnome_screensaver_lock_enabled","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'gdm3' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|local.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*lock-enabled\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)lock-enabled(\\s*=)/#\\1lock-enabled\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/desktop/screensaver]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"true\")\"\nif grep -q \"^\\\\s*lock-enabled\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*lock-enabled\\\\s*=\\\\s*.*/lock-enabled=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/screensaver\\\\]|a\\\\lock-enabled=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/screensaver/lock-enabled$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|local.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/desktop/screensaver/lock-enabled$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/desktop/screensaver/lock-enabled$\" /etc/dconf/db/local.d/\nthen\n    echo \"/org/gnome/desktop/screensaver/lock-enabled\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260537","stig_id":"UBTU-22-271020"},"xccdf_org.ssgproject.content_rule_dconf_gnome_disable_ctrlaltdel_reboot":{"rule_id":"xccdf_org.ssgproject.content_rule_dconf_gnome_disable_ctrlaltdel_reboot","title":"Disable Ctrl-Alt-Del Reboot Key Sequence in GNOME3","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["12","13","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.07","DSS06.02"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.2"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.7.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-6(a)","CM-7(b)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00227"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-271030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260539r991589_rule"]}],"description":"By default, <code>GNOME</code> will reboot the system if the\n<code>Ctrl-Alt-Del</code> key sequence is pressed.\n<br>\n         <br>\nTo configure the system to ignore the <code>Ctrl-Alt-Del</code> key sequence\nfrom the Graphical User Interface (GUI) instead of rebooting the system,\nadd or set <code>logout</code> to <code>[&#x27;&#x27;]</code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/settings-daemon/plugins/media-keys]\nlogout=[&#x27;&#x27;]</pre>\nOnce the settings have been added, add a lock to\n<code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent\nuser modification. For example:\n<pre>/org/gnome/settings-daemon/plugins/media-keys/logout</pre>\nAfter the settings have been set, run <code>dconf update</code>.","rationale":"A locally logged-in user who presses Ctrl-Alt-Del, when at the console,\ncan reboot the system. If accidentally pressed, as could happen in\nthe case of mixed OS environment, this can create the risk of short-term\nloss of availability of systems due to unintentional reboot.","oval_definition_id":"oval:ssg-dconf_gnome_disable_ctrlaltdel_reboot:def:1","remediations":[{"remediation_id":"dconf_gnome_disable_ctrlaltdel_reboot","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'gdm3' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|local.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*logout\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)logout(\\s*=)/#\\1logout\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/settings-daemon/plugins/media-keys]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"['']\")\"\nif grep -q \"^\\\\s*logout\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*logout\\\\s*=\\\\s*.*/logout=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]|a\\\\logout=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/settings-daemon/plugins/media-keys/logout$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|local.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/settings-daemon/plugins/media-keys/logout$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/settings-daemon/plugins/media-keys/logout$\" /etc/dconf/db/local.d/\nthen\n    echo \"/org/gnome/settings-daemon/plugins/media-keys/logout\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260539","stig_id":"UBTU-22-271030"},"xccdf_org.ssgproject.content_rule_sudo_require_authentication":{"rule_id":"xccdf_org.ssgproject.content_rule_sudo_require_authentication","title":"Ensure Users Re-Authenticate for Privilege Escalation - sudo","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.3.4"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.5.1","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-11"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000373-GPOS-00156"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-432010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260558r1050789_rule"]}],"description":"The sudo <code>NOPASSWD</code> and <code>!authenticate</code> option, when\nspecified, allows a user to execute commands using sudo without having to\nauthenticate. This should be disabled by making sure that\n<code>NOPASSWD</code> and/or <code>!authenticate</code> do not exist in\n<code>/etc/sudoers</code> configuration file or any sudo configuration snippets\nin <code>/etc/sudoers.d/</code>.&quot;","rationale":"Without re-authentication, users may access resources or perform tasks for which they\ndo not have authorization.\n<br>\n        <br>\nWhen operating systems provide the capability to escalate a functional capability, it\nis critical that the user re-authenticate.","oval_definition_id":"oval:ssg-sudo_require_authentication:def:1","remediations":[{"remediation_id":"sudo_require_authentication","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nfor f in /etc/sudoers /etc/sudoers.d/* ; do\n  if [ ! -e \"$f\" ] ; then\n    continue\n  fi\n  matching_list=$(grep -P '^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      # comment out \"NOPASSWD\" matches to preserve user data\n      sed -i \"s|^${entry}$|# &|g\" $f\n    done <<< \"$matching_list\"\n\n    /usr/sbin/visudo -cf $f &> /dev/null || echo \"Fail to validate $f with visudo\"\n  fi\ndone\n\nfor f in /etc/sudoers /etc/sudoers.d/* ; do\n  if [ ! -e \"$f\" ] ; then\n    continue\n  fi\n  matching_list=$(grep -P '^(?!#).*[\\s]+\\!authenticate.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      # comment out \"!authenticate\" matches to preserve user data\n      sed -i \"s|^${entry}$|# &|g\" $f\n    done <<< \"$matching_list\"\n\n    /usr/sbin/visudo -cf $f &> /dev/null || echo \"Fail to validate $f with visudo\"\n  fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sudo_require_authentication","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-432010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n\n- name: Find /etc/sudoers.d/ files\n  ansible.builtin.find:\n    paths:\n    - /etc/sudoers.d/\n  register: sudoers\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-432010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n\n- name: Remove lines containing NOPASSWD from sudoers files\n  ansible.builtin.replace:\n    regexp: (^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$)\n    replace: '# \\g<1>'\n    path: '{{ item.path }}'\n    validate: /usr/sbin/visudo -cf %s\n  with_items:\n  - path: /etc/sudoers\n  - '{{ sudoers.files }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-432010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n\n- name: Find /etc/sudoers.d/ files\n  ansible.builtin.find:\n    paths:\n    - /etc/sudoers.d/\n  register: sudoers\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-432010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n\n- name: Remove lines containing !authenticate from sudoers files\n  ansible.builtin.replace:\n    regexp: (^(?!#).*[\\s]+\\!authenticate.*$)\n    replace: '# \\g<1>'\n    path: '{{ item.path }}'\n    validate: /usr/sbin/visudo -cf %s\n  with_items:\n  - path: /etc/sudoers\n  - '{{ sudoers.files }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-432010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n"}],"vuln_id":"SV-260558","stig_id":"UBTU-22-432010"},"xccdf_org.ssgproject.content_rule_clean_components_post_updating":{"rule_id":"xccdf_org.ssgproject.content_rule_clean_components_post_updating","title":"Ensure apt_get Removes Previous Package Versions","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"low","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["18","20","4"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO12.01","APO12.02","APO12.03","APO12.04","BAI03.10","DSS05.01","DSS05.02"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.4.8"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3","4.2.3.12","4.2.3.7","4.2.3.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.6.1","A.14.2.3","A.16.1.3","A.18.2.2","A.18.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-11(a)","CM-11(b)","CM-6(a)","SI-2(6)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["ID.RA-1","PR.IP-12"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000437-GPOS-00194"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-214015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260477r1044773_rule"]}],"description":"<code>apt_get</code> should be configured to remove previous software components after\nnew versions have been installed. To configure <code>apt_get</code> to remove the\n\nprevious software components after updating, set the <code>::Remove-Unused-Dependencies</code> and\n<code>::Remove-Unused-Kernel-Packages</code>\n\n\nto <code>true</code> in <code>/etc/apt/apt.conf</code>.","rationale":"Previous versions of software components that are not removed from the information\nsystem after updates have been installed may be exploited by some adversaries.","oval_definition_id":"oval:ssg-clean_components_post_updating:def:1","remediations":[{"remediation_id":"clean_components_post_updating","system":"urn:xccdf:fix:script:sh","fix":"\n\nsed -i -E \"s/(^Unattended-Upgrade::Remove-Unused-Dependencies\\s+.*$)/#\\1/I\" /etc/apt/apt.conf.d/*\nsed -i -E \"s/(^Unattended-Upgrade::Remove-Unused-Kernel-Packages\\s+.*$)/#\\1/I\" /etc/apt/apt.conf.d/*\necho \"Unattended-Upgrade::Remove-Unused-Dependencies \\\"true\\\";\" >> /etc/apt/apt.conf.d/50unattended-upgrades\necho \"Unattended-Upgrade::Remove-Unused-Kernel-Packages \\\"true\\\";\" >> /etc/apt/apt.conf.d/50unattended-upgrades\n"}],"vuln_id":"SV-260477","stig_id":"UBTU-22-214015"},"xccdf_org.ssgproject.content_rule_banner_etc_issue_net":{"rule_id":"xccdf_org.ssgproject.content_rule_banner_etc_issue_net","title":"Modify the System Login Banner for Remote Connections","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.7.3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000023-GPOS-00006","SRG-OS-000228-GPOS-00088"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260525r958390_rule"]}],"description":"To configure the system login banner edit <code>/etc/issue.net</code>. Replace the\ndefault text with a message compliant with the local site policy or a legal\ndisclaimer.\n\nThe DoD required text is either:\n<br>\n        <br>\n        <code>You are accessing a U.S. Government (USG) Information System (IS) that\nis provided for USG-authorized use only. By using this IS (which includes\nany device attached to this IS), you consent to the following conditions:\n<br>-The USG routinely intercepts and monitors communications on this IS\nfor purposes including, but not limited to, penetration testing, COMSEC\nmonitoring, network operations and defense, personnel misconduct (PM), law\nenforcement (LE), and counterintelligence (CI) investigations.\n<br>-At any time, the USG may inspect and seize data stored on this IS.\n<br>-Communications using, or data stored on, this IS are not private,\nare subject to routine monitoring, interception, and search, and may be\ndisclosed or used for any USG-authorized purpose.\n<br>-This IS includes security measures (e.g., authentication and access\ncontrols) to protect USG interests -- not for your personal benefit or\nprivacy.\n<br>-Notwithstanding the above, using this IS does not constitute consent\nto PM, LE or CI investigative searching or monitoring of the content of\nprivileged communications, or work product, related to personal\nrepresentation or services by attorneys, psychotherapists, or clergy, and\ntheir assistants. Such communications and work product are private and\nconfidential. See User Agreement for details.</code>\n        <br>\n        <br>\nOR:\n<br>\n        <br>\n        <code>I&#x27;ve read &amp; consent to terms in IS user agreem&#x27;t.</code>\n       ","rationale":"Display of a standardized and approved use notification before granting\naccess to the operating system ensures privacy and security notification\nverbiage used is consistent with applicable federal laws, Executive Orders,\ndirectives, policies, regulations, standards, and guidance.\n<br>\n        <br>\nSystem use notifications are required only for access via login interfaces\nwith human users and are not required when such human interfaces do not\nexist.","platforms":["#system_with_kernel"],"oval_definition_id":"oval:ssg-banner_etc_issue_net:def:1","remediations":[{"remediation_id":"banner_etc_issue_net","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nremote_login_banner_text='^(You[\\s\\n]+are[\\s\\n]+accessing[\\s\\n]+a[\\s\\n]+U\\.S\\.[\\s\\n]+Government[\\s\\n]+\\(USG\\)[\\s\\n]+Information[\\s\\n]+System[\\s\\n]+\\(IS\\)[\\s\\n]+that[\\s\\n]+is[\\s\\n]+provided[\\s\\n]+for[\\s\\n]+USG\\-authorized[\\s\\n]+use[\\s\\n]+only\\.[\\s\\n]+By[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+\\(which[\\s\\n]+includes[\\s\\n]+any[\\s\\n]+device[\\s\\n]+attached[\\s\\n]+to[\\s\\n]+this[\\s\\n]+IS\\),[\\s\\n]+you[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+the[\\s\\n]+following[\\s\\n]+conditions\\:(?:[\\n]+|(?:\\\\n)+)\\-The[\\s\\n]+USG[\\s\\n]+routinely[\\s\\n]+intercepts[\\s\\n]+and[\\s\\n]+monitors[\\s\\n]+communications[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+for[\\s\\n]+purposes[\\s\\n]+including,[\\s\\n]+but[\\s\\n]+not[\\s\\n]+limited[\\s\\n]+to,[\\s\\n]+penetration[\\s\\n]+testing,[\\s\\n]+COMSEC[\\s\\n]+monitoring,[\\s\\n]+network[\\s\\n]+operations[\\s\\n]+and[\\s\\n]+defense,[\\s\\n]+personnel[\\s\\n]+misconduct[\\s\\n]+\\(PM\\),[\\s\\n]+law[\\s\\n]+enforcement[\\s\\n]+\\(LE\\),[\\s\\n]+and[\\s\\n]+counterintelligence[\\s\\n]+\\(CI\\)[\\s\\n]+investigations\\.(?:[\\n]+|(?:\\\\n)+)\\-At[\\s\\n]+any[\\s\\n]+time,[\\s\\n]+the[\\s\\n]+USG[\\s\\n]+may[\\s\\n]+inspect[\\s\\n]+and[\\s\\n]+seize[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS\\.(?:[\\n]+|(?:\\\\n)+)\\-Communications[\\s\\n]+using,[\\s\\n]+or[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on,[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+are[\\s\\n]+not[\\s\\n]+private,[\\s\\n]+are[\\s\\n]+subject[\\s\\n]+to[\\s\\n]+routine[\\s\\n]+monitoring,[\\s\\n]+interception,[\\s\\n]+and[\\s\\n]+search,[\\s\\n]+and[\\s\\n]+may[\\s\\n]+be[\\s\\n]+disclosed[\\s\\n]+or[\\s\\n]+used[\\s\\n]+for[\\s\\n]+any[\\s\\n]+USG\\-authorized[\\s\\n]+purpose\\.(?:[\\n]+|(?:\\\\n)+)\\-This[\\s\\n]+IS[\\s\\n]+includes[\\s\\n]+security[\\s\\n]+measures[\\s\\n]+\\(e\\.g\\.,[\\s\\n]+authentication[\\s\\n]+and[\\s\\n]+access[\\s\\n]+controls\\)[\\s\\n]+to[\\s\\n]+protect[\\s\\n]+USG[\\s\\n]+interests\\-\\-not[\\s\\n]+for[\\s\\n]+your[\\s\\n]+personal[\\s\\n]+benefit[\\s\\n]+or[\\s\\n]+privacy\\.(?:[\\n]+|(?:\\\\n)+)\\-Notwithstanding[\\s\\n]+the[\\s\\n]+above,[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+does[\\s\\n]+not[\\s\\n]+constitute[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+PM,[\\s\\n]+LE[\\s\\n]+or[\\s\\n]+CI[\\s\\n]+investigative[\\s\\n]+searching[\\s\\n]+or[\\s\\n]+monitoring[\\s\\n]+of[\\s\\n]+the[\\s\\n]+content[\\s\\n]+of[\\s\\n]+privileged[\\s\\n]+communications,[\\s\\n]+or[\\s\\n]+work[\\s\\n]+product,[\\s\\n]+related[\\s\\n]+to[\\s\\n]+personal[\\s\\n]+representation[\\s\\n]+or[\\s\\n]+services[\\s\\n]+by[\\s\\n]+attorneys,[\\s\\n]+psychotherapists,[\\s\\n]+or[\\s\\n]+clergy,[\\s\\n]+and[\\s\\n]+their[\\s\\n]+assistants\\.[\\s\\n]+Such[\\s\\n]+communications[\\s\\n]+and[\\s\\n]+work[\\s\\n]+product[\\s\\n]+are[\\s\\n]+private[\\s\\n]+and[\\s\\n]+confidential\\.[\\s\\n]+See[\\s\\n]+User[\\s\\n]+Agreement[\\s\\n]+for[\\s\\n]+details\\.|I've[\\s\\n]+read[\\s\\n]+\\&[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+terms[\\s\\n]+in[\\s\\n]+IS[\\s\\n]+user[\\s\\n]+agreem't\\.)$'\n\n\n# Multiple regexes transform the banner regex into a usable banner\n# 0 - Remove anchors around the banner text\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/^\\^\\(.*\\)\\$$/\\1/g')\n# 1 - Keep only the first banners if there are multiple\n#    (dod_banners contains the long and short banner)\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/^(\\(.*\\.\\)|.*)$/\\1/g')\n# 2 - Add spaces ' '. (Transforms regex for \"space or newline\" into a \" \")\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/\\[\\\\s\\\\n\\]+/ /g')\n# 3 - Adds newlines. (Transforms \"(?:\\[\\\\n\\]+|(?:\\\\n)+)\" into \"\\n\")\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/(?:\\[\\\\n\\]+|(?:\\\\n)+)/\\n/g')\n# 4 - Remove any leftover backslash. (From any parethesis in the banner, for example).\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/\\\\//g')\nformatted=$(echo \"$remote_login_banner_text\" | fold -sw 80)\n\ncat <<EOF >/etc/issue.net\n$formatted\nEOF\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"banner_etc_issue_net","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"unknown","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255020\n  - banner_etc_issue_net\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n- name: XCCDF Value remote_login_banner_text # promote to variable\n  set_fact:\n    remote_login_banner_text: !!str ^(You[\\s\\n]+are[\\s\\n]+accessing[\\s\\n]+a[\\s\\n]+U\\.S\\.[\\s\\n]+Government[\\s\\n]+\\(USG\\)[\\s\\n]+Information[\\s\\n]+System[\\s\\n]+\\(IS\\)[\\s\\n]+that[\\s\\n]+is[\\s\\n]+provided[\\s\\n]+for[\\s\\n]+USG\\-authorized[\\s\\n]+use[\\s\\n]+only\\.[\\s\\n]+By[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+\\(which[\\s\\n]+includes[\\s\\n]+any[\\s\\n]+device[\\s\\n]+attached[\\s\\n]+to[\\s\\n]+this[\\s\\n]+IS\\),[\\s\\n]+you[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+the[\\s\\n]+following[\\s\\n]+conditions\\:(?:[\\n]+|(?:\\\\n)+)\\-The[\\s\\n]+USG[\\s\\n]+routinely[\\s\\n]+intercepts[\\s\\n]+and[\\s\\n]+monitors[\\s\\n]+communications[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+for[\\s\\n]+purposes[\\s\\n]+including,[\\s\\n]+but[\\s\\n]+not[\\s\\n]+limited[\\s\\n]+to,[\\s\\n]+penetration[\\s\\n]+testing,[\\s\\n]+COMSEC[\\s\\n]+monitoring,[\\s\\n]+network[\\s\\n]+operations[\\s\\n]+and[\\s\\n]+defense,[\\s\\n]+personnel[\\s\\n]+misconduct[\\s\\n]+\\(PM\\),[\\s\\n]+law[\\s\\n]+enforcement[\\s\\n]+\\(LE\\),[\\s\\n]+and[\\s\\n]+counterintelligence[\\s\\n]+\\(CI\\)[\\s\\n]+investigations\\.(?:[\\n]+|(?:\\\\n)+)\\-At[\\s\\n]+any[\\s\\n]+time,[\\s\\n]+the[\\s\\n]+USG[\\s\\n]+may[\\s\\n]+inspect[\\s\\n]+and[\\s\\n]+seize[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS\\.(?:[\\n]+|(?:\\\\n)+)\\-Communications[\\s\\n]+using,[\\s\\n]+or[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on,[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+are[\\s\\n]+not[\\s\\n]+private,[\\s\\n]+are[\\s\\n]+subject[\\s\\n]+to[\\s\\n]+routine[\\s\\n]+monitoring,[\\s\\n]+interception,[\\s\\n]+and[\\s\\n]+search,[\\s\\n]+and[\\s\\n]+may[\\s\\n]+be[\\s\\n]+disclosed[\\s\\n]+or[\\s\\n]+used[\\s\\n]+for[\\s\\n]+any[\\s\\n]+USG\\-authorized[\\s\\n]+purpose\\.(?:[\\n]+|(?:\\\\n)+)\\-This[\\s\\n]+IS[\\s\\n]+includes[\\s\\n]+security[\\s\\n]+measures[\\s\\n]+\\(e\\.g\\.,[\\s\\n]+authentication[\\s\\n]+and[\\s\\n]+access[\\s\\n]+controls\\)[\\s\\n]+to[\\s\\n]+protect[\\s\\n]+USG[\\s\\n]+interests\\-\\-not[\\s\\n]+for[\\s\\n]+your[\\s\\n]+personal[\\s\\n]+benefit[\\s\\n]+or[\\s\\n]+privacy\\.(?:[\\n]+|(?:\\\\n)+)\\-Notwithstanding[\\s\\n]+the[\\s\\n]+above,[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+does[\\s\\n]+not[\\s\\n]+constitute[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+PM,[\\s\\n]+LE[\\s\\n]+or[\\s\\n]+CI[\\s\\n]+investigative[\\s\\n]+searching[\\s\\n]+or[\\s\\n]+monitoring[\\s\\n]+of[\\s\\n]+the[\\s\\n]+content[\\s\\n]+of[\\s\\n]+privileged[\\s\\n]+communications,[\\s\\n]+or[\\s\\n]+work[\\s\\n]+product,[\\s\\n]+related[\\s\\n]+to[\\s\\n]+personal[\\s\\n]+representation[\\s\\n]+or[\\s\\n]+services[\\s\\n]+by[\\s\\n]+attorneys,[\\s\\n]+psychotherapists,[\\s\\n]+or[\\s\\n]+clergy,[\\s\\n]+and[\\s\\n]+their[\\s\\n]+assistants\\.[\\s\\n]+Such[\\s\\n]+communications[\\s\\n]+and[\\s\\n]+work[\\s\\n]+product[\\s\\n]+are[\\s\\n]+private[\\s\\n]+and[\\s\\n]+confidential\\.[\\s\\n]+See[\\s\\n]+User[\\s\\n]+Agreement[\\s\\n]+for[\\s\\n]+details\\.|I've[\\s\\n]+read[\\s\\n]+\\&[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+terms[\\s\\n]+in[\\s\\n]+IS[\\s\\n]+user[\\s\\n]+agreem't\\.)$\n  tags:\n    - always\n\n- name: Modify the System Login Banner for Remote Connections - ensure correct banner\n  ansible.builtin.copy:\n    dest: /etc/issue.net\n    content: '{{ remote_login_banner_text | regex_replace(\"^\\^(.*)\\$$\", \"\\1\") | regex_replace(\"^\\((.*\\.)\\|.*\\)$\",\n      \"\\1\") | regex_replace(\"\\[\\\\s\\\\n\\]\\+\",\" \") | regex_replace(\"\\(\\?:\\[\\\\n\\]\\+\\|\\(\\?:\\\\\\\\n\\)\\+\\)\",\n      \"\\n\") | regex_replace(\"\\\\\", \"\") | wordwrap() }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255020\n  - banner_etc_issue_net\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"}],"vuln_id":"SV-260525","stig_id":"UBTU-22-255020"},"xccdf_org.ssgproject.content_rule_dconf_gnome_banner_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_dconf_gnome_banner_enabled","title":"Enable GNOME3 Login Warning Banner","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.8.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.9"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-8(a)","AC-8(b)","AC-8(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000023-GPOS-00006","SRG-OS-000228-GPOS-00088"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-271010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260535r958390_rule"]}],"description":"In the default graphical environment, displaying a login warning banner\nin the GNOME Display Manager&#x27;s login screen can be enabled on the login\nscreen by setting <code>banner-message-enable</code> to <code>true</code>.\n<br>\n         <br>\nTo enable, add or edit <code>banner-message-enable</code> to\n<code>/etc/dconf/db/gdm.d/00-security-settings</code>. For example:\n<pre>[org/gnome/login-screen]\nbanner-message-enable=true</pre>\nOnce the setting has been added, add a lock to\n<code>/etc/dconf/db/gdm.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/login-screen/banner-message-enable</pre>\nAfter the settings have been set, run <code>dconf update</code>.\nThe banner text must also be set.","rationale":"Display of a standardized and approved use notification before granting access to the operating system\nensures privacy and security notification verbiage used is consistent with applicable federal laws,\nExecutive Orders, directives, policies, regulations, standards, and guidance.\n<br>\n         <br>\nFor U.S. Government systems, system use notifications are required only for access via login interfaces\nwith human users and are not required when such human interfaces do not exist.","oval_definition_id":"oval:ssg-dconf_gnome_banner_enabled:def:1","remediations":[{"remediation_id":"dconf_gnome_banner_enabled","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'gdm3' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n# Duplicate the setting also in 'greeter.dconf-defaults' for consistency with\n# 'dconf_gnome_login_banner_text' and better alignment with STIG V1R1.\nif [ -e \"/etc/gdm3/greeter.dconf-defaults\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*banner\\-message\\-enable/Id\" \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    touch \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/gdm3/greeter.dconf-defaults\"\n\ncp \"/etc/gdm3/greeter.dconf-defaults\" \"/etc/gdm3/greeter.dconf-defaults.bak\"\n# Insert after the line matching the regex '\\[org/gnome/login-screen\\]'\nline_number=\"$(LC_ALL=C grep -n \"\\[org/gnome/login-screen\\]\" \"/etc/gdm3/greeter.dconf-defaults.bak\" | LC_ALL=C sed 's/:.*//g')\"\nif [ -z \"$line_number\" ]; then\n    # There was no match of '\\[org/gnome/login-screen\\]', insert at\n    # the end of the file.\n    printf '%s\\n' \"banner-message-enable=true\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    head -n \"$(( line_number ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" > \"/etc/gdm3/greeter.dconf-defaults\"\n    printf '%s\\n' \"banner-message-enable=true\" >> \"/etc/gdm3/greeter.dconf-defaults\"\n    tail -n \"+$(( line_number + 1 ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# Clean up after ourselves.\nrm \"/etc/gdm3/greeter.dconf-defaults.bak\"\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|gdm.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/gdm.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*banner-message-enable\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)banner-message-enable(\\s*=)/#\\1banner-message-enable\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/login-screen\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/login-screen]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"true\")\"\nif grep -q \"^\\\\s*banner-message-enable\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*banner-message-enable\\\\s*=\\\\s*.*/banner-message-enable=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\banner-message-enable=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/login-screen/banner-message-enable$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|gdm.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/gdm.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/login-screen/banner-message-enable$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/login-screen/banner-message-enable$\" /etc/dconf/db/gdm.d/\nthen\n    echo \"/org/gnome/login-screen/banner-message-enable\" >> \"/etc/dconf/db/gdm.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260535","stig_id":"UBTU-22-271010"},"xccdf_org.ssgproject.content_rule_dconf_gnome_login_banner_text":{"rule_id":"xccdf_org.ssgproject.content_rule_dconf_gnome_login_banner_text","title":"Set the GNOME3 Login Warning Banner Text","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.8.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.9"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-8(a)","AC-8(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000023-GPOS-00006","SRG-OS-000228-GPOS-00088"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-271015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260536r958390_rule"]}],"description":"In the default graphical environment, configuring the login warning banner text\nin the GNOME Display Manager&#x27;s login screen can be configured on the login\nscreen by setting <code>banner-message-text</code> to <code>&#x27;<i>APPROVED_BANNER</i>&#x27;</code>\nwhere <i>APPROVED_BANNER</i> is the approved banner for your environment.\n<br>\n         <br>\nTo enable, add or edit <code>banner-message-text</code> to\n\n<code>/etc/gdm3/greeter.dconf-defaults</code>. For example:\n<pre>[org/gnome/login-screen]\nbanner-message-text=&#x27;<i>APPROVED_BANNER</i>&#x27;</pre>\n\nAfter the settings have been set, run <code>dconf update</code>.\nWhen entering a warning banner that spans several lines, remember\nto begin and end the string with <code>&#x27;</code> and use <code>\\n</code> for new lines.","rationale":"An appropriate warning message reinforces policy awareness during the logon\nprocess and facilitates possible legal action against attackers.","oval_definition_id":"oval:ssg-dconf_gnome_login_banner_text:def:1","remediations":[{"remediation_id":"dconf_gnome_login_banner_text","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'gdm3' 2>/dev/null | grep -q '^installed$'; then\n\nlogin_banner_text='^(You[\\s\\n]+are[\\s\\n]+accessing[\\s\\n]+a[\\s\\n]+U\\.S\\.[\\s\\n]+Government[\\s\\n]+\\(USG\\)[\\s\\n]+Information[\\s\\n]+System[\\s\\n]+\\(IS\\)[\\s\\n]+that[\\s\\n]+is[\\s\\n]+provided[\\s\\n]+for[\\s\\n]+USG\\-authorized[\\s\\n]+use[\\s\\n]+only\\.[\\s\\n]+By[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+\\(which[\\s\\n]+includes[\\s\\n]+any[\\s\\n]+device[\\s\\n]+attached[\\s\\n]+to[\\s\\n]+this[\\s\\n]+IS\\),[\\s\\n]+you[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+the[\\s\\n]+following[\\s\\n]+conditions\\:(?:[\\n]+|(?:\\\\n)+)\\-The[\\s\\n]+USG[\\s\\n]+routinely[\\s\\n]+intercepts[\\s\\n]+and[\\s\\n]+monitors[\\s\\n]+communications[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+for[\\s\\n]+purposes[\\s\\n]+including,[\\s\\n]+but[\\s\\n]+not[\\s\\n]+limited[\\s\\n]+to,[\\s\\n]+penetration[\\s\\n]+testing,[\\s\\n]+COMSEC[\\s\\n]+monitoring,[\\s\\n]+network[\\s\\n]+operations[\\s\\n]+and[\\s\\n]+defense,[\\s\\n]+personnel[\\s\\n]+misconduct[\\s\\n]+\\(PM\\),[\\s\\n]+law[\\s\\n]+enforcement[\\s\\n]+\\(LE\\),[\\s\\n]+and[\\s\\n]+counterintelligence[\\s\\n]+\\(CI\\)[\\s\\n]+investigations\\.(?:[\\n]+|(?:\\\\n)+)\\-At[\\s\\n]+any[\\s\\n]+time,[\\s\\n]+the[\\s\\n]+USG[\\s\\n]+may[\\s\\n]+inspect[\\s\\n]+and[\\s\\n]+seize[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS\\.(?:[\\n]+|(?:\\\\n)+)\\-Communications[\\s\\n]+using,[\\s\\n]+or[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on,[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+are[\\s\\n]+not[\\s\\n]+private,[\\s\\n]+are[\\s\\n]+subject[\\s\\n]+to[\\s\\n]+routine[\\s\\n]+monitoring,[\\s\\n]+interception,[\\s\\n]+and[\\s\\n]+search,[\\s\\n]+and[\\s\\n]+may[\\s\\n]+be[\\s\\n]+disclosed[\\s\\n]+or[\\s\\n]+used[\\s\\n]+for[\\s\\n]+any[\\s\\n]+USG\\-authorized[\\s\\n]+purpose\\.(?:[\\n]+|(?:\\\\n)+)\\-This[\\s\\n]+IS[\\s\\n]+includes[\\s\\n]+security[\\s\\n]+measures[\\s\\n]+\\(e\\.g\\.,[\\s\\n]+authentication[\\s\\n]+and[\\s\\n]+access[\\s\\n]+controls\\)[\\s\\n]+to[\\s\\n]+protect[\\s\\n]+USG[\\s\\n]+interests\\-\\-not[\\s\\n]+for[\\s\\n]+your[\\s\\n]+personal[\\s\\n]+benefit[\\s\\n]+or[\\s\\n]+privacy\\.(?:[\\n]+|(?:\\\\n)+)\\-Notwithstanding[\\s\\n]+the[\\s\\n]+above,[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+does[\\s\\n]+not[\\s\\n]+constitute[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+PM,[\\s\\n]+LE[\\s\\n]+or[\\s\\n]+CI[\\s\\n]+investigative[\\s\\n]+searching[\\s\\n]+or[\\s\\n]+monitoring[\\s\\n]+of[\\s\\n]+the[\\s\\n]+content[\\s\\n]+of[\\s\\n]+privileged[\\s\\n]+communications,[\\s\\n]+or[\\s\\n]+work[\\s\\n]+product,[\\s\\n]+related[\\s\\n]+to[\\s\\n]+personal[\\s\\n]+representation[\\s\\n]+or[\\s\\n]+services[\\s\\n]+by[\\s\\n]+attorneys,[\\s\\n]+psychotherapists,[\\s\\n]+or[\\s\\n]+clergy,[\\s\\n]+and[\\s\\n]+their[\\s\\n]+assistants\\.[\\s\\n]+Such[\\s\\n]+communications[\\s\\n]+and[\\s\\n]+work[\\s\\n]+product[\\s\\n]+are[\\s\\n]+private[\\s\\n]+and[\\s\\n]+confidential\\.[\\s\\n]+See[\\s\\n]+User[\\s\\n]+Agreement[\\s\\n]+for[\\s\\n]+details\\.|I've[\\s\\n]+read[\\s\\n]+\\&[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+terms[\\s\\n]+in[\\s\\n]+IS[\\s\\n]+user[\\s\\n]+agreem't\\.)$'\n\n\n# Multiple regexes transform the banner regex into a usable banner\n# 0 - Remove anchors around the banner text\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/^\\^\\(.*\\)\\$$/\\1/g')\n# 1 - Keep only the first banners if there are multiple\n#    (dod_banners contains the long and short banner)\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/^(\\(.*\\.\\)|.*)$/\\1/g')\n# 2 - Add spaces ' '. (Transforms regex for \"space or newline\" into a \" \")\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/\\[\\\\s\\\\n\\]+/ /g')\n# 3 - Adds newline \"tokens\". (Transforms \"(?:\\[\\\\n\\]+|(?:\\\\n)+)\" into \"(n)*\")\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/(?:\\[\\\\n\\]+|(?:\\\\n)+)/(n)*/g')\n# 4 - Remove any leftover backslash. (From any parethesis in the banner, for example).\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/\\\\//g')\n# 5 - Removes the newline \"token.\" (Transforms them into newline escape sequences \"\\n\").\n#    ( Needs to be done after 4, otherwise the escapce sequence will become just \"n\".\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/(n)\\*/\\\\n/g')\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n\n# Will do both approach, since we plan to migrate to checks over dconf db. That way, future updates of the tool\n# will pass the check even if we decide to check only for the dconf db path.\nif [ -e \"/etc/gdm3/greeter.dconf-defaults\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*banner\\-message\\-text/Id\" \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    touch \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/gdm3/greeter.dconf-defaults\"\n\ncp \"/etc/gdm3/greeter.dconf-defaults\" \"/etc/gdm3/greeter.dconf-defaults.bak\"\n# Insert after the line matching the regex '\\[org/gnome/login-screen\\]'\nline_number=\"$(LC_ALL=C grep -n \"\\[org/gnome/login-screen\\]\" \"/etc/gdm3/greeter.dconf-defaults.bak\" | LC_ALL=C sed 's/:.*//g')\"\nif [ -z \"$line_number\" ]; then\n    # There was no match of '\\[org/gnome/login-screen\\]', insert at\n    # the end of the file.\n    printf '%s\\n' \"banner-message-text='${login_banner_text}'\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    head -n \"$(( line_number ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" > \"/etc/gdm3/greeter.dconf-defaults\"\n    printf '%s\\n' \"banner-message-text='${login_banner_text}'\" >> \"/etc/gdm3/greeter.dconf-defaults\"\n    tail -n \"+$(( line_number + 1 ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# Clean up after ourselves.\nrm \"/etc/gdm3/greeter.dconf-defaults.bak\"\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|gdm.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/gdm.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*banner-message-text\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)banner-message-text(\\s*=)/#\\1banner-message-text\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/login-screen\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/login-screen]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"'${login_banner_text}'\")\"\nif grep -q \"^\\\\s*banner-message-text\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*banner-message-text\\\\s*=\\\\s*.*/banner-message-text=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\banner-message-text=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# No need to use dconf update, since bash_dconf_settings does that already\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260536","stig_id":"UBTU-22-271015"},"xccdf_org.ssgproject.content_rule_package_pam_pwquality_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_pam_pwquality_installed","title":"Install pam_pwquality Package","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00225"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-215010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260478r991587_rule"]}],"description":"\nThe <code>libpam-pwquality</code> package can be installed with the following command:\n<pre>\n$ apt-get install libpam-pwquality</pre>\n       ","rationale":"Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure\nof the effectiveness of a password in resisting attempts at guessing and\nbrute-force attacks. &quot;pwquality&quot; enforces complex password construction\nconfiguration and has the ability to limit brute-force attacks on the system.","platforms":["#package_pam"],"oval_definition_id":"oval:ssg-package_pam_pwquality_installed:def:1","remediations":[{"remediation_id":"package_pam_pwquality_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"libpam-pwquality\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_pam_pwquality_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_libpam-pwquality\n\nclass install_libpam-pwquality {\n  package { 'libpam-pwquality':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_pam_pwquality_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"libpam-pwquality\"\nversion = \"*\"\n"},{"remediation_id":"package_pam_pwquality_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-215010\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_pam_pwquality_installed\n\n- name: Ensure libpam-pwquality is installed\n  ansible.builtin.package:\n    name: libpam-pwquality\n    state: present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-215010\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_pam_pwquality_installed\n"}],"vuln_id":"SV-260478","stig_id":"UBTU-22-215010"},"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faildelay_delay":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faildelay_delay","title":"Enforce Delay After Failed Logon Attempts","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00226"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-412010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260550r991588_rule"]}],"description":"To configure the system to introduce a delay after failed logon attempts,\nadd or correct the <code>pam_faildelay</code> settings in\n<code>/etc/pam.d/common-auth</code> to make sure its <code>delay</code> parameter\nis at least 4000000 or greater. For example:\n<pre>auth required pam_faildelay.so delay=4000000\n         </pre>\n        ","rationale":"Limiting the number of logon attempts over a certain time interval reduces\nthe chances that an unauthorized user may gain access to an account.","platforms":["#package_pam"],"oval_definition_id":"oval:ssg-accounts_passwords_pam_faildelay_delay:def:1","remediations":[{"remediation_id":"accounts_passwords_pam_faildelay_delay","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_delay='4000000'\n\ncat << EOF > /usr/share/pam-configs/cac_faildelay\nName: Enable faildelay\nConflicts: faildelay\nDefault: yes\nPriority: 513\nAuth-Type: Primary\nAuth:\n    required                   pam_faildelay.so delay=$var_password_pam_delay\nEOF\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update --enable cac_faildelay\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260550","stig_id":"UBTU-22-412010"},"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_audit":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_audit","title":"Account Lockouts Must Be Logged","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-7 (a)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000021-GPOS-00005"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260549r958388_rule"]}],"description":"PAM faillock locks an account due to excessive password failures, this event must be logged.","rationale":"Without auditing of these events it may be harder or impossible to identify what an attacker did after an attack.","platforms":["#package_pam"],"oval_definition_id":"oval:ssg-accounts_passwords_pam_faillock_audit:def:1","remediations":[{"remediation_id":"accounts_passwords_pam_faillock_audit","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \nconf_name=cac_faillock\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\" ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"\nName: Enable pam_faillock to deny access\nDefault: yes\nConflicts: faillock\nPriority: 0\nAuth-Type: Primary\nAuth:\n    [default=die]                   pam_faillock.so authfail\n    sufficient                      pam_faillock.so authsucc\nEOF\nfi\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\"_notify ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"_notify\nName: Notify of failed login attempts and reset count upon success\nDefault: yes\nConflicts: faillock_notify\nPriority: 1025\nAuth-Type: Primary\nAuth:\n    requisite                       pam_faillock.so preauth\nAccount-Type: Primary\nAccount:\n    required                        pam_faillock.so\nEOF\nfi\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\nSKIP_FAILLOCK_CHECK=true\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ] || [ \"$SKIP_FAILLOCK_CHECK\" = \"true\" ]; then\n    regex=\"^\\s*audit\"\n    line=\"audit\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    fi\n    \nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so\\s+(preauth|authfail).*audit' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*/ s/$/ audit/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_passwords_pam_faillock_audit","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Check if system relies on pam-auth-update\n    tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Remediation where pam-auth-update tool is\n    present\n  block:\n\n  - name: Account Lockouts Must Be Logged - Check the presence of cac_faillock file\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_faillock\n    register: faillock_file_stat\n\n  - name: Account Lockouts Must Be Logged - Check the presence of cac_faillock_notify\n      file\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_faillock_notify\n    register: faillock_notify_file_stat\n\n  - name: Account Lockouts Must Be Logged - Put the content into cac_faillock if it\n      does not exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_faillock\n      content: |\n        Name: Enable pam_faillock to deny access\n        Default: yes\n        Priority: 0\n        Conflicts: faillock\n        Auth-Type: Primary\n        Auth:\n          [default=die]                   pam_faillock.so authfail\n          sufficient                      pam_faillock.so authsucc\n      force: true\n    when: not faillock_file_stat.stat.exists\n\n  - name: Account Lockouts Must Be Logged - Put the content into cac_faillock_notify\n      if it does not exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_faillock_notify\n      content: |\n        Name: Notify of failed login attempts and reset count upon success\n        Default: yes\n        Priority: 1025\n        Conflicts: faillock_notify\n        Auth-Type: Primary\n        Auth:\n          requisite                       pam_faillock.so preauth\n        Account-Type: Primary\n        Account:\n          required                        pam_faillock.so\n      force: true\n    when: not faillock_notify_file_stat.stat.exists\n\n  - name: None - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_faillock\n\n  - name: None - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_faillock_notify\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Check the presence of /etc/security/faillock.conf\n    file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Ensure the pam_faillock.so audit parameter\n    in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*audit\n    line: audit\n    state: present\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Ensure the pam_faillock.so audit parameter\n    not in PAM files\n  block:\n\n  - name: Account Lockouts Must Be Logged - Check if /etc/pam.d/system-auth file is\n      present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Account Lockouts Must Be Logged - Check the proper remediation for the system\n    block:\n\n    - name: Account Lockouts Must Be Logged - Define the PAM file to be edited as\n        a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Account Lockouts Must Be Logged - Check if system relies on authselect\n        tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect custom profile is\n        used if authselect is present\n      block:\n\n      - name: Account Lockouts Must Be Logged - Check integrity of authselect current\n          profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        check_mode: false\n        failed_when: false\n\n      - name: Account Lockouts Must Be Logged - Informative message based on the authselect\n          integrity check result\n        ansible.builtin.assert:\n          that:\n          - ansible_check_mode or result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Account Lockouts Must Be Logged - Get authselect current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Account Lockouts Must Be Logged - Define the current authselect profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Define the new authselect custom profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Get authselect current features to\n          also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        check_mode: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Check if any custom profile with the\n          same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Create an authselect custom profile\n          based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"^(custom/|local)\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Account Lockouts Must Be Logged - Create an authselect custom profile\n          based on sssd profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b sssd\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is match(\"local\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Ensure the authselect custom profile\n          is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Restore the authselect features in\n          the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Account Lockouts Must Be Logged - Change the PAM file to be edited according\n          to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n        when:\n        - authselect_custom_profile is defined\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Account Lockouts Must Be Logged - Define a fact for control already filtered\n        in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Account Lockouts Must Be Logged - Check if {{ pam_file_path }} file is\n        present\n      ansible.builtin.stat:\n        path: '{{ pam_file_path }}'\n      register: result_pam_file_present\n\n    - name: Account Lockouts Must Be Logged - Ensure the \"audit\" option from \"pam_faillock.so\"\n        is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\baudit\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n      when: result_pam_file_present.stat.exists\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Account Lockouts Must Be Logged - Check if /etc/pam.d/password-auth file\n      is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Account Lockouts Must Be Logged - Check the proper remediation for the system\n    block:\n\n    - name: Account Lockouts Must Be Logged - Define the PAM file to be edited as\n        a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Account Lockouts Must Be Logged - Check if system relies on authselect\n        tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect custom profile is\n        used if authselect is present\n      block:\n\n      - name: Account Lockouts Must Be Logged - Check integrity of authselect current\n          profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        check_mode: false\n        failed_when: false\n\n      - name: Account Lockouts Must Be Logged - Informative message based on the authselect\n          integrity check result\n        ansible.builtin.assert:\n          that:\n          - ansible_check_mode or result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Account Lockouts Must Be Logged - Get authselect current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Account Lockouts Must Be Logged - Define the current authselect profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Define the new authselect custom profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Get authselect current features to\n          also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        check_mode: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Check if any custom profile with the\n          same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Create an authselect custom profile\n          based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"^(custom/|local)\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Account Lockouts Must Be Logged - Create an authselect custom profile\n          based on sssd profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b sssd\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is match(\"local\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Ensure the authselect custom profile\n          is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Restore the authselect features in\n          the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Account Lockouts Must Be Logged - Change the PAM file to be edited according\n          to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n        when:\n        - authselect_custom_profile is defined\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Account Lockouts Must Be Logged - Define a fact for control already filtered\n        in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Account Lockouts Must Be Logged - Check if {{ pam_file_path }} file is\n        present\n      ansible.builtin.stat:\n        path: '{{ pam_file_path }}'\n      register: result_pam_file_present\n\n    - name: Account Lockouts Must Be Logged - Ensure the \"audit\" option from \"pam_faillock.so\"\n        is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\baudit\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n      when: result_pam_file_present.stat.exists\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Ensure the pam_faillock.so audit parameter\n    in PAM files\n  block:\n\n  - name: Account Lockouts Must Be Logged - Check if pam_faillock.so audit parameter\n      is already enabled in pam files\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail).*audit\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_audit_parameter_is_present\n\n  - name: Account Lockouts Must Be Logged - Ensure the inclusion of pam_faillock.so\n      preauth audit parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)\n      line: \\1required\\3 audit\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_audit_parameter_is_present.found == 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260549","stig_id":"UBTU-22-411045"},"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny","title":"Lock Accounts After Failed Password Attempts","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.3"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.8"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-7(a)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000021-GPOS-00005","SRG-OS-000329-GPOS-00128"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FIA_AFL.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.6"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260549r958388_rule"]}],"description":"This rule configures the system to lock out accounts after a number of incorrect login attempts\nusing <code>pam_faillock.so</code>.\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected.\nEnsure that the file <code>/etc/security/faillock.conf</code> contains the following entry:\n<code>deny = &lt;count&gt;</code>\nWhere count should be less than or equal to\n3 and greater than 0.","rationale":"By limiting the number of failed logon attempts, the risk of unauthorized system access via\nuser password guessing, also known as brute-forcing, is reduced. Limits are imposed by locking\nthe account.","warnings":[{"text":"If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.","category":"general"}],"platforms":["#package_pam"],"oval_definition_id":"oval:ssg-accounts_passwords_pam_faillock_deny:def:1","remediations":[{"remediation_id":"accounts_passwords_pam_faillock_deny","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_passwords_pam_faillock_deny='3'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \nconf_name=cac_faillock\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\" ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"\nName: Enable pam_faillock to deny access\nDefault: yes\nConflicts: faillock\nPriority: 0\nAuth-Type: Primary\nAuth:\n    [default=die]                   pam_faillock.so authfail\n    sufficient                      pam_faillock.so authsucc\nEOF\nfi\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\"_notify ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"_notify\nName: Notify of failed login attempts and reset count upon success\nDefault: yes\nConflicts: faillock_notify\nPriority: 1025\nAuth-Type: Primary\nAuth:\n    requisite                       pam_faillock.so preauth\nAccount-Type: Primary\nAccount:\n    required                        pam_faillock.so\nEOF\nfi\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\nSKIP_FAILLOCK_CHECK=true\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ] || [ \"$SKIP_FAILLOCK_CHECK\" = \"true\" ]; then\n    regex=\"^\\s*deny\\s*=\"\n    line=\"deny = $var_accounts_passwords_pam_faillock_deny\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(deny\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_deny\"'|g' $FAILLOCK_CONF\n    fi\n    \nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so\\s+(preauth|authfail).*deny' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*/ s/$/ deny='\"$var_accounts_passwords_pam_faillock_deny\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*authfail.*/ s/$/ deny='\"$var_accounts_passwords_pam_faillock_deny\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*preauth.*\\)\\('\"deny\"'=\\)\\S\\+\\b\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_deny\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*authfail.*\\)\\('\"deny\"'=\\)\\S\\+\\b\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_deny\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260549","stig_id":"UBTU-22-411045"},"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_interval":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_interval","title":"Set Interval For Counting Failed Password Attempts","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-7(a)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000021-GPOS-00005","SRG-OS-000329-GPOS-00128"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FIA_AFL.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260549r958388_rule"]}],"description":"Utilizing <code>pam_faillock.so</code>, the <code>fail_interval</code> directive configures the system\nto lock out an account after a number of incorrect login attempts within a specified time\nperiod.\n\nEnsure that the file <code>/etc/security/faillock.conf</code> contains the following entry:\n<code>fail_interval = &lt;interval-in-seconds&gt;</code> where <code>interval-in-seconds</code> is <code>900</code> or greater.","rationale":"By limiting the number of failed logon attempts the risk of unauthorized system\naccess via user password guessing, otherwise known as brute-forcing, is reduced.\nLimits are imposed by locking the account.","warnings":[{"text":"If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.","category":"general"}],"platforms":["#package_pam"],"oval_definition_id":"oval:ssg-accounts_passwords_pam_faillock_interval:def:1","remediations":[{"remediation_id":"accounts_passwords_pam_faillock_interval","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_passwords_pam_faillock_fail_interval='900'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \nconf_name=cac_faillock\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\" ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"\nName: Enable pam_faillock to deny access\nDefault: yes\nConflicts: faillock\nPriority: 0\nAuth-Type: Primary\nAuth:\n    [default=die]                   pam_faillock.so authfail\n    sufficient                      pam_faillock.so authsucc\nEOF\nfi\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\"_notify ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"_notify\nName: Notify of failed login attempts and reset count upon success\nDefault: yes\nConflicts: faillock_notify\nPriority: 1025\nAuth-Type: Primary\nAuth:\n    requisite                       pam_faillock.so preauth\nAccount-Type: Primary\nAccount:\n    required                        pam_faillock.so\nEOF\nfi\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\nSKIP_FAILLOCK_CHECK=true\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ] || [ \"$SKIP_FAILLOCK_CHECK\" = \"true\" ]; then\n    regex=\"^\\s*fail_interval\\s*=\"\n    line=\"fail_interval = $var_accounts_passwords_pam_faillock_fail_interval\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(fail_interval\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_fail_interval\"'|g' $FAILLOCK_CONF\n    fi\n    \nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so\\s+(preauth|authfail).*fail_interval' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*/ s/$/ fail_interval='\"$var_accounts_passwords_pam_faillock_fail_interval\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*authfail.*/ s/$/ fail_interval='\"$var_accounts_passwords_pam_faillock_fail_interval\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*preauth.*\\)\\('\"fail_interval\"'=\\)\\S\\+\\b\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_fail_interval\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*authfail.*\\)\\('\"fail_interval\"'=\\)\\S\\+\\b\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_fail_interval\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260549","stig_id":"UBTU-22-411045"},"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_silent":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_silent","title":"Do Not Show System Messages When Unsuccessful Logon Attempts Occur","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000021-GPOS-00005","SRG-OS-000329-GPOS-00128"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260549r958388_rule"]}],"description":"This rule ensures the system prevents informative messages from being presented to the user\npertaining to logon information after a number of incorrect login attempts using\n<code>pam_faillock.so</code>.\n\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected. In order to avoid errors when manually editing these files, it is\nrecommended to use the appropriate tools, such as <code>authselect</code> or <code>authconfig</code>,\ndepending on the OS version.","rationale":"The pam_faillock module without the silent option will leak information about the existence or\nnon-existence of a user account in the system because the failures are not recorded for unknown\nusers. The message about the user account being locked is never displayed for non-existing user\naccounts allowing the adversary to infer that a particular account exists or not on the system.","warnings":[{"text":"If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.","category":"general"}],"platforms":["#package_pam"],"oval_definition_id":"oval:ssg-accounts_passwords_pam_faillock_silent:def:1","remediations":[{"remediation_id":"accounts_passwords_pam_faillock_silent","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \nconf_name=cac_faillock\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\" ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"\nName: Enable pam_faillock to deny access\nDefault: yes\nConflicts: faillock\nPriority: 0\nAuth-Type: Primary\nAuth:\n    [default=die]                   pam_faillock.so authfail\n    sufficient                      pam_faillock.so authsucc\nEOF\nfi\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\"_notify ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"_notify\nName: Notify of failed login attempts and reset count upon success\nDefault: yes\nConflicts: faillock_notify\nPriority: 1025\nAuth-Type: Primary\nAuth:\n    requisite                       pam_faillock.so preauth\nAccount-Type: Primary\nAccount:\n    required                        pam_faillock.so\nEOF\nfi\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\nSKIP_FAILLOCK_CHECK=true\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ] || [ \"$SKIP_FAILLOCK_CHECK\" = \"true\" ]; then\n    regex=\"^\\s*silent\"\n    line=\"silent\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    fi\n    \nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so\\s+(preauth|authfail).*silent' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*/ s/$/ silent/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_passwords_pam_faillock_silent","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n    if system relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Remediation\n    where pam-auth-update tool is present\n  block:\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      the presence of cac_faillock file\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_faillock\n    register: faillock_file_stat\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      the presence of cac_faillock_notify file\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_faillock_notify\n    register: faillock_notify_file_stat\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Put\n      the content into cac_faillock if it does not exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_faillock\n      content: |\n        Name: Enable pam_faillock to deny access\n        Default: yes\n        Priority: 0\n        Conflicts: faillock\n        Auth-Type: Primary\n        Auth:\n          [default=die]                   pam_faillock.so authfail\n          sufficient                      pam_faillock.so authsucc\n      force: true\n    when: not faillock_file_stat.stat.exists\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Put\n      the content into cac_faillock_notify if it does not exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_faillock_notify\n      content: |\n        Name: Notify of failed login attempts and reset count upon success\n        Default: yes\n        Priority: 1025\n        Conflicts: faillock_notify\n        Auth-Type: Primary\n        Auth:\n          requisite                       pam_faillock.so preauth\n        Account-Type: Primary\n        Account:\n          required                        pam_faillock.so\n      force: true\n    when: not faillock_notify_file_stat.stat.exists\n\n  - name: None - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_faillock\n\n  - name: None - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_faillock_notify\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n    the presence of /etc/security/faillock.conf file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n    the pam_faillock.so silent parameter in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*silent\n    line: silent\n    state: present\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n    the pam_faillock.so silent parameter not in PAM files\n  block:\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      if /etc/pam.d/system-auth file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      the proper remediation for the system\n    block:\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Define\n        the PAM file to be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n        if system relies on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n        authselect custom profile is used if authselect is present\n      block:\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Check integrity of authselect current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        check_mode: false\n        failed_when: false\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Informative message based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - ansible_check_mode or result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Get authselect current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Define the current authselect profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Define the new authselect custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Get authselect current features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        check_mode: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Check if any custom profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Create an authselect custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"^(custom/|local)\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Create an authselect custom profile based on sssd profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b sssd\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is match(\"local\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Ensure the authselect custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Restore the authselect features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Change the PAM file to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n        when:\n        - authselect_custom_profile is defined\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Define\n        a fact for control already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n        if {{ pam_file_path }} file is present\n      ansible.builtin.stat:\n        path: '{{ pam_file_path }}'\n      register: result_pam_file_present\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n        the \"silent\" option from \"pam_faillock.so\" is not present in {{ pam_file_path\n        }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bsilent\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n      when: result_pam_file_present.stat.exists\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n        authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      if /etc/pam.d/password-auth file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      the proper remediation for the system\n    block:\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Define\n        the PAM file to be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n        if system relies on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n        authselect custom profile is used if authselect is present\n      block:\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Check integrity of authselect current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        check_mode: false\n        failed_when: false\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Informative message based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - ansible_check_mode or result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Get authselect current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Define the current authselect profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Define the new authselect custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Get authselect current features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        check_mode: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Check if any custom profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Create an authselect custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"^(custom/|local)\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Create an authselect custom profile based on sssd profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b sssd\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is match(\"local\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Ensure the authselect custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Restore the authselect features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur -\n          Change the PAM file to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n        when:\n        - authselect_custom_profile is defined\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Define\n        a fact for control already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n        if {{ pam_file_path }} file is present\n      ansible.builtin.stat:\n        path: '{{ pam_file_path }}'\n      register: result_pam_file_present\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n        the \"silent\" option from \"pam_faillock.so\" is not present in {{ pam_file_path\n        }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bsilent\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n      when: result_pam_file_present.stat.exists\n\n    - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n        authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n    the pam_faillock.so silent parameter in PAM files\n  block:\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n      the inclusion of pam_faillock.so preauth silent parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth(:?(?!silent).)*)\n      line: \\1required\\3 silent\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-411045\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260549","stig_id":"UBTU-22-411045"},"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time","title":"Set Lockout Time for Failed Password Attempts","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.3"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.8"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-7(b)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000021-GPOS-00005","SRG-OS-000329-GPOS-00128"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FIA_AFL.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.7"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260549r958388_rule"]}],"description":"This rule configures the system to lock out accounts during a specified time period after a\nnumber of incorrect login attempts using <code>pam_faillock.so</code>.\n\nEnsure that the file <code>/etc/security/faillock.conf</code> contains the following entry:\n<code>unlock_time=&lt;interval-in-seconds&gt;</code> where\n<code>interval-in-seconds</code> is <code>0</code> or greater.\n\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected. In order to avoid any errors when manually editing these files,\nit is recommended to use the appropriate tools, such as <code>authselect</code> or <code>authconfig</code>,\ndepending on the OS version.\n\nIf <code>unlock_time</code> is set to <code>0</code>, manual intervention by an administrator is required\nto unlock a user. This should be done using the <code>faillock</code> tool.","rationale":"By limiting the number of failed logon attempts the risk of unauthorized system\naccess via user password guessing, otherwise known as brute-forcing, is reduced.\nLimits are imposed by locking the account.","warnings":[{"text":"If the system supports the new <code>/etc/security/faillock.conf</code> file but the\npam_faillock.so parameters are defined directly in <code>/etc/pam.d/system-auth</code> and\n<code>/etc/pam.d/password-auth</code>, the remediation will migrate the <code>unlock_time</code> parameter\nto <code>/etc/security/faillock.conf</code> to ensure compatibility with <code>authselect</code> tool.\nThe parameters <code>deny</code> and <code>fail_interval</code>, if used, also have to be migrated\nby their respective remediation.","category":"general"},{"text":"If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.","category":"general"}],"platforms":["#package_pam"],"oval_definition_id":"oval:ssg-accounts_passwords_pam_faillock_unlock_time:def:1","remediations":[{"remediation_id":"accounts_passwords_pam_faillock_unlock_time","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_passwords_pam_faillock_unlock_time='0'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \nconf_name=cac_faillock\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\" ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"\nName: Enable pam_faillock to deny access\nDefault: yes\nConflicts: faillock\nPriority: 0\nAuth-Type: Primary\nAuth:\n    [default=die]                   pam_faillock.so authfail\n    sufficient                      pam_faillock.so authsucc\nEOF\nfi\n\nif [ ! -f /usr/share/pam-configs/\"$conf_name\"_notify ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"_notify\nName: Notify of failed login attempts and reset count upon success\nDefault: yes\nConflicts: faillock_notify\nPriority: 1025\nAuth-Type: Primary\nAuth:\n    requisite                       pam_faillock.so preauth\nAccount-Type: Primary\nAccount:\n    required                        pam_faillock.so\nEOF\nfi\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\nSKIP_FAILLOCK_CHECK=true\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ] || [ \"$SKIP_FAILLOCK_CHECK\" = \"true\" ]; then\n    regex=\"^\\s*unlock_time\\s*=\"\n    line=\"unlock_time = $var_accounts_passwords_pam_faillock_unlock_time\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(unlock_time\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_unlock_time\"'|g' $FAILLOCK_CONF\n    fi\n    \nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so\\s+(preauth|authfail).*unlock_time' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*/ s/$/ unlock_time='\"$var_accounts_passwords_pam_faillock_unlock_time\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*authfail.*/ s/$/ unlock_time='\"$var_accounts_passwords_pam_faillock_unlock_time\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*preauth.*\\)\\('\"unlock_time\"'=\\)\\S\\+\\b\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_unlock_time\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*authfail.*\\)\\('\"unlock_time\"'=\\)\\S\\+\\b\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_unlock_time\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260549","stig_id":"UBTU-22-411045"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit","title":"Ensure PAM Enforces Password Requirements - Minimum Digit Characters","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(a)","IA-5(4)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000071-GPOS-00039"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260562r1015014_rule"]}],"description":"The pam_pwquality module&#x27;s <code>dcredit</code> parameter controls requirements for\nusage of digits in a password. When set to a negative number, any password will be required to\ncontain that many digits. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each digit. Modify the <code>dcredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of a digit in passwords.","rationale":"Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossible combinations that need to be tested before the password is compromised.\nRequiring digits makes password guessing attacks more difficult by ensuring a larger\nsearch space.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_dcredit:def:1","remediations":[{"remediation_id":"accounts_password_pam_dcredit","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_dcredit='-1'\n\n\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^dcredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dcredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^dcredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^dcredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_dcredit","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-611020\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_dcredit # promote to variable\n  set_fact:\n    var_password_pam_dcredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Digit Characters - Check\n    if system relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611020\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Digit Characters - Remediation\n    where pam-auth-update tool is present\n  block:\n\n  - name: Check if /usr/share/pam-configs/cac_pwquality exists\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_pwquality\n    register: pwquality_file_stat\n\n  - name: Put the content into /usr/share/pam-configs/cac_pwquality if it does not\n      exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_pwquality\n      content: |\n        Name: Pwquality password strength checking\n        Default: yes\n        Priority: 1024\n        Conflicts: cracklib\n        Password-Type: Primary\n        Password:\n          requisite           pam_pwquality.so retry=3\n      force: true\n    when: not pwquality_file_stat.stat.exists\n\n  - name: Ensure PAM Enforces Password Requirements - Minimum Digit Characters - Ensure\n      pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_pwquality\n  when:\n  - '\"libpwquality1\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-611020\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Digit Characters - Ensure\n    PAM variable dcredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*dcredit\n    line: dcredit = {{ var_password_pam_dcredit }}\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611020\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260562","stig_id":"UBTU-22-611020"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_dictcheck":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_dictcheck","title":"Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(a)","IA-5(4)","IA-5(c)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000072-GPOS-00040","SRG-OS-000480-GPOS-00225"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260564r991587_rule"]}],"description":"The pam_pwquality module&#x27;s <code>dictcheck</code> check if passwords contains dictionary words. When\n<code>dictcheck</code> is set to <code>1</code> passwords will be checked for dictionary words.","rationale":"Use of a complex password helps to increase the time and resources required to compromise the password.\nPassword complexity, or strength, is a measure of the effectiveness of a password in resisting attempts at\nguessing and brute-force attacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes to crack a password. The more\ncomplex the password, the greater the number of possible combinations that need to be tested before the\npassword is compromised.\n<br>\n          <br>\nPasswords with dictionary words may be more vulnerable to password-guessing attacks.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_dictcheck:def:1","remediations":[{"remediation_id":"accounts_password_pam_dictcheck","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_dictcheck='1'\n\n\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^dictcheck\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dictcheck\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^dictcheck\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^dictcheck\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_dictcheck","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-611030\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_dictcheck\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_dictcheck # promote to variable\n  set_fact:\n    var_password_pam_dictcheck: !!str 1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary\n    Words - Check if system relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611030\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_dictcheck\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary\n    Words - Remediation where pam-auth-update tool is present\n  block:\n\n  - name: Check if /usr/share/pam-configs/cac_pwquality exists\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_pwquality\n    register: pwquality_file_stat\n\n  - name: Put the content into /usr/share/pam-configs/cac_pwquality if it does not\n      exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_pwquality\n      content: |\n        Name: Pwquality password strength checking\n        Default: yes\n        Priority: 1024\n        Conflicts: cracklib\n        Password-Type: Primary\n        Password:\n          requisite           pam_pwquality.so retry=3\n      force: true\n    when: not pwquality_file_stat.stat.exists\n\n  - name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary\n      Words - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_pwquality\n  when:\n  - '\"libpwquality1\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-611030\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_dictcheck\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary\n    Words - Ensure PAM variable dictcheck is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*dictcheck\n    line: dictcheck = {{ var_password_pam_dictcheck }}\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611030\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_dictcheck\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260564","stig_id":"UBTU-22-611030"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_difok":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_difok","title":"Ensure PAM Enforces Password Requirements - Minimum Different Characters","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.6.2.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(b)","IA-5(4)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000072-GPOS-00040"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260566r1015017_rule"]}],"description":"The pam_pwquality module&#x27;s <code>difok</code> parameter sets the number of characters\nin a password that must not be present in and old password during a password change.\n<br>\n          <br>\nModify the <code>difok</code> setting in <code>/etc/security/pwquality.conf</code>\nto equal 8 to require differing characters\nwhen changing passwords.","rationale":"Use of a complex password helps to increase the time and resources\nrequired to compromise the password. Password complexity, or strength,\nis a measure of the effectiveness of a password in resisting attempts\nat guessing and bruteforce attacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long\nit takes to crack a password. The more complex the password, the\ngreater the number of possible combinations that need to be tested\nbefore the password is compromised.\n<br>\n          <br>\nRequiring a minimum number of different characters during password changes ensures that\nnewly changed passwords should not resemble previously compromised ones.\nNote that passwords which are changed on compromised systems will still be compromised, however.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_difok:def:1","remediations":[{"remediation_id":"accounts_password_pam_difok","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_difok='8'\n\n\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^difok\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_difok\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^difok\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^difok\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_difok","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611040\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(b)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_difok\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_difok # promote to variable\n  set_fact:\n    var_password_pam_difok: !!str 8\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Different Characters -\n    Check if system relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611040\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(b)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_difok\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Different Characters -\n    Remediation where pam-auth-update tool is present\n  block:\n\n  - name: Check if /usr/share/pam-configs/cac_pwquality exists\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_pwquality\n    register: pwquality_file_stat\n\n  - name: Put the content into /usr/share/pam-configs/cac_pwquality if it does not\n      exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_pwquality\n      content: |\n        Name: Pwquality password strength checking\n        Default: yes\n        Priority: 1024\n        Conflicts: cracklib\n        Password-Type: Primary\n        Password:\n          requisite           pam_pwquality.so retry=3\n      force: true\n    when: not pwquality_file_stat.stat.exists\n\n  - name: Ensure PAM Enforces Password Requirements - Minimum Different Characters\n      - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_pwquality\n  when:\n  - '\"libpwquality1\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611040\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(b)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_difok\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Different Characters -\n    Ensure PAM variable difok is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*difok\n    line: difok = {{ var_password_pam_difok }}\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611040\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(b)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_difok\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260566","stig_id":"UBTU-22-611040"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_enforcing":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_enforcing","title":"Ensure PAM Enforces Password Requirements - Enforcing","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00225"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260567r991587_rule"]}],"description":"Verify that the operating system uses &quot;pwquality&quot; to enforce the\npassword complexity rules.\n\nVerify the pwquality module is being enforced by operating system by\nrunning the following command:\n<pre>\n$ grep -i enforcing /etc/security/pwquality.conf\nenforcing = 1\n</pre>\n\nIf the value of &quot;enforcing&quot; is not &quot;1&quot; or the line is commented out,\nthis is a finding.","rationale":"Use of a complex password helps to increase the time and resources\nrequired to compromise the password. Password complexity, or strength,\nis a measure of the effectiveness of a password in resisting attempts at\nguessing and brute-force attacks. Using enforcing=1 ensures &quot;pwquality&quot;\nenforces complex password construction configuration and has the ability\nto limit brute-force attacks on the system.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_enforcing:def:1","remediations":[{"remediation_id":"accounts_password_pam_enforcing","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nif [ -e \"/etc/security/pwquality.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*enforcing = 1/Id\" \"/etc/security/pwquality.conf\"\nelse\n    touch \"/etc/security/pwquality.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/security/pwquality.conf\"\n\ncp \"/etc/security/pwquality.conf\" \"/etc/security/pwquality.conf.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"enforcing = 1\" >> \"/etc/security/pwquality.conf\"\n# Clean up after ourselves.\nrm \"/etc/security/pwquality.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_enforcing","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-611045\n  - accounts_password_pam_enforcing\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Enforcing\n  ansible.builtin.lineinfile:\n    path: /etc/security/pwquality.conf\n    create: true\n    regexp: ''\n    line: enforcing = 1\n    state: present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611045\n  - accounts_password_pam_enforcing\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260567","stig_id":"UBTU-22-611045"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit","title":"Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(a)","IA-5(4)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000070-GPOS-00038"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260561r1015013_rule"]}],"description":"The pam_pwquality module&#x27;s <code>lcredit</code> parameter controls requirements for\nusage of lowercase letters in a password. When set to a negative number, any password will be required to\ncontain that many lowercase characters. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each lowercase character. Modify the <code>lcredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of a lowercase character in passwords.","rationale":"Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossble combinations that need to be tested before the password is compromised.\nRequiring a minimum number of lowercase characters makes password guessing attacks\nmore difficult by ensuring a larger search space.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_lcredit:def:1","remediations":[{"remediation_id":"accounts_password_pam_lcredit","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_lcredit='-1'\n\n\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^lcredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_lcredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^lcredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^lcredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_lcredit","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-611015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_lcredit # promote to variable\n  set_fact:\n    var_password_pam_lcredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters -\n    Check if system relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters -\n    Remediation where pam-auth-update tool is present\n  block:\n\n  - name: Check if /usr/share/pam-configs/cac_pwquality exists\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_pwquality\n    register: pwquality_file_stat\n\n  - name: Put the content into /usr/share/pam-configs/cac_pwquality if it does not\n      exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_pwquality\n      content: |\n        Name: Pwquality password strength checking\n        Default: yes\n        Priority: 1024\n        Conflicts: cracklib\n        Password-Type: Primary\n        Password:\n          requisite           pam_pwquality.so retry=3\n      force: true\n    when: not pwquality_file_stat.stat.exists\n\n  - name: Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters\n      - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_pwquality\n  when:\n  - '\"libpwquality1\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-611015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters -\n    Ensure PAM variable lcredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*lcredit\n    line: lcredit = {{ var_password_pam_lcredit }}\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260561","stig_id":"UBTU-22-611015"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen","title":"Ensure PAM Enforces Password Requirements - Minimum Length","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31","R68"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.6.2.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(a)","IA-5(4)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000078-GPOS-00046"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260565r1015016_rule"]}],"description":"The pam_pwquality module&#x27;s <code>minlen</code> parameter controls requirements for\nminimum characters required in a password. Add <code>minlen=15\n          </code>\nafter pam_pwquality to set minimum password length requirements.","rationale":"The shorter the password, the lower the number of possible combinations\nthat need to be tested before the password is compromised.\n<br>\nPassword complexity, or strength, is a measure of the effectiveness of a\npassword in resisting attempts at guessing and brute-force attacks.\nPassword length is one factor of several that helps to determine strength\nand how long it takes to crack a password. Use of more characters in a password\nhelps to exponentially increase the time and/or resources required to\ncompromise the password.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_minlen:def:1","remediations":[{"remediation_id":"accounts_password_pam_minlen","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_minlen='15'\n\n\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^minlen\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minlen\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^minlen\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^minlen\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_minlen","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611035\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_minlen # promote to variable\n  set_fact:\n    var_password_pam_minlen: !!str 15\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Length - Check if system\n    relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611035\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Length - Remediation where\n    pam-auth-update tool is present\n  block:\n\n  - name: Check if /usr/share/pam-configs/cac_pwquality exists\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_pwquality\n    register: pwquality_file_stat\n\n  - name: Put the content into /usr/share/pam-configs/cac_pwquality if it does not\n      exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_pwquality\n      content: |\n        Name: Pwquality password strength checking\n        Default: yes\n        Priority: 1024\n        Conflicts: cracklib\n        Password-Type: Primary\n        Password:\n          requisite           pam_pwquality.so retry=3\n      force: true\n    when: not pwquality_file_stat.stat.exists\n\n  - name: Ensure PAM Enforces Password Requirements - Minimum Length - Ensure pam-auth-update\n      profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_pwquality\n  when:\n  - '\"libpwquality1\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611035\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Length - Ensure PAM variable\n    minlen is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*minlen\n    line: minlen = {{ var_password_pam_minlen }}\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-22-611035\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260565","stig_id":"UBTU-22-611035"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_ocredit":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_ocredit","title":"Ensure PAM Enforces Password Requirements - Minimum Special Characters","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(a)","IA-5(4)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000266-GPOS-00101"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260563r1015015_rule"]}],"description":"The pam_pwquality module&#x27;s <code>ocredit=</code> parameter controls requirements for\nusage of special (or &quot;other&quot;) characters in a password. When set to a negative number,\nany password will be required to contain that many special characters.\nWhen set to a positive number, pam_pwquality will grant +1\nadditional length credit for each special character. Modify the <code>ocredit</code> setting\nin <code>/etc/security/pwquality.conf</code> to equal -1\nto require use of a special character in passwords.","rationale":"Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossible combinations that need to be tested before the password is compromised.\nRequiring a minimum number of special characters makes password guessing attacks\nmore difficult by ensuring a larger search space.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_ocredit:def:1","remediations":[{"remediation_id":"accounts_password_pam_ocredit","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_ocredit='-1'\n\n\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ocredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ocredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^ocredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^ocredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_ocredit","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-611025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_ocredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_ocredit # promote to variable\n  set_fact:\n    var_password_pam_ocredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Special Characters - Check\n    if system relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_ocredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Special Characters - Remediation\n    where pam-auth-update tool is present\n  block:\n\n  - name: Check if /usr/share/pam-configs/cac_pwquality exists\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_pwquality\n    register: pwquality_file_stat\n\n  - name: Put the content into /usr/share/pam-configs/cac_pwquality if it does not\n      exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_pwquality\n      content: |\n        Name: Pwquality password strength checking\n        Default: yes\n        Priority: 1024\n        Conflicts: cracklib\n        Password-Type: Primary\n        Password:\n          requisite           pam_pwquality.so retry=3\n      force: true\n    when: not pwquality_file_stat.stat.exists\n\n  - name: Ensure PAM Enforces Password Requirements - Minimum Special Characters -\n      Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_pwquality\n  when:\n  - '\"libpwquality1\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-611025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_ocredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Special Characters - Ensure\n    PAM variable ocredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*ocredit\n    line: ocredit = {{ var_password_pam_ocredit }}\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611025\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_ocredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260563","stig_id":"UBTU-22-611025"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_retry":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_retry","title":"Ensure PAM Enforces Password Requirements - Authentication Retry Prompts Permitted Per-Session","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R68"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","15","16","3","5","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.3"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4","4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.2","A.12.5.1","A.12.6.2","A.14.2.2","A.14.2.3","A.14.2.4","A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-7(a)","CM-6(a)","IA-5(4)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7","PR.IP-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000069-GPOS-00037","SRG-OS-000480-GPOS-00227"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260567r991587_rule"]}],"description":"To configure the number of retry prompts that are permitted per-session:\n\nEdit the <code>pam_pwquality.so</code> statement in\n\n<code>/etc/pam.d/common-password</code> to show\n\n\n<code>retry=3\n          </code>, or a lower value if site\npolicy is more restrictive. The profile requirement is a maximum of <code>retry=3\n          </code> prompts\nper session.","rationale":"Setting the password retry prompts that are permitted on a per-session basis to a low value\nrequires some software, such as SSH, to re-connect. This can slow down and\ndraw additional attention to some types of password-guessing attacks. Note that this\nis different from account lockout, which is provided by the pam_faillock module.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_retry:def:1","remediations":[{"remediation_id":"accounts_password_pam_retry","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_retry='3'\n\n\nconf_name=cac_pwquality\nif [ ! -f /usr/share/pam-configs/\"$conf_name\" ]; then\n    cat << EOF > /usr/share/pam-configs/\"$conf_name\"\nName: Pwquality password strength checking\nDefault: yes\nPriority: 1025\nConflicts: cracklib, pwquality\nPassword-Type: Primary\nPassword:\n    requisite                   pam_pwquality.so\nEOF\nfi\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\nPWQUALITY_CONF=\"/etc/security/pwquality.conf\"\n    regex=\"^\\s*retry\\s*=\"\n    line=\"retry = $var_password_pam_retry\"\n    if ! grep -q $regex $PWQUALITY_CONF; then\n        echo $line >> $PWQUALITY_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(retry\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_password_pam_retry\"'|g' $PWQUALITY_CONF\n    fi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260567","stig_id":"UBTU-22-611045"},"xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit","title":"Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters","result":"fail","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R31"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0421","0422","0431","0974","1173","1401","1504","1505","1546","1557","1558","1559","1560","1561"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(a)","IA-5(4)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000069-GPOS-00037","SRG-OS-000070-GPOS-00038"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260560r1015012_rule"]}],"description":"The pam_pwquality module&#x27;s <code>ucredit=</code> parameter controls requirements for\nusage of uppercase letters in a password. When set to a negative number, any password will be required to\ncontain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each uppercase character. Modify the <code>ucredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of an uppercase character in passwords.","rationale":"Use of a complex password helps to increase the time and resources required to compromise the password.\nPassword complexity, or strength, is a measure of the effectiveness of a password in resisting attempts\nat guessing and brute-force attacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes to crack a password. The more\ncomplex the password, the greater the number of possible combinations that need to be tested before\nthe password is compromised.","platforms":["#package_libpwquality"],"oval_definition_id":"oval:ssg-accounts_password_pam_ucredit:def:1","remediations":[{"remediation_id":"accounts_password_pam_ucredit","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpwquality1' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_pam_ucredit='-1'\n\n\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ucredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ucredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^ucredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^ucredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_password_pam_ucredit","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-611010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_ucredit # promote to variable\n  set_fact:\n    var_password_pam_ucredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters -\n    Check if system relies on pam-auth-update tool\n  ansible.builtin.stat:\n    path: /usr/sbin/pam-auth-update\n  register: result_pam_auth_update_present\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters -\n    Remediation where pam-auth-update tool is present\n  block:\n\n  - name: Check if /usr/share/pam-configs/cac_pwquality exists\n    ansible.builtin.stat:\n      path: /usr/share/pam-configs/cac_pwquality\n    register: pwquality_file_stat\n\n  - name: Put the content into /usr/share/pam-configs/cac_pwquality if it does not\n      exist\n    ansible.builtin.copy:\n      dest: /usr/share/pam-configs/cac_pwquality\n      content: |\n        Name: Pwquality password strength checking\n        Default: yes\n        Priority: 1024\n        Conflicts: cracklib\n        Password-Type: Primary\n        Password:\n          requisite           pam_pwquality.so retry=3\n      force: true\n    when: not pwquality_file_stat.stat.exists\n\n  - name: Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters\n      - Ensure pam-auth-update profile changes are applied\n    ansible.builtin.command:\n      cmd: pam-auth-update --enable cac_pwquality\n  when:\n  - '\"libpwquality1\" in ansible_facts.packages'\n  - result_pam_auth_update_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-611010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters -\n    Ensure PAM variable ucredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*ucredit\n    line: ucredit = {{ var_password_pam_ucredit }}\n  when: '\"libpwquality1\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611010\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260560","stig_id":"UBTU-22-611010"},"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_logindefs":{"rule_id":"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_logindefs","title":"Set Password Hashing Algorithm in /etc/login.defs","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.4.4"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.6.2.2"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.13.11"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0418","1055","1402"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(c)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000073-GPOS-00041"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.1"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611070"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260572r971535_rule"]}],"description":"In <code>/etc/login.defs</code>, add or update the following line to ensure the system will use\nSHA512 as the hashing algorithm:\n<pre>ENCRYPT_METHOD SHA512\n         </pre>\n        ","rationale":"Passwords need to be protected at all times, and encryption is the standard method for\nprotecting passwords. If passwords are not encrypted, they can be plainly read\n(i.e., clear text) and easily compromised. Passwords that are encrypted with a weak algorithm\nare no more protected than if they are kept in plain text.\n<br>\n         <br>\nUsing a stronger hashing algorithm makes password cracking attacks more difficult.","platforms":["#package_shadow-utils"],"oval_definition_id":"oval:ssg-set_password_hashing_algorithm_logindefs:def:1","remediations":[{"remediation_id":"set_password_hashing_algorithm_logindefs","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'login' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_hashing_algorithm='SHA512'\n\n\n# Allow multiple algorithms, but choose the first one for remediation\n#\nvar_password_hashing_algorithm=\"$(echo $var_password_hashing_algorithm | cut -d \\| -f 1)\"\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ENCRYPT_METHOD\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_password_hashing_algorithm\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^ENCRYPT_METHOD\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^ENCRYPT_METHOD\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260572","stig_id":"UBTU-22-611070"},"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_systemauth":{"rule_id":"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_systemauth","title":"Set PAM''s Password Hashing Algorithm","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R68"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.6.2.2"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.13.11"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0418","1055","1402"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(c)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000073-GPOS-00041","SRG-OS-000120-GPOS-00061"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.1"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611055"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260569r1044767_rule"]}],"description":"The PAM system service can be configured to only store encrypted representations of passwords.\nIn &quot;/etc/pam.d/common-password&quot;, the <code>password</code> section of the file controls which\nPAM modules to execute during a password change.\n\nSet the <code>pam_unix.so</code> module in the <code>password</code> section to include the option\n<code>sha512</code> and no other hashing\nalgorithms as shown below:\n<br>\n         <pre>password    [success=1 default=ignore]   pam_unix.so sha512\n          <i>other arguments...</i>\n         </pre>\n         <br>\nThis will help ensure that new passwords for local users will be stored using the\nsha512 algorithm.","rationale":"Passwords need to be protected at all times, and encryption is the standard method for\nprotecting passwords. If passwords are not encrypted, they can be plainly read\n(i.e., clear text) and easily compromised. Passwords that are encrypted with a weak algorithm\nare no more protected than if they are kept in plain text.\n<br>\n         <br>\nThis setting ensures user and group account administration utilities are configured to store\nonly encrypted representations of passwords. Additionally, the <code>crypt_style</code>\nconfiguration option in <code>/etc/libuser.conf</code> ensures the use of a strong hashing\nalgorithm that makes password cracking attacks more difficult.","warnings":[{"text":"The hashing algorithms to be used with pam_unix.so are defined with independent module\noptions. There are at least 7 possible algorithms and likely more algorithms will be\nintroduced along the time. Due the the number of options and its possible combinations,\nthe use of multiple hashing algorithm options may bring unexpected behaviors to the\nsystem. For this reason the check will pass only when one hashing algorithm option is\ndefined and is aligned to the &quot;var_password_hashing_algorithm_pam&quot; variable. The\nremediation will ensure the correct option and remove any other extra hashing algorithm\noption.","category":"general"}],"platforms":["#package_pam"],"oval_definition_id":"oval:ssg-set_password_hashing_algorithm_systemauth:def:1","remediations":[{"remediation_id":"set_password_hashing_algorithm_systemauth","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nvar_password_hashing_algorithm_pam='sha512'\n\n\nconf_name=cac_unix\nconf_path=\"/usr/share/pam-configs\"\n\nif [ ! -f \"$conf_path\"/\"$conf_name\" ]; then\n    if [ -f \"$conf_path\"/unix ]; then\n        if grep -q \"$(md5sum \"$conf_path\"/unix | cut -d ' ' -f 1)\" /var/lib/dpkg/info/libpam-runtime.md5sums;then\n            cp \"$conf_path\"/unix \"$conf_path\"/\"$conf_name\"\n            sed -i 's/Priority: [0-9]\\+/Priority: 257\\\nConflicts: unix/' \"$conf_path\"/\"$conf_name\"\n            DEBIAN_FRONTEND=noninteractive pam-auth-update\n        else\n            echo \"Not applicable - checksum of $conf_path/unix does not match the original.\" >&2\n        fi\n    else\n        echo \"Not applicable - $conf_path/unix does not exist\" >&2\n    fi\nfi\nPAM_FILE_PATH=/usr/share/pam-configs/cac_unix\n\n# Ensure all the hashing algorithm option is removed.\ndeclare -a HASHING_ALGORITHMS_OPTIONS=(\"sha512\" \"yescrypt\" \"gost_yescrypt\" \"blowfish\" \"sha256\" \"md5\" \"bigcrypt\")\n\nfor hash_option in \"${HASHING_ALGORITHMS_OPTIONS[@]}\"; do\n  sed -i -E '/^Password:/,/^[^[:space:]]/ {\n    /pam_unix\\.so/ {\n      s/\\s*\\b'\"$hash_option\"'\\b//g\n    }\n    }' \"$PAM_FILE_PATH\"\n    sed -i -E '/^Password-Initial:/,/^[^[:space:]]/ {\n    /pam_unix\\.so/ {\n      s/\\s*\\b'\"$hash_option\"'\\b//g\n    }\n    }' \"$PAM_FILE_PATH\"\n    DEBIAN_FRONTEND=noninteractive pam-auth-update\ndone\n\nif ! grep -qzP \"Password:\\s*\\n\\s+.*\\s+pam_unix.so\\s+.*\\b$var_password_hashing_algorithm_pam\\b\" \"$PAM_FILE_PATH\"; then\n  sed -i -E '/^Password:/,/^[^[:space:]]/ {\n    /pam_unix\\.so/ {\n        s/$/ '\"$var_password_hashing_algorithm_pam\"'/g\n    }\n}' \"$PAM_FILE_PATH\"\nfi\n\nif ! grep -qzP \"Password-Initial:\\s*\\n\\s+.*\\s+pam_unix.so\\s+.*\\b$var_password_hashing_algorithm_pam\\b\" \"$PAM_FILE_PATH\"; then\n  sed -i -E '/^Password-Initial:/,/^[^[:space:]]/ {\n    /pam_unix\\.so/ {\n        s/$/ '\"$var_password_hashing_algorithm_pam\"'/g\n    }\n}' \"$PAM_FILE_PATH\"\nfi\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"set_password_hashing_algorithm_systemauth","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.6.2.2\n  - DISA-STIG-UBTU-22-611055\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n- name: XCCDF Value var_password_hashing_algorithm_pam # promote to variable\n  set_fact:\n    var_password_hashing_algorithm_pam: !!str sha512\n  tags:\n    - always\n\n- name: Set PAM's Password Hashing Algorithm - Check if /etc/pam.d/system-auth file\n    is present\n  ansible.builtin.stat:\n    path: /etc/pam.d/system-auth\n  register: result_pam_file_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.2\n  - DISA-STIG-UBTU-22-611055\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n\n- name: Set PAM's Password Hashing Algorithm - Check the proper remediation for the\n    system\n  block:\n\n  - name: Set PAM's Password Hashing Algorithm - Define the PAM file to be edited\n      as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/system-auth\n\n  - name: Set PAM's Password Hashing Algorithm - Check if system relies on authselect\n      tool\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure authselect custom profile\n      is used if authselect is present\n    block:\n\n    - name: Set PAM's Password Hashing Algorithm - Check integrity of authselect current\n        profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      check_mode: false\n      failed_when: false\n\n    - name: Set PAM's Password Hashing Algorithm - Informative message based on the\n        authselect integrity check result\n      ansible.builtin.assert:\n        that:\n        - ansible_check_mode or result_authselect_check_cmd.rc == 0\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Set PAM's Password Hashing Algorithm - Get authselect current profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Set PAM's Password Hashing Algorithm - Define the current authselect profile\n        as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Define the new authselect custom\n        profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Get authselect current features\n        to also enable them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      check_mode: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Check if any custom profile with\n        the same name was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Create an authselect custom profile\n        based on the current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"^(custom/|local)\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Set PAM's Password Hashing Algorithm - Create an authselect custom profile\n        based on sssd profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b sssd\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is match(\"local\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure the authselect custom profile\n        is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - Restore the authselect features\n        in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - Change the PAM file to be edited\n        according to the custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n      when:\n      - authselect_custom_profile is defined\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Set PAM's Password Hashing Algorithm - Define a fact for control already\n      filtered in case filters are used\n    ansible.builtin.set_fact:\n      pam_module_control: sufficient\n\n  - name: Set PAM's Password Hashing Algorithm - Check if expected PAM module line\n      is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+{{ pam_module_control | regex_escape() }}\\s+pam_unix.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Set PAM's Password Hashing Algorithm - Include or update the PAM module\n      line in {{ pam_file_path }}\n    block:\n\n    - name: Set PAM's Password Hashing Algorithm - Check if required PAM module line\n        is present in {{ pam_file_path }} with different control\n      ansible.builtin.lineinfile:\n        path: '{{ pam_file_path }}'\n        regexp: ^\\s*password\\s+.*\\s+pam_unix.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure the correct control for\n        the required PAM module line in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: ^(\\s*password\\s+).*(\\bpam_unix.so.*)\n        replace: \\1{{ pam_module_control }} \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure the required PAM module\n        line is included in {{ pam_file_path }}\n      ansible.builtin.lineinfile:\n        dest: '{{ pam_file_path }}'\n        line: password    {{ pam_module_control }}    pam_unix.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present is defined\n      - result_authselect_present.stat.exists\n      - |-\n        (result_pam_module_add is defined and result_pam_module_add.changed)\n         or (result_pam_module_edit is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Set PAM's Password Hashing Algorithm - Define a fact for control already\n      filtered in case filters are used\n    ansible.builtin.set_fact:\n      pam_module_control: sufficient\n\n  - name: Set PAM's Password Hashing Algorithm - Check if the required PAM module\n      option is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+{{ pam_module_control | regex_escape() }}\\s+pam_unix.so\\s*.*\\s{{\n        var_password_hashing_algorithm_pam }}\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_set_password_hashing_algorithm_systemauth_option_present\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure the \"{{ var_password_hashing_algorithm_pam\n      }}\" PAM option for \"pam_unix.so\" is included in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*password\\s+{{ pam_module_control | regex_escape() }}\\s+pam_unix.so.*)\n      line: \\1 {{ var_password_hashing_algorithm_pam }}\n      state: present\n    register: result_pam_set_password_hashing_algorithm_systemauth_add\n    when:\n    - result_pam_module_set_password_hashing_algorithm_systemauth_option_present.found\n      is defined\n    - result_pam_module_set_password_hashing_algorithm_systemauth_option_present.found\n      == 0\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - |-\n      (result_pam_set_password_hashing_algorithm_systemauth_add is defined and result_pam_set_password_hashing_algorithm_systemauth_add.changed)\n       or (result_pam_set_password_hashing_algorithm_systemauth_edit is defined and result_pam_set_password_hashing_algorithm_systemauth_edit.changed)\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CJIS-5.6.2.2\n  - DISA-STIG-UBTU-22-611055\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n\n- name: Set PAM's Password Hashing Algorithm - Check if /etc/pam.d/system-auth File\n    is Present\n  ansible.builtin.stat:\n    path: /etc/pam.d/system-auth\n  register: result_pam_file_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.2\n  - DISA-STIG-UBTU-22-611055\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n\n- name: Set PAM's Password Hashing Algorithm - Check The Proper Remediation For The\n    System\n  block:\n\n  - name: Set PAM's Password Hashing Algorithm - Define the PAM file to be edited\n      as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/system-auth\n\n  - name: Set PAM's Password Hashing Algorithm - Check if system relies on authselect\n      tool\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure authselect custom profile\n      is used if authselect is present\n    block:\n\n    - name: Set PAM's Password Hashing Algorithm - Check integrity of authselect current\n        profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      check_mode: false\n      failed_when: false\n\n    - name: Set PAM's Password Hashing Algorithm - Informative message based on the\n        authselect integrity check result\n      ansible.builtin.assert:\n        that:\n        - ansible_check_mode or result_authselect_check_cmd.rc == 0\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Set PAM's Password Hashing Algorithm - Get authselect current profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Set PAM's Password Hashing Algorithm - Define the current authselect profile\n        as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Define the new authselect custom\n        profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Get authselect current features\n        to also enable them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      check_mode: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Check if any custom profile with\n        the same name was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Create an authselect custom profile\n        based on the current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"^(custom/|local)\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Set PAM's Password Hashing Algorithm - Create an authselect custom profile\n        based on sssd profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b sssd\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is match(\"local\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure the authselect custom profile\n        is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - Restore the authselect features\n        in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - Change the PAM file to be edited\n        according to the custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n      when:\n      - authselect_custom_profile is defined\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Set PAM's Password Hashing Algorithm - Check if \"{{ pam_file_path }}\" File\n      is Present\n    ansible.builtin.stat:\n      path: '{{ pam_file_path }}'\n    register: pam_file_path_present\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure That Only the Correct Hashing\n      Algorithm Option For pam_unix.so Is Used in {{ pam_file_path }}\n    ansible.builtin.replace:\n      dest: '{{ pam_file_path }}'\n      regexp: (^\\s*password.*pam_unix\\.so.*)\\b{{ item }}\\b\\s*(.*)\n      replace: \\1\\2\n    when:\n    - item != var_password_hashing_algorithm_pam\n    - pam_file_path_present.stat.exists\n    loop:\n    - sha512\n    - yescrypt\n    - gost_yescrypt\n    - blowfish\n    - sha256\n    - md5\n    - bigcrypt\n    register: result_pam_hashing_options_removal\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - result_pam_hashing_options_removal is changed\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CJIS-5.6.2.2\n  - DISA-STIG-UBTU-22-611055\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n"}],"vuln_id":"SV-260569","stig_id":"UBTU-22-611055"},"xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_reboot":{"rule_id":"xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_reboot","title":"Disable Ctrl-Alt-Del Reboot Activation","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["12","13","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.07","DSS06.02"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.4.5"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(B)","164.308(a)(7)(i)","164.308(a)(7)(ii)(A)","164.310(a)(1)","164.310(a)(2)(i)","164.310(a)(2)(ii)","164.310(a)(2)(iii)","164.310(b)","164.310(c)","164.310(d)(1)","164.310(d)(2)(iii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.7.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000324-GPOS-00125","SRG-OS-000480-GPOS-00227"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FAU_GEN.1.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-211015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260469r991589_rule"]}],"description":"By default, <code>SystemD</code> will reboot the system if the <code>Ctrl-Alt-Del</code>\nkey sequence is pressed.\n<br>\n        <br>\nTo configure the system to ignore the <code>Ctrl-Alt-Del</code> key sequence from the\n\ncommand line instead of rebooting the system, do either of the following:\n<pre>ln -sf /dev/null /etc/systemd/system/ctrl-alt-del.target</pre>\nor\n<pre>systemctl mask ctrl-alt-del.target</pre>\n        <br>\n        <br>\nDo not simply delete the <code>/usr/lib/systemd/system/ctrl-alt-del.service</code> file,\nas this file may be restored during future system updates.","rationale":"A locally logged-in user who presses Ctrl-Alt-Del, when at the console,\ncan reboot the system. If accidentally pressed, as could happen in\nthe case of mixed OS environment, this can create the risk of short-term\nloss of availability of systems due to unintentional reboot.","platforms":["#not_container"],"oval_definition_id":"oval:ssg-disable_ctrlaltdel_reboot:def:1","remediations":[{"remediation_id":"disable_ctrlaltdel_reboot","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ); }; then\n\nif /bin/false ; then\n    systemctl disable ctrl-alt-del.target\n    systemctl mask ctrl-alt-del.target\nelse\n    systemctl disable --now ctrl-alt-del.target\n    systemctl mask --now ctrl-alt-del.target\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"disable_ctrlaltdel_reboot","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-211015\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - disable_ctrlaltdel_reboot\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n\n- name: Disable Ctrl-Alt-Del Reboot Activation\n  ansible.builtin.systemd:\n    name: ctrl-alt-del.target\n    force: true\n    masked: true\n    state: stopped\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_virtualization_type in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n    )\n  tags:\n  - DISA-STIG-UBTU-22-211015\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - disable_ctrlaltdel_reboot\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n"}],"vuln_id":"SV-260469","stig_id":"UBTU-22-211015"},"xccdf_org.ssgproject.content_rule_vlock_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_vlock_installed","title":"Check that vlock is installed to allow session locking","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000028-GPOS-00009","SRG-OS-000030-GPOS-00011"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-412025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260553r1015010_rule"]}],"description":"The Ubuntu 22.04 operating system must have vlock installed to allow for session locking.\n\n\nThe <code>vlock</code> package can be installed with the following command:\n<pre>\n$ apt-get install vlock</pre>\n         ","rationale":"A session lock is a temporary action taken when a user stops work and\nmoves away from the immediate physical vicinity of the information\nsystem but does not want to log out because of the temporary nature of\nthe absence.\n\nThe session lock is implemented at the point where session activity can\nbe determined.\n\nRegardless of where the session lock is determined and implemented,\nonce invoked, the session lock must remain in place until the user\nreauthenticates. No other activity aside from reauthentication must\nunlock the system.","oval_definition_id":"oval:ssg-vlock_installed:def:1","remediations":[{"remediation_id":"vlock_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"vlock\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"vlock_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_vlock\n\nclass install_vlock {\n  package { 'vlock':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"vlock_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"vlock\"\nversion = \"*\"\n"},{"remediation_id":"vlock_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-412025\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - vlock_installed\n\n- name: Ensure vlock is installed\n  ansible.builtin.package:\n    name: vlock\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-412025\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - vlock_installed\n"}],"vuln_id":"SV-260553","stig_id":"UBTU-22-412025"},"xccdf_org.ssgproject.content_rule_package_opensc_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_opensc_installed","title":"Install the opensc Package For Multifactor Authentication","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["1382","1384","1386"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000375-GPOS-00160","SRG-OS-000376-GPOS-00161"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260574r958816_rule"]}],"description":"\nThe <code>opensc-pkcs11</code> package can be installed with the following command:\n<pre>\n$ apt-get install opensc-pkcs11</pre>\n         ","rationale":"Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards\nor similar secure authentication devices issued by an organization or identity provider.","oval_definition_id":"oval:ssg-package_opensc_installed:def:1","remediations":[{"remediation_id":"package_opensc_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"opensc-pkcs11\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_opensc_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_opensc-pkcs11\n\nclass install_opensc-pkcs11 {\n  package { 'opensc-pkcs11':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_opensc_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"opensc-pkcs11\"\nversion = \"*\"\n"},{"remediation_id":"package_opensc_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-612015\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_opensc_installed\n\n- name: Ensure opensc-pkcs11 is installed\n  ansible.builtin.package:\n    name: opensc-pkcs11\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-612015\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_opensc_installed\n"}],"vuln_id":"SV-260574","stig_id":"UBTU-22-612015"},"xccdf_org.ssgproject.content_rule_install_smartcard_packages":{"rule_id":"xccdf_org.ssgproject.content_rule_install_smartcard_packages","title":"Install Smart Card Packages For Multifactor Authentication","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000105-GPOS-00052","SRG-OS-000375-GPOS-00160","SRG-OS-000375-GPOS-00161","SRG-OS-000377-GPOS-00162"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260573r1015019_rule"]}],"description":"Configure the operating system to implement multifactor authentication by\ninstalling the required package with the following command:\n\nThe <code>libpam-pkcs11</code> package can be installed with the following command:\n<pre>\n$ apt-get install libpam-pkcs11</pre>\n         ","rationale":"Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards\nor similar secure authentication devices issued by an organization or identity provider.","platforms":["#not_s390x_arch"],"oval_definition_id":"oval:ssg-install_smartcard_packages:def:1","remediations":[{"remediation_id":"install_smartcard_packages","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( grep -sqE \"^.*\\.s390x$\" /proc/sys/kernel/osrelease || grep -sqE \"^s390x$\" /proc/sys/kernel/arch; ); }; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y -o Dpkg::Options::=\"--path-include=/usr/share/doc/libpam-pkcs11/*\" \"libpam-pkcs11\"\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nsed -i -e 's/debug = true/debug = false/g' \\\n    -e 's|module = /usr/lib/opensc-pkcs11|module = /usr/lib/'\"$(uname -m)\"'-linux-gnu/pkcs11/opensc-pkcs11|' /etc/pam_pkcs11/pam_pkcs11.conf\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"install_smartcard_packages","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_libpam-pkcs11\n\nclass install_libpam-pkcs11 {\n  package { 'libpam-pkcs11':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"install_smartcard_packages","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"libpam-pkcs11\"\nversion = \"*\"\n"},{"remediation_id":"install_smartcard_packages","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-612010\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.3\n  - enable_strategy\n  - install_smartcard_packages\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure libpam-pkcs11 is installed\n  ansible.builtin.package:\n    name: libpam-pkcs11\n    state: present\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture != \"s390x\"\n  tags:\n  - DISA-STIG-UBTU-22-612010\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.3\n  - enable_strategy\n  - install_smartcard_packages\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260573","stig_id":"UBTU-22-612010"},"xccdf_org.ssgproject.content_rule_smartcard_configure_ca":{"rule_id":"xccdf_org.ssgproject.content_rule_smartcard_configure_ca","title":"Configure Smart Card Certificate Authority Validation","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000066-GPOS-00034","SRG-OS-000384-GPOS-00167"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260577r986294_rule"]}],"description":"Configure the operating system to do certificate status checking for PKI\nauthentication. Modify all of the <code>cert_policy</code> lines in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> to include <code>ca</code> like so:\n<pre>cert_policy = ca, ocsp_on, signature;</pre>\n         ","rationale":"Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards\nor similar secure authentication devices issued by an organization or identity provider.","oval_definition_id":"oval:ssg-smartcard_configure_ca:def:1","remediations":[{"remediation_id":"smartcard_configure_ca","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nif grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"ca\"; then\n    sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260577","stig_id":"UBTU-22-612030"},"xccdf_org.ssgproject.content_rule_smartcard_configure_cert_checking":{"rule_id":"xccdf_org.ssgproject.content_rule_smartcard_configure_cert_checking","title":"Configure Smart Card Certificate Status Checking","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000375-GPOS-00160","SRG-OS-000376-GPOS-00161","SRG-OS-000377-GPOS-00162","SRG-OS-000384-GPOS-00167"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260576r958818_rule"]}],"description":"Configure the operating system to do certificate status checking for PKI\nauthentication. Modify all of the <code>cert_policy</code> lines in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> to include <code>ocsp_on</code> like so:\n<pre>cert_policy = ca, ocsp_on, signature;</pre>\n         ","rationale":"Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards\nor similar secure authentication devices issued by an organization or identity provider.","platforms":["#not_s390x_arch"],"oval_definition_id":"oval:ssg-smartcard_configure_cert_checking:def:1","remediations":[{"remediation_id":"smartcard_configure_cert_checking","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( grep -sqE \"^.*\\.s390x$\" /proc/sys/kernel/osrelease || grep -sqE \"^s390x$\" /proc/sys/kernel/arch; ); }; then\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nif grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"ocsp_on\"; then\n    sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260576","stig_id":"UBTU-22-612025"},"xccdf_org.ssgproject.content_rule_smartcard_configure_crl":{"rule_id":"xccdf_org.ssgproject.content_rule_smartcard_configure_crl","title":"Configure Smart Card Local Cache of Revocation Data","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000384-GPOS-00167"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260578r1015021_rule"]}],"description":"Configure the operating system for PKI-based authentication to use\nlocal revocation data when unable to access the network to obtain it\nremotely. Modify all of the <code>cert_policy</code> lines in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> to include <code>crl_auto</code>\nor <code>crl_offline</code> like so:\n<pre>cert_policy = ca,signature,ocsp_on,crl_auto;</pre>\n         ","rationale":"Without configuring a local cache of revocation data, there is the\npotential to allow access to users who are no longer authorized\n(users with revoked certificates).","oval_definition_id":"oval:ssg-smartcard_configure_crl:def:1","remediations":[{"remediation_id":"smartcard_configure_crl","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nif grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -Eqv 'crl_auto|crl_offline'; then\n    sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on,crl_auto;/\" /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260578","stig_id":"UBTU-22-612035"},"xccdf_org.ssgproject.content_rule_smartcard_pam_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_smartcard_pam_enabled","title":"Enable Smart Card Logins in PAM","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000068-GPOS-00036","SRG-OS-000105-GPOS-00052","SRG-OS-000106-GPOS-00053","SRG-OS-000107-GPOS-00054","SRG-OS-000108-GPOS-00055","SRG-OS-000375-GPOS-00160","SRG-OS-000375-GPOS-00161","SRG-OS-000375-GPOS-00162"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260575r1044770_rule"]}],"description":"This requirement only applies to components where this is specific to the\nfunction of the device or has the concept of an organizational user (e.g.,\nVPN, proxy capability). This does not apply to authentication for the\npurpose of configuring the device itself (management).\n\n\nAdd or update the following line in <code>/etc/pam.d/common-auth</code>,\nplacing it above any lines containing <code>pam_unix.so</code>:\n<pre>auth    [success=2 default=ignore] pam_pkcs11.so </pre>\n\n\nFor general information about enabling smart card authentication, consult\nthe documentation at:\n\n<ul><li><b><a href=\"https://pages.ubuntu.com/rs/066-EOV-335/images/SmartCardLogin_WhitePapaer_04.03.20.pdf\">https://pages.ubuntu.com/rs/066-EOV-335/images/SmartCardLogin_WhitePapaer_04.03.20.pdf</a></b></li></ul>\n         ","rationale":"Smart card login provides two-factor authentication stronger than\nthat provided by a username and password combination. Smart cards leverage PKI\n(public key infrastructure) in order to provide and verify credentials.\n\nUsing an authentication device, such as a CAC or token that is separate\nfrom the information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n\nMultifactor solutions that require devices separate from information\nsystems gaining access include, for example, hardware tokens providing\ntime-based or challenge-response authenticators and smart cards\nor similar secure authentication devices issued by an organization or identity provider.","oval_definition_id":"oval:ssg-smartcard_pam_enabled:def:1","remediations":[{"remediation_id":"smartcard_pam_enabled","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\ncat << EOF > /usr/share/pam-configs/cac_pkcs11\nName: Enable pkcs11\nConflicts: pkcs11\nDefault: yes\nPriority: 512\nAuth-Type: Primary\nAuth:\n    [success=end default=ignore]\tpam_pkcs11.so\nEOF\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update --enable cac_pkcs11\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260575","stig_id":"UBTU-22-612020"},"xccdf_org.ssgproject.content_rule_verify_use_mappers":{"rule_id":"xccdf_org.ssgproject.content_rule_verify_use_mappers","title":"Verify that 'use_mappers' is set to 'pwent' in PAM","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"low","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000068-GPOS-00036"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260579r958452_rule"]}],"description":"The operating system must map the authenticated identity to the user or\ngroup account for PKI-based authentication.\n\nVerify that <code>use_mappers</code> is set to <code>pwent</code> in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> file with the following command:\n\n<pre>$ grep ^use_mappers /etc/pam_pkcs11/pam_pkcs11.conf\n\nuse_mappers = pwent</pre>\n         ","rationale":"Without mapping the certificate used to authenticate to the user account,\nthe ability to determine the identity of the individual user or group will\nnot be available for forensic analysis.","oval_definition_id":"oval:ssg-verify_use_mappers:def:1","remediations":[{"remediation_id":"verify_use_mappers","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif [ -e \"/etc/pam_pkcs11/pam_pkcs11.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*use_mappers = pwent/Id\" \"/etc/pam_pkcs11/pam_pkcs11.conf\"\nelse\n    touch \"/etc/pam_pkcs11/pam_pkcs11.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/pam_pkcs11/pam_pkcs11.conf\"\n\ncp \"/etc/pam_pkcs11/pam_pkcs11.conf\" \"/etc/pam_pkcs11/pam_pkcs11.conf.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"use_mappers = pwent\" >> \"/etc/pam_pkcs11/pam_pkcs11.conf\"\n# Clean up after ourselves.\nrm \"/etc/pam_pkcs11/pam_pkcs11.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"verify_use_mappers","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-612040\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - verify_use_mappers\n\n- name: Verify that 'use_mappers' is set to 'pwent' in PAM\n  ansible.builtin.lineinfile:\n    path: /etc/pam_pkcs11/pam_pkcs11.conf\n    create: true\n    regexp: ''\n    line: use_mappers = pwent\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-612040\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - verify_use_mappers\n"}],"vuln_id":"SV-260579","stig_id":"UBTU-22-612040"},"xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration":{"rule_id":"xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration","title":"Set Account Expiration Following Inactivity","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.5.1.4"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","18","3","5","7","8"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.6.2.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS01.03","DSS03.05","DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.5.6"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.3","A.18.1.4","A.6.1.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(3)","CM-6(a)","IA-4(e)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","PR.AC-1","PR.AC-4","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000118-GPOS-00060"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.4"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.2","8.2.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260547r1015009_rule"]}],"description":"To specify the number of days after a password expires (which\nsignifies inactivity) until an account is permanently disabled, add or correct\nthe following line in <code>/etc/default/useradd</code>:\n<pre>INACTIVE=<i>35</i>\n         </pre>\nIf a password is currently on the verge of expiration, then\n<code>35</code>\nday(s) remain(s) until the account is automatically\ndisabled. However, if the password will not expire for another 60 days, then 60\ndays plus <code>35</code> day(s) could\nelapse until the account would be automatically disabled. See the\n<code>useradd</code> man page for more information.","rationale":"Inactive identifiers pose a risk to systems and applications because attackers may exploit an inactive identifier and potentially obtain undetected access to the system.\nDisabling inactive accounts ensures that accounts which may not have been responsibly removed are not available to attackers who may have compromised their credentials.\nOwners of inactive accounts will not notice if unauthorized access to their user account has been obtained.","platforms":["#package_shadow-utils"],"oval_definition_id":"oval:ssg-account_disable_post_pw_expiration:def:1","remediations":[{"remediation_id":"account_disable_post_pw_expiration","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'login' 2>/dev/null | grep -q '^installed$'; then\n\nvar_account_disable_post_pw_expiration='35'\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^INACTIVE\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s=%s\" \"$stripped_key\" \"$var_account_disable_post_pw_expiration\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^INACTIVE\\\\>\" \"/etc/default/useradd\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^INACTIVE\\\\>.*/$escaped_formatted_output/gi\" \"/etc/default/useradd\"\nelse\n    if [[ -s \"/etc/default/useradd\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/default/useradd\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/default/useradd\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/default/useradd\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260547","stig_id":"UBTU-22-411035"},"xccdf_org.ssgproject.content_rule_account_temp_expire_date":{"rule_id":"xccdf_org.ssgproject.content_rule_account_temp_expire_date","title":"Assign Expiration Date to Temporary Accounts","result":"notchecked","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","18","3","5","7","8"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS01.03","DSS03.05","DSS05.04","DSS05.05","DSS05.07","DSS06.03"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.3","A.6.1.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(2)","AC-2(3)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","PR.AC-1","PR.AC-4","PR.AC-6"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000002-GPOS-00002","SRG-OS-000123-GPOS-00064"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260548r958364_rule"]}],"description":"Temporary accounts are established as part of normal account activation\nprocedures when there is a need for short-term accounts. In the event\ntemporary accounts are required, configure the system to\nterminate them after a documented time period. For every temporary account, run the following command to set an expiration date on\nit, substituting <code><i>USER</i></code> and <code><i>YYYY-MM-DD</i></code>\nappropriately:\n<pre>$ sudo chage -E <i>YYYY-MM-DD USER</i>\n         </pre>\n         <code><i>YYYY-MM-DD</i></code> indicates the documented expiration date for the\naccount. For U.S. Government systems, the operating system must be\nconfigured to automatically terminate these types of accounts after a\nperiod of 72 hours.","rationale":"If temporary user accounts remain active when no longer needed or for\nan excessive period, these accounts may be used to gain unauthorized access.\nTo mitigate this risk, automated termination of all temporary accounts\nmust be set upon account creation.\n<br>\n        ","messages":["No candidate or applicable check found."],"vuln_id":"SV-260548","stig_id":"UBTU-22-411040"},"xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs","title":"Set Password Maximum Age","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.5.1.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.6.2.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.5.6"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0418","1055","1402"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(d)","IA-5(f)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000076-GPOS-00044"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.4"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.9"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260546r1038967_rule"]}],"description":"To specify password maximum age for new accounts,\nedit the file <code>/etc/login.defs</code>\nand add or correct the following line:\n<pre>PASS_MAX_DAYS 60\n         </pre>\nThe profile requirement is <code>60</code>.","rationale":"Any password, no matter how complex, can eventually be cracked. Therefore, passwords\nneed to be changed periodically. If the operating system does not limit the lifetime\nof passwords and force users to change their passwords, there is the risk that the\noperating system passwords could be compromised.\n<br>\n         <br>\nSetting the password maximum age ensures users are required to\nperiodically change their passwords. Requiring shorter password lifetimes\nincreases the risk of users writing down the password in a convenient\nlocation subject to physical compromise.","platforms":["#package_shadow-utils"],"oval_definition_id":"oval:ssg-accounts_maximum_age_login_defs:def:1","remediations":[{"remediation_id":"accounts_maximum_age_login_defs","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'login' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_maximum_age_login_defs='60'\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^PASS_MAX_DAYS\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_maximum_age_login_defs\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^PASS_MAX_DAYS\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^PASS_MAX_DAYS\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260546","stig_id":"UBTU-22-411030"},"xccdf_org.ssgproject.content_rule_accounts_minimum_age_login_defs":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_minimum_age_login_defs","title":"Set Password Minimum Age","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.5.1.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.6.2.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.5.8"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0418","1055","1402"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(d)","IA-5(f)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000075-GPOS-00043"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260545r1015007_rule"]}],"description":"To specify password minimum age for new accounts,\nedit the file <code>/etc/login.defs</code>\nand add or correct the following line:\n<pre>PASS_MIN_DAYS 1\n         </pre>\nA value of 1 day is considered sufficient for many\nenvironments.\nThe profile requirement is <code>1</code>.","rationale":"Enforcing a minimum password lifetime helps to prevent repeated password\nchanges to defeat the password reuse or history enforcement requirement. If\nusers are allowed to immediately and continually change their password,\nthen the password could be repeatedly changed in a short period of time to\ndefeat the organization&#x27;s policy regarding password reuse.\n<br>\n         <br>\nSetting the minimum password age protects against users cycling back to a\nfavorite password after satisfying the password reuse requirement.","platforms":["#package_shadow-utils"],"oval_definition_id":"oval:ssg-accounts_minimum_age_login_defs:def:1","remediations":[{"remediation_id":"accounts_minimum_age_login_defs","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'login' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_minimum_age_login_defs='1'\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^PASS_MIN_DAYS\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_minimum_age_login_defs\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^PASS_MIN_DAYS\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^PASS_MIN_DAYS\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260545","stig_id":"UBTU-22-411025"},"xccdf_org.ssgproject.content_rule_ensure_sudo_group_restricted":{"rule_id":"xccdf_org.ssgproject.content_rule_ensure_sudo_group_restricted","title":"Ensure sudo group has only necessary members","result":"notchecked","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000134-GPOS-00068"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-432015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260559r958518_rule"]}],"description":"Developers and implementers can increase the assurance in security\nfunctions by employing well-defined security policy models; structured,\ndisciplined, and rigorous hardware and software development techniques;\nand sound system/security engineering principles. Implementation may\ninclude isolation of memory space and libraries.\n\nThe Ubuntu operating system restricts access to security functions\nthrough the use of access control mechanisms and by implementing least\nprivilege capabilities.","rationale":"Any users assigned to the sudo group would be granted administrator\naccess to the system.","warnings":[{"text":"Due to the risk of removing user rights, automated remediation is\nnot available for this configuration check.","category":"general"}],"messages":["No candidate or applicable check found."],"vuln_id":"SV-260559","stig_id":"UBTU-22-432015"},"xccdf_org.ssgproject.content_rule_no_duplicate_uids":{"rule_id":"xccdf_org.ssgproject.content_rule_no_duplicate_uids","title":"Ensure no duplicate UIDs exist","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000104-GPOS-00051","SRG-OS-000121-GPOS-00062"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260543r958482_rule"]}],"description":"Although the useradd program will not let you create a duplicate User ID (UID),\nit is possible for an administrator to manually edit the /etc/passwd file\nand change the UID field. Users must be assigned unique UIDs for\naccountability and to ensure appropriate access protections.","rationale":"Users must be assigned unique UIDs for accountability and to ensure\nappropriate access protections.","warnings":[{"text":"Due to the risk of removing user accounts or changing user&#x27;s UIDS,\nautomated remediation is not available for this configuration check.","category":"general"}],"oval_definition_id":"oval:ssg-no_duplicate_uids:def:1","vuln_id":"SV-260543","stig_id":"UBTU-22-411015"},"xccdf_org.ssgproject.content_rule_no_empty_passwords":{"rule_id":"xccdf_org.ssgproject.content_rule_no_empty_passwords","title":"Prevent Login to Accounts With Empty Password","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","18","3","5"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.2"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.02","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.1","3.1.5"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(B)","164.308(a)(7)(i)","164.308(a)(7)(ii)(A)","164.310(a)(1)","164.310(a)(2)(i)","164.310(a)(2)(ii)","164.310(a)(2)(iii)","164.310(b)","164.310(c)","164.310(d)(1)","164.310(d)(2)(iii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.18.1.4","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(1)(a)","IA-5(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-4","PR.AC-6","PR.AC-7","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00227"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FIA_UAU.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.2.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.3","8.3.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611060"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260570r991589_rule"]}],"description":"If an account is configured for password authentication\nbut does not have an assigned password, it may be possible to log\ninto the account without authentication. Remove any instances of the\n<code>nullok</code> in\n\n<code>/etc/pam.d/common-password</code>\n\nto prevent logins with empty passwords.","rationale":"If an account has an empty password, anyone could log in and\nrun commands with the privileges of that account. Accounts with\nempty passwords should never be used in operational environments.","warnings":[{"text":"If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nNote that this rule is not applicable for systems running within a\ncontainer. Having user with empty password within a container is not\nconsidered a risk, because it should not be possible to directly login into\na container anyway.","category":"general"}],"platforms":["#package_pam"],"oval_definition_id":"oval:ssg-no_empty_passwords:def:1","remediations":[{"remediation_id":"no_empty_passwords","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"medium","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nconf_name=cac_unix\nconf_path=\"/usr/share/pam-configs\"\n\nif [ ! -f \"$conf_path\"/\"$conf_name\" ]; then\n    if [ -f \"$conf_path\"/unix ]; then\n        if grep -q \"$(md5sum \"$conf_path\"/unix | cut -d ' ' -f 1)\" /var/lib/dpkg/info/libpam-runtime.md5sums;then\n            cp \"$conf_path\"/unix \"$conf_path\"/\"$conf_name\"\n            sed -i 's/Priority: [0-9]\\+/Priority: 257\\\nConflicts: unix/' \"$conf_path\"/\"$conf_name\"\n            DEBIAN_FRONTEND=noninteractive pam-auth-update\n        else\n            echo \"Not applicable - checksum of $conf_path/unix does not match the original.\" >&2\n        fi\n    else\n        echo \"Not applicable - $conf_path/unix does not exist\" >&2\n    fi\nfi\nconfig_file=\"/usr/share/pam-configs/cac_unix\"\nsed -i -E '/^Password:/,/^[^[:space:]]/ {\n    /pam_unix\\.so/ {\n        s/\\s*nullok//g\n    }\n}' \"$config_file\"\n\nsed -i -E '/^Password-Initial:/,/^[^[:space:]]/ {\n    /pam_unix\\.so/ {\n        s/\\s*nullok//g\n    }\n}' \"$config_file\"\n\nDEBIAN_FRONTEND=noninteractive pam-auth-update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"no_empty_passwords","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.2\n  - DISA-STIG-UBTU-22-611060\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.1\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n\n- name: Prevent Login to Accounts With Empty Password - Check if system relies on\n    authselect\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.2\n  - DISA-STIG-UBTU-22-611060\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.1\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n\n- name: Prevent Login to Accounts With Empty Password - Remediate using authselect\n  block:\n\n  - name: Prevent Login to Accounts With Empty Password - Check integrity of authselect\n      current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    check_mode: false\n    failed_when: false\n\n  - name: Prevent Login to Accounts With Empty Password - Informative message based\n      on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - ansible_check_mode or result_authselect_check_cmd.rc == 0\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Prevent Login to Accounts With Empty Password - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    check_mode: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Prevent Login to Accounts With Empty Password - Ensure \"without-nullok\"\n      feature is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature without-nullok\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"without-nullok\")\n\n  - name: Prevent Login to Accounts With Empty Password - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.2\n  - DISA-STIG-UBTU-22-611060\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.1\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n\n- name: Prevent Login to Accounts With Empty Password - Remediate directly editing\n    PAM files\n  ansible.builtin.replace:\n    dest: '{{ item }}'\n    regexp: nullok\n  loop:\n  - /etc/pam.d/common-password\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.2\n  - DISA-STIG-UBTU-22-611060\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3\n  - PCI-DSSv4-8.3.1\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n"}],"vuln_id":"SV-260570","stig_id":"UBTU-22-611060"},"xccdf_org.ssgproject.content_rule_no_empty_passwords_etc_shadow":{"rule_id":"xccdf_org.ssgproject.content_rule_no_empty_passwords_etc_shadow","title":"Ensure There Are No Accounts With Blank or Null Passwords","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(b)","CM-6.1(iv)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00227"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-611065"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260571r991589_rule"]}],"description":"Check the &quot;/etc/shadow&quot; file for blank passwords with the\nfollowing command:\n<pre>$ sudo awk -F: &#x27;!$2 {print $1}&#x27; /etc/shadow</pre>\nIf the command returns any results, this is a finding.\nConfigure all accounts on the system to have a password or lock\nthe account with the following commands:\nPerform a password reset:\n<pre>$ sudo passwd [username]</pre>\nLock an account:\n<pre>$ sudo passwd -l [username]</pre>\n        ","rationale":"If an account has an empty password, anyone could log in and\nrun commands with the privileges of that account. Accounts with\nempty passwords should never be used in operational environments.","warnings":[{"text":"Note that this rule is not applicable for systems running within a container. Having user with empty password within a container is not considered a risk, because it should not be possible to directly login into a container anyway.","category":"general"}],"platforms":["#system_with_kernel"],"oval_definition_id":"oval:ssg-no_empty_passwords_etc_shadow:def:1","remediations":[{"remediation_id":"no_empty_passwords_etc_shadow","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nreadarray -t users_with_empty_pass < <(sudo awk -F: '!$2 {print $1}' /etc/shadow)\n\nfor user_with_empty_pass in \"${users_with_empty_pass[@]}\"\ndo\n    passwd -l $user_with_empty_pass\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"no_empty_passwords_etc_shadow","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-611065\n  - NIST-800-53-CM-6(b)\n  - NIST-800-53-CM-6.1(iv)\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.2\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_empty_passwords_etc_shadow\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Collect users with no password\n  ansible.builtin.command: |\n    awk -F: '!$2 {print $1}' /etc/shadow\n  register: users_nopasswd\n  changed_when: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-611065\n  - NIST-800-53-CM-6(b)\n  - NIST-800-53-CM-6.1(iv)\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.2\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_empty_passwords_etc_shadow\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock users with no password\n  ansible.builtin.command: |\n    passwd -l {{ item }}\n  with_items: '{{ users_nopasswd.stdout_lines }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - users_nopasswd is not skipped and users_nopasswd.stdout_lines | length > 0\n  tags:\n  - DISA-STIG-UBTU-22-611065\n  - NIST-800-53-CM-6(b)\n  - NIST-800-53-CM-6.1(iv)\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.2\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_empty_passwords_etc_shadow\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260571","stig_id":"UBTU-22-611065"},"xccdf_org.ssgproject.content_rule_prevent_direct_root_logins":{"rule_id":"xccdf_org.ssgproject.content_rule_prevent_direct_root_logins","title":"Direct root Logins Are Not Allowed","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000109-GPOS-00056"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-411010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260542r1015006_rule"]}],"description":"Configure the operating system to prevent direct logins to the\n<code>root</code> account by performing the following operations:\n<pre>$ sudo passwd -l root</pre>\n        ","rationale":"Disabling direct root logins ensures proper accountability and\nmultifactor authentication to privileged accounts.","oval_definition_id":"oval:ssg-prevent_direct_root_logins:def:1","vuln_id":"SV-260542","stig_id":"UBTU-22-411010"},"xccdf_org.ssgproject.content_rule_accounts_max_concurrent_login_sessions":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_max_concurrent_login_sessions","title":"Limit the Number of Concurrent Login Sessions Allowed Per User","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"low","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["14","15","18","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.2.2"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS01.05","DSS05.02"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.1","SR 3.8"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.13.1.1","A.13.1.3","A.13.2.1","A.14.1.2","A.14.1.3"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-007-3 R5.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-10","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000027-GPOS-00008"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-412020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260552r958398_rule"]}],"description":"Limiting the number of allowed users and sessions per user can limit risks related to Denial of\nService attacks. This addresses concurrent sessions for a single account and does not address\nconcurrent sessions by a single user via multiple accounts. To set the number of concurrent\nsessions per user add the following line in <code>/etc/security/limits.conf</code> or\na file under <code>/etc/security/limits.d/</code>:\n<pre>* hard maxlogins 10\n        </pre>\n       ","rationale":"Limiting simultaneous user logins can insulate the system from denial of service\nproblems caused by excessive logins. Automated login processes operating improperly or\nmaliciously may result in an exceptional number of simultaneous login sessions.","platforms":["#package_pam"],"oval_definition_id":"oval:ssg-accounts_max_concurrent_login_sessions:def:1","remediations":[{"remediation_id":"accounts_max_concurrent_login_sessions","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'libpam-runtime' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_max_concurrent_login_sessions='10'\n\n\nif grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.d/*.conf; then\n\tsed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.d/*.conf\nelif grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.conf; then\n\tsed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.conf\nelse\n\techo \"*\thard\tmaxlogins\t$var_accounts_max_concurrent_login_sessions\" >> /etc/security/limits.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260552","stig_id":"UBTU-22-412020"},"xccdf_org.ssgproject.content_rule_accounts_tmout":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_tmout","title":"Set Interactive Session Timeout","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R32"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.5.5"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.11"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.3","CIP-007-3 R5.1","CIP-007-3 R5.2","CIP-007-3 R5.3.1","CIP-007-3 R5.3.2","CIP-007-3 R5.3.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-12","AC-2(5)","CM-6(a)","SC-10"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000029-GPOS-00010","SRG-OS-000163-GPOS-00072"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.6","8.6.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-412030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260554r958636_rule"]}],"description":"Setting the <code>TMOUT</code> option in <code>/etc/profile</code> ensures that\nall user sessions will terminate based on inactivity. A value of <code>0</code> (zero)\ndisables the automatic logout feature and is therefore not a compliant setting.\nThe value of TMOUT should be a positive integer, exported, and read only.\nThe <code>TMOUT</code>\n\nsetting in a file loaded by <code>/etc/profile</code>, e.g.\n<code>/etc/profile.d/tmout.sh</code> should read as follows:\n<pre>TMOUT=900\n        </pre>\nreadonly TMOUT\nexport TMOUT","rationale":"Terminating an idle session within a short time period reduces\nthe window of opportunity for unauthorized personnel to take control of a\nmanagement session enabled on the console or console port that has been\nleft unattended.","platforms":["#system_with_kernel"],"oval_definition_id":"oval:ssg-accounts_tmout:def:1","remediations":[{"remediation_id":"accounts_tmout","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_tmout='900'\n\n\n# if 0, no occurence of tmout found, if 1, occurence found\ntmout_found=0\n\nfor f in /etc/bash.bashrc /etc/profile /etc/profile.d/*.sh; do\n    if grep --silent '^\\s*TMOUT' $f; then\n        sed -i -E \"s/^(\\s*)TMOUT\\s*=\\s*(\\w|\\$)*(.*)$/\\1TMOUT=$var_accounts_tmout\\3/g\" $f\n        tmout_found=1\n        if ! grep --silent '^\\s*readonly TMOUT' $f ; then\n            echo \"readonly TMOUT\" >> $f\n        fi\n        if ! grep --silent '^\\s*export TMOUT' $f ; then\n            echo \"export TMOUT\" >> $f\n        fi\n    fi\ndone\n\nOLD_UMASK=$(umask)\numask u=rw,go=r\nif [ $tmout_found -eq 0 ]; then\n        echo -e \"\\n# Set TMOUT to $var_accounts_tmout per security requirements\" >> /etc/profile.d/tmout.sh\n        echo \"TMOUT=$var_accounts_tmout\" >> /etc/profile.d/tmout.sh\n        echo \"readonly TMOUT\" >> /etc/profile.d/tmout.sh\n        echo \"export TMOUT\" >> /etc/profile.d/tmout.sh\nfi\numask $OLD_UMASK\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_tmout","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-412030\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSSv4-8.6\n  - PCI-DSSv4-8.6.1\n  - accounts_tmout\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_tmout # promote to variable\n  set_fact:\n    var_accounts_tmout: !!str 900\n  tags:\n    - always\n\n- name: Correct any occurrence of TMOUT in /etc/profile\n  ansible.builtin.replace:\n    path: /etc/profile\n    regexp: ^[^#].*TMOUT=.*\n    replace: typeset -xr TMOUT={{ var_accounts_tmout }}\n  register: profile_replaced\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-412030\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSSv4-8.6\n  - PCI-DSSv4-8.6.1\n  - accounts_tmout\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interactive Session Timeout\n  ansible.builtin.lineinfile:\n    path: /etc/profile.d/tmout.sh\n    create: true\n    regexp: TMOUT=\n    line: typeset -xr TMOUT={{ var_accounts_tmout }}\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-412030\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSSv4-8.6\n  - PCI-DSSv4-8.6.1\n  - accounts_tmout\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260554","stig_id":"UBTU-22-412030"},"xccdf_org.ssgproject.content_rule_accounts_umask_etc_login_defs":{"rule_id":"xccdf_org.ssgproject.content_rule_accounts_umask_etc_login_defs","title":"Ensure the Default Umask is Set Correctly in login.defs","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R36"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.5.4"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","18","3","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","BAI03.01","BAI03.02","BAI03.03","BAI10.01","BAI10.02","BAI10.03","BAI10.05"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.2","A.12.5.1","A.12.6.2","A.14.1.1","A.14.2.1","A.14.2.2","A.14.2.3","A.14.2.4","A.14.2.5","A.6.1.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.IP-1","PR.IP-2"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00228"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-412035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260555r991590_rule"]}],"description":"To ensure the default umask controlled by <code>/etc/login.defs</code> is set properly,\nadd or correct the <code>UMASK</code> setting in <code>/etc/login.defs</code> to read as follows:\n<pre>UMASK 077\n         </pre>\n        ","rationale":"The umask value influences the permissions assigned to files when they are created.\nA misconfigured umask value could result in files with excessive permissions that can be read and\nwritten to by unauthorized users.","platforms":["#package_shadow-utils"],"oval_definition_id":"oval:ssg-accounts_umask_etc_login_defs:def:1","remediations":[{"remediation_id":"accounts_umask_etc_login_defs","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'login' 2>/dev/null | grep -q '^installed$'; then\n\nvar_accounts_user_umask='077'\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^UMASK\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_user_umask\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^UMASK\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^UMASK\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"accounts_umask_etc_login_defs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-412035\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_user_umask # promote to variable\n  set_fact:\n    var_accounts_user_umask: !!str 077\n  tags:\n    - always\n\n- name: Check if UMASK is already set\n  ansible.builtin.lineinfile:\n    path: /etc/login.defs\n    regexp: ^(\\s*)UMASK\\s+.*\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: result_umask_is_set\n  when: '\"login\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-412035\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Replace user UMASK in /etc/login.defs\n  ansible.builtin.replace:\n    path: /etc/login.defs\n    regexp: ^(\\s*)UMASK(\\s+).*\n    replace: \\g<1>UMASK\\g<2>{{ var_accounts_user_umask }}\n  when:\n  - '\"login\" in ansible_facts.packages'\n  - result_umask_is_set.found > 0\n  tags:\n  - DISA-STIG-UBTU-22-412035\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure the Default UMASK is Appended Correctly\n  ansible.builtin.lineinfile:\n    create: true\n    path: /etc/login.defs\n    line: UMASK {{ var_accounts_user_umask }}\n  when:\n  - '\"login\" in ansible_facts.packages'\n  - result_umask_is_set.found == 0\n  tags:\n  - DISA-STIG-UBTU-22-412035\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260555","stig_id":"UBTU-22-412035"},"xccdf_org.ssgproject.content_rule_package_apparmor_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_apparmor_installed","title":"Ensure AppArmor is installed","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R45"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.6.1.1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000312-GPOS-00122","SRG-OS-000312-GPOS-00123","SRG-OS-000312-GPOS-00124","SRG-OS-000324-GPOS-00125","SRG-OS-000368-GPOS-00154","SRG-OS-000370-GPOS-00155"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-431010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260556r958702_rule"]}],"description":"AppArmor provide Mandatory Access Controls.","rationale":"Without a Mandatory Access Control system installed only the default\nDiscretionary Access Control system will be available.","oval_definition_id":"oval:ssg-package_apparmor_installed:def:1","remediations":[{"remediation_id":"package_apparmor_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"apparmor\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_apparmor_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_apparmor\n\nclass install_apparmor {\n  package { 'apparmor':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_apparmor_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"apparmor\"\nversion = \"*\"\n"},{"remediation_id":"package_apparmor_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Ensure apparmor is installed\n  ansible.builtin.package:\n    name: apparmor\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-22-431010\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_apparmor_installed\n"}],"vuln_id":"SV-260556","stig_id":"UBTU-22-431010"},"xccdf_org.ssgproject.content_rule_apparmor_configured":{"rule_id":"xccdf_org.ssgproject.content_rule_apparmor_configured","title":"Ensure AppArmor is Active and Configured","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R45"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-3(4)","AC-6(10)","AC-6(8)","CM-6(a)","CM-7(2)","CM-7(5)(b)","SC-7(21)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000312-GPOS-00122","SRG-OS-000312-GPOS-00123","SRG-OS-000312-GPOS-00124","SRG-OS-000324-GPOS-00125","SRG-OS-000326-GPOS-00126","SRG-OS-000370-GPOS-00155","SRG-OS-000480-GPOS-00227","SRG-OS-000480-GPOS-00230","SRG-OS-000480-GPOS-00231","SRG-OS-000480-GPOS-00232"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-431015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260557r958804_rule"]}],"description":"Verify that the Apparmor tool is configured to\ncontrol whitelisted applications and user home directory access\ncontrol.<br>\n       <br>\n\nThe <code>apparmor</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable apparmor.service</pre>\n      ","rationale":"Using a whitelist provides a configuration management method for allowing\nthe execution of only authorized software. Using only authorized software\ndecreases risk by limiting the number of potential vulnerabilities.<br>\n       <br>\n\nThe organization must identify authorized software programs and permit\nexecution of authorized software by adding each authorized program to the\n&quot;pam_apparmor&quot; exception policy. The process used to identify software\nprograms that are authorized to execute on organizational information\nsystems is commonly referred to as whitelisting.<br>\n       <br>\n\nVerification of whitelisted software occurs prior to execution or at system\nstartup.<br>\n       <br>\n\nUsers&#x27; home directories/folders may contain information of a sensitive\nnature. Nonprivileged users should coordinate any sharing of information\nwith a System Administrator (SA) through shared resources.<br>\n       <br>\n\nApparmor can confine users to their home directory, not allowing them to\nmake any changes outside of their own home directories. Confining users to\ntheir home directory will minimize the risk of sharing information.","oval_definition_id":"oval:ssg-apparmor_configured:def:1","remediations":[{"remediation_id":"apparmor_configured","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\n# Enable apparmor\n/usr/bin/systemctl enable \"apparmor\"\nif [[ $(/usr/bin/systemctl is-system-running) != \"offline\" ]]; then\n/usr/bin/systemctl start \"apparmor\"\nfi\n# The service may not be running because it has been started and failed,\n# so let's reset the state so OVAL checks pass.\n# Service should be 'inactive', not 'failed' after reboot though.\nif /usr/bin/systemctl --failed | grep -q \"apparmor\"; then\n    /usr/bin/systemctl reset-failed \"apparmor\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"apparmor_configured","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include enable_apparmor\n\nclass enable_apparmor {\n  service {'apparmor':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"},{"remediation_id":"apparmor_configured","system":"urn:redhat:osbuild:blueprint","fix":"\n[customizations.services]\nenabled = [\"apparmor\"]\n"}],"vuln_id":"SV-260557","stig_id":"UBTU-22-431015"},"xccdf_org.ssgproject.content_rule_grub2_password":{"rule_id":"xccdf_org.ssgproject.content_rule_grub2_password","title":"Set Boot Loader Password in grub2","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R5"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.02","DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.06","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.4.5"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(B)","164.308(a)(7)(i)","164.308(a)(7)(ii)(A)","164.310(a)(1)","164.310(a)(2)(i)","164.310(a)(2)(ii)","164.310(a)(2)(iii)","164.310(b)","164.310(c)","164.310(d)(1)","164.310(d)(2)(iii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.5.3","4.3.3.5.4","4.3.3.5.5","4.3.3.5.6","4.3.3.5.7","4.3.3.5.8","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.1","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.11","SR 1.12","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.6","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.2","SR 2.3","SR 2.4","SR 2.5","SR 2.6","SR 2.7"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.6.1.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-4","PR.AC-6","PR.AC-7","PR.PT-3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000080-GPOS-00048"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FIA_UAU.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-212010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260470r958472_rule"]}],"description":"The grub2 boot loader should have a superuser account and password\nprotection enabled to protect boot-time settings.\n<br>\n        <br>\nSince plaintext passwords are a security risk, generate a hash for the password\nby running the following command:\n\n<pre># grub2-mkpasswd-pbkdf2</pre>\n\nWhen prompted, enter the password that was selected.\n<br>\n        <br>\n\nUsing the hash from the output, modify the <code>/etc/grub.d/40_custom</code>\nfile with the following content:\n<pre>set superusers=&quot;boot&quot;\npassword_pbkdf2 boot grub.pbkdf2.sha512.VeryLongString\n</pre>\nNOTE: the bootloader superuser account and password MUST differ from the\nroot account and password.\nOnce the superuser password has been added,\nupdate the\n<code>grub.cfg</code> file by running:\n<pre>update-grub </pre>\n       ","rationale":"Password protection on the boot loader configuration ensures\nusers with physical access cannot trivially alter\nimportant bootloader settings. These include which kernel to use,\nand whether to enter single-user mode.","warnings":[{"text":"To prevent hard-coded passwords, automatic remediation of this control is not available. Remediation\nmust be automated as a component of machine provisioning, or followed manually as outlined above.\n\nAlso, do NOT manually add the superuser account and password to the\n<code>grub.cfg</code> file as the grub2-mkconfig command overwrites this file.","category":"general"}],"platforms":["#not_container"],"oval_definition_id":"oval:ssg-grub2_password:def:1","vuln_id":"SV-260470","stig_id":"UBTU-22-212010"},"xccdf_org.ssgproject.content_rule_grub2_uefi_password":{"rule_id":"xccdf_org.ssgproject.content_rule_grub2_uefi_password","title":"Set the UEFI Boot Loader Password","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R5"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.4.1"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","12","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.02","DSS05.04","DSS05.05","DSS05.07","DSS06.03","DSS06.06"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.4.5"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(B)","164.308(a)(7)(i)","164.308(a)(7)(ii)(A)","164.310(a)(1)","164.310(a)(2)(i)","164.310(a)(2)(ii)","164.310(a)(2)(iii)","164.310(b)","164.310(c)","164.310(d)(1)","164.310(d)(2)(iii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.5.3","4.3.3.5.4","4.3.3.5.5","4.3.3.5.6","4.3.3.5.7","4.3.3.5.8","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.1","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.11","SR 1.12","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.6","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.2","SR 2.3","SR 2.4","SR 2.5","SR 2.6","SR 2.7"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.6.1.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.AC-6","PR.PT-3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000080-GPOS-00048"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FIA_UAU.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-212010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260470r958472_rule"]}],"description":"The grub2 boot loader should have a superuser account and password\nprotection enabled to protect boot-time settings.\n<br>\n        <br>\nSince plaintext passwords are a security risk, generate a hash for the password\nby running the following command:\n\n<pre># grub2-mkpasswd-pbkdf2</pre>\n\nWhen prompted, enter the password that was selected.\n<br>\n        <br>\n\nUsing the hash from the output, modify the <code>/etc/grub.d/40_custom</code>\nfile with the following content:\n<pre>set superusers=&quot;boot&quot;\npassword_pbkdf2 boot grub.pbkdf2.sha512.VeryLongString\n</pre>\nNOTE: the bootloader superuser account and password MUST differ from the\nroot account and password.\nOnce the superuser password has been added,\nupdate the\n<code>grub.cfg</code> file by running:\n<pre>update-grub </pre>\n       ","rationale":"Password protection on the boot loader configuration ensures\nusers with physical access cannot trivially alter\nimportant bootloader settings. These include which kernel to use,\nand whether to enter single-user mode.","warnings":[{"text":"To prevent hard-coded passwords, automatic remediation of this control is not available. Remediation\nmust be automated as a component of machine provisioning, or followed manually as outlined above.\n\nAlso, do NOT manually add the superuser account and password to the\n<code>grub.cfg</code> file as the grub2-mkconfig command overwrites this file.","category":"general"}],"oval_definition_id":"oval:ssg-grub2_uefi_password:def:1","vuln_id":"SV-260470","stig_id":"UBTU-22-212010"},"xccdf_org.ssgproject.content_rule_service_rsyslog_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_service_rsyslog_enabled","title":"Enable rsyslog Service","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.2.2.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO13.01","BAI03.05","BAI04.04","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.312(a)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2","SR 7.1","SR 7.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.3","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2","A.17.2.1"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-4(1)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.DS-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00227"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-652010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260588r991562_rule"]}],"description":"The <code>rsyslog</code> service provides syslog-style logging by default on Ubuntu 22.04.\n\nThe <code>rsyslog</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable rsyslog.service</pre>\n      ","rationale":"The <code>rsyslog</code> service must be running in order to provide\nlogging services, which are essential to system administration.","oval_definition_id":"oval:ssg-service_rsyslog_enabled:def:1","remediations":[{"remediation_id":"service_rsyslog_enabled","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'rsyslog.service'\nif [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then\n  \"$SYSTEMCTL_EXEC\" start 'rsyslog.service'\nfi\n\"$SYSTEMCTL_EXEC\" enable 'rsyslog.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"service_rsyslog_enabled","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include enable_rsyslog\n\nclass enable_rsyslog {\n  service {'rsyslog':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"},{"remediation_id":"service_rsyslog_enabled","system":"urn:redhat:osbuild:blueprint","fix":"\n[customizations.services]\nenabled = [\"rsyslog\"]\n"},{"remediation_id":"service_rsyslog_enabled","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-652010\n  - NIST-800-53-AU-4(1)\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_rsyslog_enabled\n\n- name: Enable rsyslog Service - Enable service rsyslog\n  block:\n\n  - name: Gather the package facts\n    ansible.builtin.package_facts:\n      manager: auto\n\n  - name: Enable rsyslog Service - Enable Service rsyslog\n    ansible.builtin.systemd:\n      name: rsyslog\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-652010\n  - NIST-800-53-AU-4(1)\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_rsyslog_enabled\n  - special_service_block\n  when: '\"linux-base\" in ansible_facts.packages'\n"}],"vuln_id":"SV-260588","stig_id":"UBTU-22-652010"},"xccdf_org.ssgproject.content_rule_ensure_rtc_utc_configuration":{"rule_id":"xccdf_org.ssgproject.content_rule_ensure_rtc_utc_configuration","title":"Ensure real-time clock is set to UTC","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000359-GPOS-00146"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-252020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260521r958788_rule"]}],"description":"Ensure that the system real-time clock (RTC) is set to Coordinated Universal Time (UTC).","rationale":"If time stamps are not consistently applied and there is no common\ntime reference, it is difficult to perform forensic analysis.\n\nTime stamps generated by the operating system include date and time.\nTime is commonly expressed in UTC, a modern continuation of GMT, or\nlocal time with an offset from UTC.","oval_definition_id":"oval:ssg-ensure_rtc_utc_configuration:def:1","remediations":[{"remediation_id":"ensure_rtc_utc_configuration","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif timedatectl status | grep -i \"time zone\" | grep -iv 'UTC\\|GMT'; then\n    timedatectl set-timezone UTC\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260521","stig_id":"UBTU-22-252020"},"xccdf_org.ssgproject.content_rule_rsyslog_remote_access_monitoring":{"rule_id":"xccdf_org.ssgproject.content_rule_rsyslog_remote_access_monitoring","title":"Ensure remote access methods are monitored in Rsyslog","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-17(1)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000032-GPOS-00013"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-652015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260589r958406_rule"]}],"description":"Logging of remote access methods must be implemented to help identify cyber\nattacks and ensure ongoing compliance with remote access policies are being\naudited and upheld. An examples of a remote access method is the use of the\nRemote Desktop Protocol (RDP) from an external, non-organization controlled\nnetwork. The <code>/etc/rsyslog.d/50-default.conf</code> file should contain a match for the following\nselectors: <code>auth.*</code>, <code>authpriv.*</code>, and <code>daemon.*</code>. If\nnot, use the following as an example configuration:\n<code>\n    auth.*;authpriv.*                              /var/log/secure\n    daemon.*                                       /var/log/messages\n</code>\n       ","rationale":"Logging remote access methods can be used to trace the decrease the risks\nassociated with remote user access management. It can also be used to spot\ncyber attacks and ensure ongoing compliance with organizational policies\nsurrounding the use of remote access methods.","oval_definition_id":"oval:ssg-rsyslog_remote_access_monitoring:def:1","remediations":[{"remediation_id":"rsyslog_remote_access_monitoring","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'rsyslog' 2>/dev/null | grep -q '^installed$'; then\n\nif [ ! -f /etc/rsyslog.d/50-default.conf ]; then\n    mkdir -p /etc/rsyslog.d/\n    touch /etc/rsyslog.d/50-default.conf\nfi\n\n# Check to see if auth exists\nif ! grep -Erq \"^auth\\.\\*,authpriv\\.\\*\" /etc/rsyslog.*; then\n    echo \"auth.*,authpriv.* /var/log/secure\" >> /etc/rsyslog.d/50-default.conf\nfi\n\nif ! grep -Erq \"^daemon\\.\\*\" /etc/rsyslog.*; then\n    echo \"daemon.* /var/log/messages\" >> /etc/rsyslog.d/50-default.conf\nfi\n\nsystemctl restart rsyslog.service\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"rsyslog_remote_access_monitoring","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-652015\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n\n- name: Ensure remote access methods are monitored in Rsyslog - Set Facts\n  ansible.builtin.set_fact:\n    conf_files:\n    - /etc/rsyslog.d/50-default.conf\n    remote_methods:\n    - selector: auth.*\n      regexp: ^.*auth\\.\\*.*$\n      log_path_name: secure\n    - selector: authpriv.*\n      regexp: ^.*authpriv\\.\\*.*$\n      log_path_name: secure\n    - selector: daemon.*\n      regexp: ^.*daemon\\.\\*.*$\n      log_path_name: messages\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-652015\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n\n- name: Ensure remote access methods are monitored in Rsyslog - Ensure /etc/rsyslog.d/50-default.conf\n    Exists\n  ansible.builtin.file:\n    path: '{{ conf_files.0 }}'\n    state: touch\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-652015\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n\n- name: Ensure remote access methods are monitored in Rsyslog - Check for Existing\n    Values in Conf Files\n  ansible.builtin.lineinfile:\n    path: '{{ item.1 }}'\n    regexp: '{{ item.0.regexp }}'\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: remote_method_values\n  loop: '{{ remote_methods|product(conf_files)|list }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-652015\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n\n- name: Ensure remote access methods are monitored in Rsyslog - Configure /etc/rsyslog.d/50-default.conf\n    With Proper Log Paths\n  ansible.builtin.lineinfile:\n    path: /etc/rsyslog.d/50-default.conf\n    line: '{{ item.item.0.selector }} /var/log/{{ item.item.0.log_path_name }}'\n    insertafter: ^.*\\/var\\/log\\/secure.*$\n    create: true\n  loop: '{{ remote_method_values.results }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"rsyslog\" in ansible_facts.packages'\n  - item.found == 0\n  tags:\n  - DISA-STIG-UBTU-22-652015\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n"}],"vuln_id":"SV-260589","stig_id":"UBTU-22-652015"},"xccdf_org.ssgproject.content_rule_dir_groupowner_system_journal":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_groupowner_system_journal","title":"Verify group-owner of system journal directories","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232085"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260502r958566_rule"]}],"description":"Verify the /run/log/journal and /var/log/journal directories are group-owned by\n&quot;systemd-journal&quot; by using the following command:\n<pre>\n$ sudo find /run/log/journal /var/log/journal  -type d -exec stat -c &quot;%n %G&quot; {} \\;\n</pre>\nIf any output returned is not owned by &quot;systemd-journal&quot;, this is a finding.","rationale":"Only authorized personnel should be aware of errors and the details of the errors.\nError messages are an indicator of an organization&#x27;s operational state or can identify\nthe operating system or platform. Additionally, personally identifiable information\n(PII) and operational information must not be revealed through error messages to\nunauthorized personnel or their designated representatives.","oval_definition_id":"oval:ssg-dir_groupowner_system_journal:def:1","remediations":[{"remediation_id":"dir_groupowner_system_journal","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nTMPFILES_CONF=\"/usr/lib/tmpfiles.d/systemd.conf\"\n\nif ! grep -q 'Z /var/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/var\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/var\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /var/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nif ! grep -q 'Z /run/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/run\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/run\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /run/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nsystemd-tmpfiles --create\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"dir_groupowner_system_journal","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232085\n  - configure_strategy\n  - dir_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Check that the systemd-journal group is defined\n  ansible.builtin.getent:\n    database: group\n    key: systemd-journal\n  ignore_errors: true\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - dir_groupowner_system_journal_newgroup is undefined\n  tags:\n  - DISA-STIG-UBTU-22-232085\n  - configure_strategy\n  - dir_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the dir_groupowner_system_journal_newgroup variable if systemd-journal\n    found\n  ansible.builtin.set_fact:\n    dir_groupowner_system_journal_newgroup: systemd-journal\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_facts.getent_group[\"systemd-journal\"] is defined\n  tags:\n  - DISA-STIG-UBTU-22-232085\n  - configure_strategy\n  - dir_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /run/log/journal/ recursively\n  ansible.builtin.file:\n    path: /run/log/journal/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupowner_system_journal_newgroup }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232085\n  - configure_strategy\n  - dir_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /var/log/journal/ recursively\n  ansible.builtin.file:\n    path: /var/log/journal/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupowner_system_journal_newgroup }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232085\n  - configure_strategy\n  - dir_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260502","stig_id":"UBTU-22-232085"},"xccdf_org.ssgproject.content_rule_dir_owner_system_journal":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_owner_system_journal","title":"Verify owner of system journal directories","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232080"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260501r958566_rule"]}],"description":"Verify the /run/log/journal and /var/log/journal directories are owned by\n&quot;root&quot; by using the following command:\n<pre>\n$ sudo find /run/log/journal /var/log/journal  -type d -exec stat -c &quot;%n %U&quot; {} \\;\n</pre>\nIf any output returned is not owned by &quot;root&quot;, this is a finding.","rationale":"Only authorized personnel should be aware of errors and the details of the errors.\nError messages are an indicator of an organization&#x27;s operational state or can identify\nthe operating system or platform. Additionally, personally identifiable information\n(PII) and operational information must not be revealed through error messages to\nunauthorized personnel or their designated representatives.","oval_definition_id":"oval:ssg-dir_owner_system_journal:def:1","remediations":[{"remediation_id":"dir_owner_system_journal","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nTMPFILES_CONF=\"/usr/lib/tmpfiles.d/systemd.conf\"\n\nif ! grep -q 'Z /var/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/var\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/var\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /var/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nif ! grep -q 'Z /run/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/run\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/run\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /run/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nsystemd-tmpfiles --create\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"dir_owner_system_journal","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232080\n  - configure_strategy\n  - dir_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the dir_owner_system_journal_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    dir_owner_system_journal_newown: '0'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232080\n  - configure_strategy\n  - dir_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /run/log/journal/ recursively\n  ansible.builtin.file:\n    path: /run/log/journal/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_owner_system_journal_newown }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232080\n  - configure_strategy\n  - dir_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /var/log/journal/ recursively\n  ansible.builtin.file:\n    path: /var/log/journal/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_owner_system_journal_newown }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232080\n  - configure_strategy\n  - dir_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260501","stig_id":"UBTU-22-232080"},"xccdf_org.ssgproject.content_rule_dir_permissions_system_journal":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_permissions_system_journal","title":"Verify Permissions on the system journal directories","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232027"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260490r1014781_rule"]}],"description":"Verify the /run/log/journal and /var/log/journal directories have\npermissions set to &quot;2750&quot; or less permissive by using the following command:\n<pre>\n$ sudo find /run/log/journal /var/log/journal  -type d -exec stat -c &quot;%n %a&quot; {} \\;\n</pre>\nIf any output returned has a permission set greater than &quot;2750&quot;, this is a finding.","rationale":"Any operating system providing too much information in error messages risks\ncompromising the data and security of the structure, and content of error messages\nneeds to be carefully considered by the organization.","oval_definition_id":"oval:ssg-dir_permissions_system_journal:def:1","remediations":[{"remediation_id":"dir_permissions_system_journal","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nTMPFILES_CONF=\"/usr/lib/tmpfiles.d/systemd.conf\"\n\nif ! grep -q 'Z /var/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/var\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/var\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /var/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nif ! grep -q 'Z /run/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/run\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/run\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /run/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nsystemd-tmpfiles --create\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"dir_permissions_system_journal","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - dir_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /run/log/journal/ file(s) recursively\n  ansible.builtin.command: 'find -P /run/log/journal/  -perm /u+s,g+w,o+xwrt  -type\n    d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - dir_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /run/log/journal/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-w,o-xwrt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - dir_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /var/log/journal/ file(s) recursively\n  ansible.builtin.command: 'find -P /var/log/journal/  -perm /u+s,g+w,o+xwrt  -type\n    d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - dir_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /var/log/journal/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-w,o-xwrt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - dir_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260490","stig_id":"UBTU-22-232027"},"xccdf_org.ssgproject.content_rule_file_groupowner_journalctl":{"rule_id":"xccdf_org.ssgproject.content_rule_file_groupowner_journalctl","title":"Verify Groupowner on the journalctl command","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232105"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260506r958566_rule"]}],"description":"Verify that the &quot;journalctl&quot; command is group-owned by &quot;root&quot; by\nusing the following command:\n<pre>\n$ sudo find /usr/bin/journalctl -exec stat -c &quot;%n %G&quot; {} \\;\n</pre>\nIf any output returned is not owned by &quot;root&quot;, this is a finding.","rationale":"Only authorized personnel should be aware of errors and the details of the errors.\nError messages are an indicator of an organization&#x27;s operational state or can\nidentify the operating system or platform. Additionally, personally identifiable\ninformation (PII) and operational information must not be revealed through error\nmessages to unauthorized personnel or their designated representatives.","oval_definition_id":"oval:ssg-file_groupowner_journalctl:def:1","remediations":[{"remediation_id":"file_groupowner_journalctl","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nnewgroup=\"\"\nif getent group \"0\" >/dev/null 2>&1; then\n  newgroup=\"0\"\nfi\n\nif [[ -z \"${newgroup}\" ]]; then\n  >&2 echo \"0 is not a defined group on the system\"\nelse\nif ! stat -c \"%g %G\" \"/usr/bin/journalctl\" | grep -E -w -q \"0\"; then\n    chgrp --no-dereference \"$newgroup\" /usr/bin/journalctl\nfi\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_groupowner_journalctl","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232105\n  - configure_strategy\n  - file_groupowner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_groupowner_journalctl_newgroup variable if represented by gid\n  ansible.builtin.set_fact:\n    file_groupowner_journalctl_newgroup: '0'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232105\n  - configure_strategy\n  - file_groupowner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /usr/bin/journalctl\n  ansible.builtin.stat:\n    path: /usr/bin/journalctl\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232105\n  - configure_strategy\n  - file_groupowner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/bin/journalctl\n  ansible.builtin.file:\n    path: /usr/bin/journalctl\n    follow: false\n    group: '{{ file_groupowner_journalctl_newgroup }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232105\n  - configure_strategy\n  - file_groupowner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260506","stig_id":"UBTU-22-232105"},"xccdf_org.ssgproject.content_rule_file_groupowner_system_journal":{"rule_id":"xccdf_org.ssgproject.content_rule_file_groupowner_system_journal","title":"Verify Group Who Owns the system journal","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000118-CTR-000240"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232095"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260504r958566_rule"]}],"description":"Verify the /run/log/journal and /var/log/journal files are group-owned by\n&quot;systemd-journal&quot; by using the following command:\n<pre>\n$ sudo find /run/log/journal /var/log/journal  -type f -exec stat -c &quot;%n %G&quot; {} \\;\n</pre>\nIf any output returned is not group-owned by &quot;systemd-journal&quot;, this is a finding.","rationale":"Only authorized personnel should be aware of errors and the details of the errors.\nError messages are an indicator of an organization&#x27;s operational state or can\nidentify the operating system or platform. Additionally, personally identifiable\ninformation (PII) and operational information must not be revealed through error\nmessages to unauthorized personnel or their designated representatives.","oval_definition_id":"oval:ssg-file_groupowner_system_journal:def:1","remediations":[{"remediation_id":"file_groupowner_system_journal","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nTMPFILES_CONF=\"/usr/lib/tmpfiles.d/systemd.conf\"\n\nif ! grep -q 'Z /var/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/var\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/var\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /var/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nif ! grep -q 'Z /run/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/run\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/run\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /run/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nsystemd-tmpfiles --create\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_groupowner_system_journal","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232095\n  - configure_strategy\n  - file_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Check that the systemd-journal group is defined\n  ansible.builtin.getent:\n    database: group\n    key: systemd-journal\n  ignore_errors: true\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_groupowner_system_journal_newgroup is undefined\n  tags:\n  - DISA-STIG-UBTU-22-232095\n  - configure_strategy\n  - file_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_groupowner_system_journal_newgroup variable if systemd-journal\n    found\n  ansible.builtin.set_fact:\n    file_groupowner_system_journal_newgroup: systemd-journal\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_facts.getent_group[\"systemd-journal\"] is defined\n  tags:\n  - DISA-STIG-UBTU-22-232095\n  - configure_strategy\n  - file_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /run/log/journal/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /run/log/journal/  -type f  ! -group systemd-journal\n    -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232095\n  - configure_strategy\n  - file_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /run/log/journal/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    group: '{{ file_groupowner_system_journal_newgroup }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232095\n  - configure_strategy\n  - file_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /var/log/journal/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /var/log/journal/  -type f  ! -group systemd-journal\n    -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232095\n  - configure_strategy\n  - file_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /var/log/journal/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    group: '{{ file_groupowner_system_journal_newgroup }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232095\n  - configure_strategy\n  - file_groupowner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260504","stig_id":"UBTU-22-232095"},"xccdf_org.ssgproject.content_rule_file_owner_journalctl":{"rule_id":"xccdf_org.ssgproject.content_rule_file_owner_journalctl","title":"Verify Owner on the journalctl Command","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232100"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260505r958566_rule"]}],"description":"Verify that the &quot;journalctl&quot; command is owned by &quot;root&quot; by\nusing the following command:\n<pre>\n$ sudo find /usr/bin/journalctl -exec stat -c &quot;%n %U&quot; {} \\;\n</pre>\nIf any output returned is not owned by &quot;root&quot;, this is a finding.","rationale":"Only authorized personnel should be aware of errors and the details of the errors.\nError messages are an indicator of an organization&#x27;s operational state or can\nidentify the operating system or platform. Additionally, personally identifiable\ninformation (PII) and operational information must not be revealed through error\nmessages to unauthorized personnel or their designated representatives.","oval_definition_id":"oval:ssg-file_owner_journalctl:def:1","remediations":[{"remediation_id":"file_owner_journalctl","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nnewown=\"\"\nif id \"0\" >/dev/null 2>&1; then\n  newown=\"0\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"0 is not a defined user on the system\"\nelse\nif ! stat -c \"%u %U\" \"/usr/bin/journalctl\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /usr/bin/journalctl\nfi\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_owner_journalctl","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232100\n  - configure_strategy\n  - file_owner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_owner_journalctl_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    file_owner_journalctl_newown: '0'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232100\n  - configure_strategy\n  - file_owner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /usr/bin/journalctl\n  ansible.builtin.stat:\n    path: /usr/bin/journalctl\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232100\n  - configure_strategy\n  - file_owner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /usr/bin/journalctl\n  ansible.builtin.file:\n    path: /usr/bin/journalctl\n    follow: false\n    owner: '{{ file_owner_journalctl_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232100\n  - configure_strategy\n  - file_owner_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260505","stig_id":"UBTU-22-232100"},"xccdf_org.ssgproject.content_rule_file_owner_system_journal":{"rule_id":"xccdf_org.ssgproject.content_rule_file_owner_system_journal","title":"Verify Owner on the system journal","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000118-CTR-000240"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232090"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260503r958566_rule"]}],"description":"Verify the /run/log/journal and /var/log/journal files are owned by\n&quot;root&quot; by using the following command:\n<pre>\n$ sudo find /run/log/journal /var/log/journal  -type f -exec stat -c &quot;%n %U&quot; {} \\;\n</pre>\nIf any output returned is not owned by &quot;root&quot;, this is a finding.","rationale":"Only authorized personnel should be aware of errors and the details of the errors.\nError messages are an indicator of an organization&#x27;s operational state or can\nidentify the operating system or platform. Additionally, personally identifiable\ninformation (PII) and operational information must not be revealed through error\nmessages to unauthorized personnel or their designated representatives.","oval_definition_id":"oval:ssg-file_owner_system_journal:def:1","remediations":[{"remediation_id":"file_owner_system_journal","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nTMPFILES_CONF=\"/usr/lib/tmpfiles.d/systemd.conf\"\n\nif ! grep -q 'Z /var/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/var\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/var\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /var/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nif ! grep -q 'Z /run/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/run\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/run\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /run/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nsystemd-tmpfiles --create\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_owner_system_journal","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232090\n  - configure_strategy\n  - file_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_owner_system_journal_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    file_owner_system_journal_newown: '0'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232090\n  - configure_strategy\n  - file_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /run/log/journal/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /run/log/journal/  -type f  ! -user 0 -regextype\n    posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232090\n  - configure_strategy\n  - file_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /run/log/journal/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_owner_system_journal_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232090\n  - configure_strategy\n  - file_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /var/log/journal/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /var/log/journal/  -type f  ! -user 0 -regextype\n    posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232090\n  - configure_strategy\n  - file_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /var/log/journal/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_owner_system_journal_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232090\n  - configure_strategy\n  - file_owner_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260503","stig_id":"UBTU-22-232090"},"xccdf_org.ssgproject.content_rule_file_permissions_journalctl":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_journalctl","title":"Verify Permissions on the journal command","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232140"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260512r958564_rule"]}],"description":"Verify that the &quot;journalctl&quot; command has a permission set of &quot;740&quot; by\nusing the following command:\n<pre>\n $ sudo find /usr/bin/journalctl -exec stat -c &quot;%n %a&quot; {} \\;\n</pre>\nIf &quot;journalctl&quot; is not set to &quot;740&quot;, this is a finding.","rationale":"Any operating system providing too much information in error messages risks\ncompromising the data and security of the structure, and content of error messages\nneeds to be carefully considered by the organization.","oval_definition_id":"oval:ssg-file_permissions_journalctl:def:1","remediations":[{"remediation_id":"file_permissions_journalctl","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nchmod u-s,g-xws,o-xwrt /usr/bin/journalctl\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_permissions_journalctl","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232140\n  - configure_strategy\n  - file_permissions_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /usr/bin/journalctl\n  ansible.builtin.stat:\n    path: /usr/bin/journalctl\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232140\n  - configure_strategy\n  - file_permissions_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-xws,o-xwrt on /usr/bin/journalctl\n  ansible.builtin.file:\n    path: /usr/bin/journalctl\n    mode: u-s,g-xws,o-xwrt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232140\n  - configure_strategy\n  - file_permissions_journalctl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260512","stig_id":"UBTU-22-232140"},"xccdf_org.ssgproject.content_rule_file_permissions_system_journal":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_system_journal","title":"Verify Permissions on the system journal","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000118-CTR-000240"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232027"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260490r1014781_rule"]}],"description":"Verify all files in the /run/log/journal and /var/log/journal directories have\npermissions set to &quot;640&quot; or less permissive by using the following command:\n<pre>\n$ sudo find /run/log/journal /var/log/journal  -type f -exec stat -c &quot;%n %a&quot; {} \\;\n</pre>\nIf any output returned has a permission set greater than &quot;640&quot;, this is a finding.","rationale":"Any operating system providing too much information in error messages risks\ncompromising the data and security of the structure, and content of error messages\nneeds to be carefully considered by the organization.","oval_definition_id":"oval:ssg-file_permissions_system_journal:def:1","remediations":[{"remediation_id":"file_permissions_system_journal","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nTMPFILES_CONF=\"/usr/lib/tmpfiles.d/systemd.conf\"\n\nif ! grep -q 'Z /var/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/var\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/var\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /var/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nif ! grep -q 'Z /run/log/journal ~2750 root systemd-journal - -' \"$TMPFILES_CONF\"; then\n    if grep -qP \"^[zZ][+]*\\s+\\/run\\/log\\/journal\" \"$TMPFILES_CONF\"; then\n        sed -i --follow-symlinks \"s/\\(^[zZ][+]*\\)\\(\\s\\+\\/run\\/log\\/journal.*\\)/# \\1\\2/\" \"$TMPFILES_CONF\"\n    fi\n    echo \"Z /run/log/journal ~2750 root systemd-journal - -\" >>\"$TMPFILES_CONF\"\nfi\n\nsystemd-tmpfiles --create\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_permissions_system_journal","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - file_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /run/log/journal/ file(s) recursively\n  ansible.builtin.command: find -P /run/log/journal/  -perm /u+xs,g+xws,o+xwrt  -type\n    f -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - file_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /run/log/journal/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-xs,g-xws,o-xwrt\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - file_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /var/log/journal/ file(s) recursively\n  ansible.builtin.command: find -P /var/log/journal/  -perm /u+xs,g+xws,o+xwrt  -type\n    f -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - file_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /var/log/journal/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-xs,g-xws,o-xwrt\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232027\n  - configure_strategy\n  - file_permissions_system_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260490","stig_id":"UBTU-22-232027"},"xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_tcp_syncookies":{"rule_id":"xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_tcp_syncookies","title":"Enable Kernel Parameter to Use TCP Syncookies on Network Interfaces","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R12"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["3.3.8"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","18","2","4","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.10.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","APO13.01","BAI04.04","DSS01.03","DSS01.05","DSS03.01","DSS03.05","DSS05.02","DSS05.04","DSS05.07","DSS06.02"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.20"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.4","4.3.3.4","4.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.2","SR 7.1","SR 7.2","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.12.1.1","A.12.1.2","A.12.1.3","A.13.1.1","A.13.1.2","A.13.1.3","A.13.2.1","A.13.2.2","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.17.2.1","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","CM-7(a)","CM-7(b)","SC-5(1)","SC-5(2)","SC-5(3)(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-1","DE.CM-1","ID.AM-3","PR.AC-5","PR.DS-4","PR.DS-5","PR.PT-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000142-GPOS-00071","SRG-OS-000420-GPOS-00186","SRG-OS-000480-GPOS-00227"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-1.4.1"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["1.4","1.4.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-253010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260522r958528_rule"]}],"description":"To set the runtime status of the <code>net.ipv4.tcp_syncookies</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w net.ipv4.tcp_syncookies=1</pre>\nTo make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>net.ipv4.tcp_syncookies = 1</pre>\n        ","rationale":"A TCP SYN flood attack can cause a denial of service by filling a\nsystem&#x27;s TCP connection table with connections in the SYN_RCVD state.\nSyncookies can be used to track a connection when a subsequent ACK is received,\nverifying the initiator is attempting a valid connection and is not a flood\nsource. This feature is activated when a flood condition is detected, and\nenables the system to continue servicing valid connection requests.","oval_definition_id":"oval:ssg-sysctl_net_ipv4_tcp_syncookies:def:1","remediations":[{"remediation_id":"sysctl_net_ipv4_tcp_syncookies","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"medium","strategy":"disable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Comment out any occurrences of net.ipv4.tcp_syncookies from /etc/sysctl.d/*.conf files\n\nfor f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /etc/ufw/sysctl.conf; do\n\n\n  # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf)\n  if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi\n\n  matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.tcp_syncookies.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\")\n      # comment out \"net.ipv4.tcp_syncookies\" matches to preserve user data\n      sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n  fi\ndone\n\n#\n# Set sysctl config file which to save the desired value\n#\n\nSYSCONFIG_FILE=\"/etc/sysctl.conf\"\n\nsysctl_net_ipv4_tcp_syncookies_value='1'\n\n\n#\n# Set runtime for net.ipv4.tcp_syncookies\n#\nif ! /bin/false ; then\n    /sbin/sysctl -q -n -w net.ipv4.tcp_syncookies=\"$sysctl_net_ipv4_tcp_syncookies_value\"\nfi\n\n#\n# If net.ipv4.tcp_syncookies present in /etc/sysctl.conf, change value to appropriate value\n#\telse, add \"net.ipv4.tcp_syncookies = value\" to /etc/sysctl.conf\n#\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^net.ipv4.tcp_syncookies\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_tcp_syncookies_value\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.tcp_syncookies\\\\>\" \"${SYSCONFIG_FILE}\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^net.ipv4.tcp_syncookies\\\\>.*/$escaped_formatted_output/gi\" \"${SYSCONFIG_FILE}\"\nelse\n    if [[ -s \"${SYSCONFIG_FILE}\" ]] && [[ -n \"$(tail -c 1 -- \"${SYSCONFIG_FILE}\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"${SYSCONFIG_FILE}\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"${SYSCONFIG_FILE}\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sysctl_net_ipv4_tcp_syncookies","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-22-253010\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n\n- name: List /etc/sysctl.d/*.conf files\n  ansible.builtin.find:\n    paths:\n    - /etc/sysctl.d/\n    - /run/sysctl.d/\n    - /usr/local/lib/sysctl.d/\n    contains: ^[\\s]*net.ipv4.tcp_syncookies.*$\n    patterns: '*.conf'\n    file_type: any\n  register: find_sysctl_d\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-22-253010\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n\n- name: Comment out any occurrences of net.ipv4.tcp_syncookies from config files\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: ^[\\s]*net.ipv4.tcp_syncookies\n    replace: '#net.ipv4.tcp_syncookies'\n  loop: '{{ find_sysctl_d.files }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-22-253010\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n\n- name: Comment out any occurrences of net.ipv4.tcp_syncookies from /etc/ufw/sysctl.conf\n  ansible.builtin.replace:\n    path: /etc/ufw/sysctl.conf\n    regexp: (^[\\s]*net.ipv4.tcp_syncookies.*$)\n    replace: '# \\1'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-22-253010\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n- name: XCCDF Value sysctl_net_ipv4_tcp_syncookies_value # promote to variable\n  set_fact:\n    sysctl_net_ipv4_tcp_syncookies_value: !!str 1\n  tags:\n    - always\n\n- name: Ensure sysctl net.ipv4.tcp_syncookies is set\n  ansible.posix.sysctl:\n    name: net.ipv4.tcp_syncookies\n    value: '{{ sysctl_net_ipv4_tcp_syncookies_value }}'\n    sysctl_file: /etc/sysctl.conf\n    state: present\n    reload: true\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-22-253010\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n"}],"vuln_id":"SV-260522","stig_id":"UBTU-22-253010"},"xccdf_org.ssgproject.content_rule_package_ufw_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_ufw_installed","title":"Install ufw Package","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000297-GPOS-00115"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-251010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260514r958672_rule"]}],"description":"The <code>ufw</code> package can be installed with the following command:\n<pre>\n$ apt-get install ufw</pre>\n       ","rationale":"<code>ufw</code> controls the Linux kernel network packet filtering\ncode. <code>ufw</code> allows system operators to set up firewalls and IP\nmasquerading, etc.","oval_definition_id":"oval:ssg-package_ufw_installed:def:1","remediations":[{"remediation_id":"package_ufw_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"ufw\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_ufw_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_ufw\n\nclass install_ufw {\n  package { 'ufw':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_ufw_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"ufw\"\nversion = \"*\"\n"},{"remediation_id":"package_ufw_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-251010\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_ufw_installed\n\n- name: Ensure ufw is installed\n  ansible.builtin.package:\n    name: ufw\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-251010\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_ufw_installed\n"}],"vuln_id":"SV-260514","stig_id":"UBTU-22-251010"},"xccdf_org.ssgproject.content_rule_service_ufw_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_service_ufw_enabled","title":"Verify ufw Enabled","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["3.5.1.3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000297-GPOS-00115"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-251020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260516r991593_rule"]}],"description":"\nThe <code>ufw</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable ufw.service</pre>\n       ","rationale":"The ufw service must be enabled and running in order for ufw to protect the system","platforms":["#package_ufw_and_system_with_kernel"],"oval_definition_id":"oval:ssg-service_ufw_enabled:def:1","remediations":[{"remediation_id":"service_ufw_enabled","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ( dpkg-query --show --showformat='${db:Status-Status}' 'ufw' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' ); }; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'ufw.service'\nif [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then\n  \"$SYSTEMCTL_EXEC\" start 'ufw.service'\nfi\n\"$SYSTEMCTL_EXEC\" enable 'ufw.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"service_ufw_enabled","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include enable_ufw\n\nclass enable_ufw {\n  service {'ufw':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"},{"remediation_id":"service_ufw_enabled","system":"urn:redhat:osbuild:blueprint","fix":"\n[customizations.services]\nenabled = [\"ufw\"]\n"},{"remediation_id":"service_ufw_enabled","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-251020\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_ufw_enabled\n\n- name: Verify ufw Enabled - Enable service ufw\n  block:\n\n  - name: Gather the package facts\n    ansible.builtin.package_facts:\n      manager: auto\n\n  - name: Verify ufw Enabled - Enable Service ufw\n    ansible.builtin.systemd:\n      name: ufw\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"ufw\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-251020\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_ufw_enabled\n  - special_service_block\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"ufw\" in ansible_facts.packages and \"linux-base\" in ansible_facts.packages )\n"}],"vuln_id":"SV-260516","stig_id":"UBTU-22-251020"},"xccdf_org.ssgproject.content_rule_check_ufw_active":{"rule_id":"xccdf_org.ssgproject.content_rule_check_ufw_active","title":"Verify ufw Active","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-251015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260515r958672_rule"]}],"description":"Verify the ufw is enabled on the system with the following command:\n<pre># sudo ufw status</pre>\nIf the above command returns the status as &quot;inactive&quot; or any type of error, this is a finding.","rationale":"Remote access services, such as those providing remote access to network devices and information systems, \nwhich lack automated control capabilities, increase risk and make remote user access management difficult at best.  \nRemote access is access to nonpublic information systems by an authorized user (or an information system) communicating \nthrough an external, nonorganization-controlled network. Remote access methods include, for example, dial-up, broadband, and wireless.  \nUbuntu 22.04 LTS functionality (e.g., RDP) must be capable of taking enforcement action if the audit reveals unauthorized activity. \nAutomated control of remote access sessions allows organizations to ensure ongoing compliance with remote access policies by \nenforcing connection rules of remote access applications on a variety of information system components.","platforms":["#package_ufw_and_system_with_kernel"],"vuln_id":"SV-260515","stig_id":"UBTU-22-251015"},"xccdf_org.ssgproject.content_rule_ufw_only_required_services":{"rule_id":"xccdf_org.ssgproject.content_rule_ufw_only_required_services","title":"Only Allow Authorized Network Services in ufw","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000096-GPOS-00050"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-251030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260518r958480_rule"]}],"description":"Check the firewall configuration for any unnecessary or prohibited\nfunctions, ports, protocols, and/or services by running the following\ncommand:\n<pre>$ sudo ufw show raw\nChain OUTPUT (policy ACCEPT)\ntarget prot opt sources destination\nChain INPUT (policy ACCEPT 1 packets, 40 bytes)\npkts bytes target prot opt in out source destination\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target prot opt in out source destination\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target prot opt in out source destination</pre>\n\nAsk the System Administrator for the site or program PPSM CLSA. Verify\nthe services allowed by the firewall match the PPSM CLSA.","rationale":"To prevent unauthorized connection of devices, unauthorized transfer of\ninformation, or unauthorized tunneling (i.e., embedding of data types\nwithin data types), organizations must disable or restrict unused or\nunnecessary physical and logical ports/protocols on information systems.\n\nOperating systems are capable of providing a wide variety of functions\nand services. Some of the functions and services provided by default\nmay not be necessary to support essential organizational operations.\nAdditionally, it is sometimes convenient to provide multiple services\nfrom a single component (e.g., VPN and IPS); however, doing so\nincreases risk over limiting the services provided by any one component.\n\nTo support the requirements and principles of least functionality, the\noperating system must support the organizational requirements, providing\nonly essential capabilities and limiting the use of ports, protocols,\nand/or services to only those required, authorized, and approved to\nconduct official business or to address authorized quality of life\nissues.","vuln_id":"SV-260518","stig_id":"UBTU-22-251030"},"xccdf_org.ssgproject.content_rule_ufw_rate_limit":{"rule_id":"xccdf_org.ssgproject.content_rule_ufw_rate_limit","title":"ufw Must rate-limit network interfaces","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000420-GPOS-00186"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-251025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260517r958902_rule"]}],"description":"The operating system must configure the uncomplicated firewall to\nrate-limit impacted network interfaces.\n\nCheck all the services listening to the ports with the following\ncommand:\n<pre>$ sudo ss -l46ut\nNetid State Recv-Q Send-Q Local Address:Port Peer Address:Port Process\ntcp LISTEN 0 128 [::]:ssh [::]:*</pre>\n\nFor each entry, verify that the ufw is configured to rate limit the\nservice ports with the following command:\n<pre>$ sudo ufw status</pre>\n\nIf any port with a state of &quot;LISTEN&quot; is not marked with the &quot;LIMIT&quot;\naction, run the following command, replacing &quot;service&quot; with the\nservice that needs to be rate limited:\n<pre>$ sudo ufw limit &quot;service&quot;</pre>\n\nRate-limiting can also be done on an interface. An example of adding\na rate-limit on the eth0 interface follows:\n<pre>$ sudo ufw limit in on eth0</pre>\n       ","rationale":"This requirement addresses the configuration of the operating system to\nmitigate the impact of DoS attacks that have occurred or are ongoing on\nsystem availability. For each system, known and potential DoS attacks\nmust be identified and solutions for each type implemented. A variety\nof technologies exist to limit or, in some cases, eliminate the effects\nof DoS attacks (e.g., limiting processes or establishing memory\npartitions). Employing increased capacity and bandwidth, combined with\nservice redundancy, may reduce the susceptibility to some DoS attacks.","vuln_id":"SV-260517","stig_id":"UBTU-22-251025"},"xccdf_org.ssgproject.content_rule_wireless_disable_interfaces":{"rule_id":"xccdf_org.ssgproject.content_rule_wireless_disable_interfaces","title":"Deactivate Wireless Network Interfaces","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["3.1.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","12","14","15","3","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS01.04","DSS05.02","DSS05.03","DSS05.05","DSS06.06"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.16"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.5.1","4.3.3.5.2","4.3.3.5.3","4.3.3.5.4","4.3.3.5.5","4.3.3.5.6","4.3.3.5.7","4.3.3.5.8","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.1","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.11","SR 1.12","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.6","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.2","SR 2.3","SR 2.4","SR 2.5","SR 2.6","SR 2.7","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 7.1","SR 7.6"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["1315","1319"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.1.2","A.12.5.1","A.12.6.2","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.6.2.1","A.6.2.2","A.9.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-18(3)","AC-18(a)","CM-6(a)","CM-7(a)","CM-7(b)","MP-7"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-3","PR.IP-1","PR.PT-3","PR.PT-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000299-GPOS-00117","SRG-OS-000300-GPOS-00118","SRG-OS-000424-GPOS-00188","SRG-OS-000481-GPOS-00481"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-1.3.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["1.3","1.3.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-291015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260541r958358_rule"]}],"description":"Deactivating wireless network interfaces should prevent normal usage of the wireless\ncapability.\n<br>\n         <br>\n\nVerify that there are no wireless interfaces configured on the system\nwith the following command:\n<pre>$ ls -L -d /sys/class/net/*/wireless | xargs dirname | xargs basename -a</pre>\n        ","rationale":"The use of wireless networking can introduce many different attack vectors into\nthe organization&#x27;s network. Common attack vectors such as malicious association\nand ad hoc networks will allow an attacker to spoof a wireless access point\n(AP), allowing validated systems to connect to the malicious AP and enabling the\nattacker to monitor and record network traffic. These malicious APs can also\nserve to create a man-in-the-middle attack or be used to create a denial of\nservice to valid network resources.","platforms":["#not_container_and_wifi-iface"],"oval_definition_id":"oval:ssg-wireless_disable_interfaces:def:1","remediations":[{"remediation_id":"wireless_disable_interfaces","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif ( ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ); then\n\nif [ -n \"$(find /sys/class/net/*/ -type d -name wireless)\" ]; then\n    interfaces=$(find /sys/class/net/*/wireless -type d -name wireless | xargs -0 dirname | xargs basename)\n\n    for i in $interfaces; do\n        ip link set dev \"$i\" down\n        drivers=$(basename \"$(readlink -f /sys/class/net/\"$i\"/device/driver)\")\n        echo \"install $drivers /bin/false\" >> /etc/modprobe.d/disable_wireless.conf\n        modprobe -r \"$drivers\"\n     done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"wireless_disable_interfaces","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"unknown","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-291015\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n\n- name: Service facts\n  ansible.builtin.service_facts: null\n  when: ( not ( ansible_virtualization_type in [\"docker\", \"lxc\", \"openvz\", \"podman\",\n    \"container\"] ) )\n  tags:\n  - DISA-STIG-UBTU-22-291015\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n\n- name: Ensure NetworkManager is installed\n  ansible.builtin.package:\n    name: '{{ item }}'\n    state: present\n  with_items:\n  - NetworkManager\n  when: ( not ( ansible_virtualization_type in [\"docker\", \"lxc\", \"openvz\", \"podman\",\n    \"container\"] ) )\n  tags:\n  - DISA-STIG-UBTU-22-291015\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n\n- name: NetworkManager Deactivate Wireless Network Interfaces\n  ansible.builtin.command: nmcli radio wifi off\n  when:\n  - ( not ( ansible_virtualization_type in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n    ) )\n  - '''NetworkManager'' in ansible_facts.packages'\n  - ansible_facts.services['NetworkManager.service'].state == 'running'\n  tags:\n  - DISA-STIG-UBTU-22-291015\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n"}],"vuln_id":"SV-260541","stig_id":"UBTU-22-291015"},"xccdf_org.ssgproject.content_rule_only_allow_dod_certs":{"rule_id":"xccdf_org.ssgproject.content_rule_only_allow_dod_certs","title":"Only Allow DoD PKI-established CAs","result":"notchecked","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000403-GPOS-00182"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-631010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260580r958868_rule"]}],"description":"The operating system must only allow the use of DoD PKI-established\ncertificate authorities for verification of the establishment of\nprotected sessions.","rationale":"Untrusted Certificate Authorities (CA) can issue certificates, but they\nmay be issued by organizations or individuals that seek to compromise\nDoD systems or by organizations with insufficient security controls. If\nthe CA used for verifying the certificate is not a DoD-approved CA,\ntrust of this CA has not been established.\nThe DoD will only accept PKI-certificates obtained from a DoD-approved\ninternal or external certificate authority. Reliance on CAs for the\nestablishment of secure sessions includes, for example, the use of\nSSL/TLS certificates.","messages":["No candidate or applicable check found."],"vuln_id":"SV-260580","stig_id":"UBTU-22-631010"},"xccdf_org.ssgproject.content_rule_dir_perms_world_writable_sticky_bits":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_perms_world_writable_sticky_bits","title":"Verify that All World-Writable Directories Have Sticky Bits Set","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R54"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["12","13","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.07","DSS06.02"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.7.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000138-GPOS-00069"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232145"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260513r958524_rule"]}],"description":"When the so-called &#x27;sticky bit&#x27; is set on a directory, only the owner of a given file may\nremove that file from the directory. Without the sticky bit, any user with write access to a\ndirectory may remove any file in the directory. Setting the sticky bit prevents users from\nremoving each other&#x27;s files. In cases where there is no reason for a directory to be\nworld-writable, a better solution is to remove that permission rather than to set the sticky\nbit. However, if a directory is used by a particular application, consult that application&#x27;s\ndocumentation instead of blindly changing modes.\n<br>\nTo set the sticky bit on a world-writable directory <i>DIR</i>, run the following command:\n<pre>$ sudo chmod +t <i>DIR</i>\n        </pre>\n       ","rationale":"Failing to set the sticky bit on public directories allows unauthorized users to delete files\nin the directory structure.\n<br>\n        <br>\nThe only authorized public directories are those temporary directories supplied with the\nsystem, or those designed to be temporary file repositories. The setting is normally reserved\nfor directories used by the system, by users for temporary file storage (such as <code>/tmp</code>),\nand for directories requiring global read/write access.","warnings":[{"text":"This rule can take a long time to perform the check and might consume a considerable\namount of resources depending on the number of directories present on the system. It is\nnot a problem in most cases, but especially systems with a large number of directories can\nbe affected. See <code>https://access.redhat.com/articles/6999111</code>.","category":"general"},{"text":"Please note that there might be cases where the rule remediation cannot fix directory permissions.\nThis can happen for example when running on a system with some immutable parts.\nThese immutable parts cannot be remediated because they are read-only.\nExample of such directories can be OStree deployments located at <code>/sysroot/ostree/deploy</code>.\nIn such case, it is needed to make modifications to the underlying ostree snapshot and this is out of scope of regular rule remediation.","category":"general"}],"oval_definition_id":"oval:ssg-dir_perms_world_writable_sticky_bits:def:1","remediations":[{"remediation_id":"dir_perms_world_writable_sticky_bits","system":"urn:xccdf:fix:script:sh","fix":"df --local -P | awk '{if (NR!=1) print $6}' \\\n| xargs -I '$6' find '$6' -xdev -type d \\\n\\( -perm -0002 -a ! -perm -1000 \\) 2>/dev/null \\\n-exec chmod a+t {} +\n"}],"vuln_id":"SV-260513","stig_id":"UBTU-22-232145"},"xccdf_org.ssgproject.content_rule_permissions_local_var_log":{"rule_id":"xccdf_org.ssgproject.content_rule_permissions_local_var_log","title":"Verify permissions of log files","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["SI-11(a)","SI-11(b)","SI-11.1(iii)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000205-GPOS-00083"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232026"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260489r958564_rule"]}],"description":"Any operating system providing too much information in error messages\nrisks compromising the data and security of the structure, and content\nof error messages needs to be carefully considered by the organization.\n\nOrganizations carefully consider the structure/content of error messages.\nThe extent to which information systems are able to identify and handle\nerror conditions is guided by organizational policy and operational\nrequirements. Information that could be exploited by adversaries includes,\nfor example, erroneous logon attempts with passwords entered by mistake\nas the username, mission/business information that can be derived from\n(if not stated explicitly by) information recorded, and personal\ninformation, such as account numbers, social security numbers, and credit\ncard numbers.","rationale":"The Ubuntu 22.04 must generate error messages that provide information\nnecessary for corrective actions without revealing information that could\nbe exploited by adversaries.","oval_definition_id":"oval:ssg-permissions_local_var_log:def:1","remediations":[{"remediation_id":"permissions_local_var_log","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\n\n\n\nfind -P /var/log/  -perm /u+xs,g+xws,o+xwrt ! -name 'history.log*' ! -name 'eipp.log.xz*' ! -name '[bw]tmp' ! -name '[bw]tmp.*' ! -name '[bw]tmp-*' ! -name 'lastlog' ! -name 'lastlog.*' -type f -regextype posix-extended -regex '.*' -exec chmod u-xs,g-xws,o-xwrt {} \\;\n"},{"remediation_id":"permissions_local_var_log","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Find /var/log/ file(s) recursively\n  ansible.builtin.command: find -P /var/log/  -perm /u+xs,g+xws,o+xwrt ! -name \"history.log*\"\n    ! -name \"eipp.log.xz*\" ! -name \"[bw]tmp\" ! -name \"[bw]tmp.*\" ! -name \"[bw]tmp-*\"\n    ! -name \"lastlog\" ! -name \"lastlog.*\" -type f -regextype posix-extended -regex\n    \".*\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232026\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - NIST-800-53-SI-11.1(iii)\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - permissions_local_var_log\n\n- name: Set permissions for /var/log/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-xs,g-xws,o-xwrt\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232026\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - NIST-800-53-SI-11.1(iii)\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - permissions_local_var_log\n"}],"vuln_id":"SV-260489","stig_id":"UBTU-22-232026"},"xccdf_org.ssgproject.content_rule_file_groupowner_var_log":{"rule_id":"xccdf_org.ssgproject.content_rule_file_groupowner_var_log","title":"Verify Group Who Owns /var/log Directory","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000118-CTR-000240"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000206-GPOS-00084"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232125"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260509r958566_rule"]}],"description":" To properly set the group owner of <code>/var/log</code>, run the command:\n<pre>$ sudo chgrp syslog /var/log</pre>\n        ","rationale":"The <code>/var/log</code> directory contains files with logs of error\nmessages in the system and should only be accessed by authorized\npersonnel.","oval_definition_id":"oval:ssg-file_groupowner_var_log:def:1","remediations":[{"remediation_id":"file_groupowner_var_log","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\nnewgroup=\"\"\nif getent group \"syslog\" >/dev/null 2>&1; then\n  newgroup=\"syslog\"\nfi\n\nif [[ -z \"${newgroup}\" ]]; then\n  >&2 echo \"syslog is not a defined group on the system\"\nelse\nfind -P /var/log/ -maxdepth 0 -type d  ! -group syslog -exec chgrp --no-dereference \"$newgroup\" {} \\;\n\nfi\n"},{"remediation_id":"file_groupowner_var_log","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Check that the syslog group is defined\n  ansible.builtin.getent:\n    database: group\n    key: syslog\n  ignore_errors: true\n  when: file_groupowner_var_log_newgroup is undefined\n  tags:\n  - DISA-STIG-UBTU-22-232125\n  - configure_strategy\n  - file_groupowner_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_groupowner_var_log_newgroup variable if syslog found\n  ansible.builtin.set_fact:\n    file_groupowner_var_log_newgroup: syslog\n  when: ansible_facts.getent_group[\"syslog\"] is defined\n  tags:\n  - DISA-STIG-UBTU-22-232125\n  - configure_strategy\n  - file_groupowner_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /var/log/\n  ansible.builtin.file:\n    path: /var/log/\n    follow: false\n    state: directory\n    group: '{{ file_groupowner_var_log_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232125\n  - configure_strategy\n  - file_groupowner_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260509","stig_id":"UBTU-22-232125"},"xccdf_org.ssgproject.content_rule_file_groupowner_var_log_syslog":{"rule_id":"xccdf_org.ssgproject.content_rule_file_groupowner_var_log_syslog","title":"Verify Group Who Owns /var/log/syslog File","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000206-GPOS-00084"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232135"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260511r958566_rule"]}],"description":" To properly set the group owner of <code>/var/log/syslog</code>, run the command:\n<pre>$ sudo chgrp adm /var/log/syslog</pre>\n        ","rationale":"The <code>/var/log/syslog</code> file contains logs of error messages in\nthe system and should only be accessed by authorized personnel.","platforms":["#package_rsyslog"],"oval_definition_id":"oval:ssg-file_groupowner_var_log_syslog:def:1","remediations":[{"remediation_id":"file_groupowner_var_log_syslog","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'rsyslog' 2>/dev/null | grep -q '^installed$'; then\n\nnewgroup=\"\"\nif getent group \"4\" >/dev/null 2>&1; then\n  newgroup=\"4\"\nfi\n\nif [[ -z \"${newgroup}\" ]]; then\n  >&2 echo \"4 is not a defined group on the system\"\nelse\nif ! stat -c \"%g %G\" \"/var/log/syslog\" | grep -E -w -q \"4\"; then\n    chgrp --no-dereference \"$newgroup\" /var/log/syslog\nfi\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_groupowner_var_log_syslog","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232135\n  - configure_strategy\n  - file_groupowner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_groupowner_var_log_syslog_newgroup variable if represented by\n    gid\n  ansible.builtin.set_fact:\n    file_groupowner_var_log_syslog_newgroup: '4'\n  when: '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232135\n  - configure_strategy\n  - file_groupowner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /var/log/syslog\n  ansible.builtin.stat:\n    path: /var/log/syslog\n  register: file_exists\n  when: '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232135\n  - configure_strategy\n  - file_groupowner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /var/log/syslog\n  ansible.builtin.file:\n    path: /var/log/syslog\n    follow: false\n    group: '{{ file_groupowner_var_log_syslog_newgroup }}'\n  when:\n  - '\"rsyslog\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232135\n  - configure_strategy\n  - file_groupowner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260511","stig_id":"UBTU-22-232135"},"xccdf_org.ssgproject.content_rule_file_owner_var_log":{"rule_id":"xccdf_org.ssgproject.content_rule_file_owner_var_log","title":"Verify User Who Owns /var/log Directory","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000118-CTR-000240"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000206-GPOS-00084"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232120"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260508r958566_rule"]}],"description":" To properly set the owner of <code>/var/log</code>, run the command:\n<pre>$ sudo chown root /var/log </pre>\n        ","rationale":"The <code>/var/log</code> directory contains files with logs of error\nmessages in the system and should only be accessed by authorized\npersonnel.","oval_definition_id":"oval:ssg-file_owner_var_log:def:1","remediations":[{"remediation_id":"file_owner_var_log","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\nnewown=\"\"\nif id \"0\" >/dev/null 2>&1; then\n  newown=\"0\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"0 is not a defined user on the system\"\nelse\nfind -P /var/log/ -maxdepth 0 -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\n\nfi\n"},{"remediation_id":"file_owner_var_log","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Set the file_owner_var_log_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    file_owner_var_log_newown: '0'\n  tags:\n  - DISA-STIG-UBTU-22-232120\n  - configure_strategy\n  - file_owner_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /var/log/\n  ansible.builtin.file:\n    path: /var/log/\n    follow: false\n    state: directory\n    owner: '{{ file_owner_var_log_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232120\n  - configure_strategy\n  - file_owner_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260508","stig_id":"UBTU-22-232120"},"xccdf_org.ssgproject.content_rule_file_owner_var_log_syslog":{"rule_id":"xccdf_org.ssgproject.content_rule_file_owner_var_log_syslog","title":"Verify User Who Owns /var/log/syslog File","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000206-GPOS-00084"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232130"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260510r958566_rule"]}],"description":" To properly set the owner of <code>/var/log/syslog</code>, run the command:\n<pre>$ sudo chown syslog /var/log/syslog </pre>\n        ","rationale":"The <code>/var/log/syslog</code> file contains logs of error messages in\nthe system and should only be accessed by authorized personnel.","platforms":["#package_rsyslog"],"oval_definition_id":"oval:ssg-file_owner_var_log_syslog:def:1","remediations":[{"remediation_id":"file_owner_var_log_syslog","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'rsyslog' 2>/dev/null | grep -q '^installed$'; then\n\nnewown=\"\"\nif id \"syslog\" >/dev/null 2>&1; then\n  newown=\"syslog\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"syslog is not a defined user on the system\"\nelse\nif ! stat -c \"%u %U\" \"/var/log/syslog\" | grep -E -w -q \"syslog\"; then\n    chown --no-dereference \"$newown\" /var/log/syslog\nfi\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_owner_var_log_syslog","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232130\n  - configure_strategy\n  - file_owner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Check that the syslog user is defined\n  ansible.builtin.getent:\n    database: passwd\n    key: syslog\n  ignore_errors: true\n  when: '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232130\n  - configure_strategy\n  - file_owner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_owner_var_log_syslog_newown variable if syslog found\n  ansible.builtin.set_fact:\n    file_owner_var_log_syslog_newown: syslog\n  when:\n  - '\"rsyslog\" in ansible_facts.packages'\n  - ansible_facts.getent_passwd[\"syslog\"] is defined\n  tags:\n  - DISA-STIG-UBTU-22-232130\n  - configure_strategy\n  - file_owner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /var/log/syslog\n  ansible.builtin.stat:\n    path: /var/log/syslog\n  register: file_exists\n  when: '\"rsyslog\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232130\n  - configure_strategy\n  - file_owner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /var/log/syslog\n  ansible.builtin.file:\n    path: /var/log/syslog\n    follow: false\n    owner: '{{ file_owner_var_log_syslog_newown }}'\n  when:\n  - '\"rsyslog\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232130\n  - configure_strategy\n  - file_owner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260510","stig_id":"UBTU-22-232130"},"xccdf_org.ssgproject.content_rule_file_permissions_var_log":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_var_log","title":"Verify Permissions on /var/log Directory","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000118-CTR-000240"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000206-GPOS-00084"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260488r958566_rule"]}],"description":"\nTo properly set the permissions of <code>/var/log</code>, run the command:\n<pre>$ sudo chmod 0755 /var/log</pre>\n        ","rationale":"The <code>/var/log</code> directory contains files with logs of error\nmessages in the system and should only be accessed by authorized\npersonnel.","platforms":["#service_disabled_rsyslog"],"oval_definition_id":"oval:ssg-file_permissions_var_log:def:1","remediations":[{"remediation_id":"file_permissions_var_log","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif ! (systemctl is-active rsyslog &>/dev/null); then\n\nchmod 0755 /var/log/\n\nif grep -q \"^z \\/var\\/log \" /usr/lib/tmpfiles.d/00rsyslog.conf; then\n    sed -i --follow-symlinks \"s/\\(^z[[:space:]]\\+\\/var\\/log[[:space:]]\\+\\)\\(\\([[:digit:]]\\+\\)[^ $]*\\)/\\10755/\" /usr/lib/tmpfiles.d/00rsyslog.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_permissions_var_log","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Find /var/log/ file(s)\n  ansible.builtin.command: 'find -P /var/log/ -maxdepth 0 -perm /u+s,g+ws,o+wt  -type\n    d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232025\n  - configure_strategy\n  - file_permissions_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /var/log/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232025\n  - configure_strategy\n  - file_permissions_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260488","stig_id":"UBTU-22-232025"},"xccdf_org.ssgproject.content_rule_file_permissions_var_log_syslog":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_var_log_syslog","title":"Verify Permissions on /var/log/syslog File","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000206-GPOS-00084"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260491r958566_rule"]}],"description":"\nTo properly set the permissions of <code>/var/log/syslog</code>, run the command:\n<pre>$ sudo chmod 0640 /var/log/syslog</pre>\n        ","rationale":"The <code>/var/log/syslog</code> file contains logs of error messages in\nthe system and should only be accessed by authorized personnel.","oval_definition_id":"oval:ssg-file_permissions_var_log_syslog:def:1","remediations":[{"remediation_id":"file_permissions_var_log_syslog","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\n\n\n\nchmod u-xs,g-xws,o-xwrt /var/log/syslog\n"},{"remediation_id":"file_permissions_var_log_syslog","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Test for existence /var/log/syslog\n  ansible.builtin.stat:\n    path: /var/log/syslog\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-22-232030\n  - configure_strategy\n  - file_permissions_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xs,g-xws,o-xwrt on /var/log/syslog\n  ansible.builtin.file:\n    path: /var/log/syslog\n    mode: u-xs,g-xws,o-xwrt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232030\n  - configure_strategy\n  - file_permissions_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260491","stig_id":"UBTU-22-232030"},"xccdf_org.ssgproject.content_rule_dir_group_ownership_library_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_group_ownership_library_dirs","title":"Verify that Shared Library Directories Have Root Group Ownership","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-5(6)","CM-5(6).1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232065"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260498r991560_rule"]}],"description":"System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are also\nstored in <code>/lib/modules</code>. All files in these directories should be\ngroup-owned by the <code>root</code> user. If the  directories, is found to be owned\nby a user other than root correct its\nownership with the following command:\n<pre>$ sudo chgrp root <i>DIR</i>\n         </pre>\n        ","rationale":"Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Proper ownership of library directories is necessary to protect\nthe integrity of the system.","oval_definition_id":"oval:ssg-dir_group_ownership_library_dirs:def:1","remediations":[{"remediation_id":"dir_group_ownership_library_dirs","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\nnewgroup=\"\"\nif getent group \"0\" >/dev/null 2>&1; then\n  newgroup=\"0\"\nfi\n\nif [[ -z \"${newgroup}\" ]]; then\n  >&2 echo \"0 is not a defined group on the system\"\nelse\nfind -P /lib/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /lib64/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /usr/lib/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /usr/lib64/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\n\nfi\n"},{"remediation_id":"dir_group_ownership_library_dirs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Set the dir_group_ownership_library_dirs_newgroup variable if represented\n    by gid\n  ansible.builtin.set_fact:\n    dir_group_ownership_library_dirs_newgroup: '0'\n  tags:\n  - DISA-STIG-UBTU-22-232065\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /lib/ recursively\n  ansible.builtin.file:\n    path: /lib/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_group_ownership_library_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232065\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /lib64/ recursively\n  ansible.builtin.file:\n    path: /lib64/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_group_ownership_library_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232065\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/lib/ recursively\n  ansible.builtin.file:\n    path: /usr/lib/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_group_ownership_library_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232065\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/lib64/ recursively\n  ansible.builtin.file:\n    path: /usr/lib64/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_group_ownership_library_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232065\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260498","stig_id":"UBTU-22-232065"},"xccdf_org.ssgproject.content_rule_dir_groupownership_binary_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_groupownership_binary_dirs","title":"Verify that system commands directories are group owned by root","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000258-GPOS-00099"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260494r991559_rule"]}],"description":"System commands files are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin\n</pre>\nAll these directories should be owned by the <code>root</code> group.\nIf the directory is found to be owned by a group other than root correct\nits ownership with the following command:\n<pre>$ sudo chgrp root <i>DIR</i>\n         </pre>\n        ","rationale":"If the operating system allows any user to make changes to software\nlibraries, then those changes might be implemented without undergoing the\nappropriate testing and approvals that are part of a robust change management\nprocess.\nThis requirement applies to operating systems with software libraries\nthat are accessible and configurable, as in the case of interpreted languages.\nSoftware libraries also include privileged programs which execute with\nescalated privileges. Only qualified and authorized individuals must be\nallowed to obtain access to information system components for purposes\nof initiating changes, including upgrades and modifications.","oval_definition_id":"oval:ssg-dir_groupownership_binary_dirs:def:1","remediations":[{"remediation_id":"dir_groupownership_binary_dirs","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\nnewgroup=\"\"\nif getent group \"0\" >/dev/null 2>&1; then\n  newgroup=\"0\"\nfi\n\nif [[ -z \"${newgroup}\" ]]; then\n  >&2 echo \"0 is not a defined group on the system\"\nelse\nfind -P /bin/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /sbin/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /usr/bin/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /usr/sbin/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /usr/local/bin/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /usr/local/sbin/  -type d  ! -group 0 -exec chgrp --no-dereference \"$newgroup\" {} \\;\n\nfi\n"},{"remediation_id":"dir_groupownership_binary_dirs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Set the dir_groupownership_binary_dirs_newgroup variable if represented by\n    gid\n  ansible.builtin.set_fact:\n    dir_groupownership_binary_dirs_newgroup: '0'\n  tags:\n  - DISA-STIG-UBTU-22-232045\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /bin/ recursively\n  ansible.builtin.file:\n    path: /bin/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupownership_binary_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232045\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /sbin/ recursively\n  ansible.builtin.file:\n    path: /sbin/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupownership_binary_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232045\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/bin/ recursively\n  ansible.builtin.file:\n    path: /usr/bin/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupownership_binary_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232045\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/sbin/ recursively\n  ansible.builtin.file:\n    path: /usr/sbin/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupownership_binary_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232045\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/local/bin/ recursively\n  ansible.builtin.file:\n    path: /usr/local/bin/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupownership_binary_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232045\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/local/sbin/ recursively\n  ansible.builtin.file:\n    path: /usr/local/sbin/\n    follow: false\n    state: directory\n    recurse: true\n    group: '{{ dir_groupownership_binary_dirs_newgroup }}'\n  tags:\n  - DISA-STIG-UBTU-22-232045\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260494","stig_id":"UBTU-22-232045"},"xccdf_org.ssgproject.content_rule_dir_ownership_binary_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_ownership_binary_dirs","title":"Verify that System Executable Have Root Ownership","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000258-GPOS-00099"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260493r991559_rule"]}],"description":"<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin</pre>\nAll these directories should be owned by the <code>root</code> user.\nIf any directory <i>DIR</i> in these directories is found\nto be owned by a user other than root, correct its ownership with the\nfollowing command:\n<pre>$ sudo chown root <i>DIR</i>\n         </pre>\n        ","rationale":"System binaries are executed by privileged users as well as system services,\nand restrictive permissions are necessary to ensure that their\nexecution of these programs cannot be co-opted.","oval_definition_id":"oval:ssg-dir_ownership_binary_dirs:def:1","remediations":[{"remediation_id":"dir_ownership_binary_dirs","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\nnewown=\"\"\nif id \"0\" >/dev/null 2>&1; then\n  newown=\"0\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"0 is not a defined user on the system\"\nelse\nfind -P /bin/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /sbin/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /usr/bin/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /usr/sbin/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /usr/local/bin/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /usr/local/sbin/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\n\nfi\n"},{"remediation_id":"dir_ownership_binary_dirs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Set the dir_ownership_binary_dirs_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    dir_ownership_binary_dirs_newown: '0'\n  tags:\n  - DISA-STIG-UBTU-22-232040\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /bin/ recursively\n  ansible.builtin.file:\n    path: /bin/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_binary_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232040\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /sbin/ recursively\n  ansible.builtin.file:\n    path: /sbin/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_binary_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232040\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/bin/ recursively\n  ansible.builtin.file:\n    path: /usr/bin/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_binary_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232040\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/sbin/ recursively\n  ansible.builtin.file:\n    path: /usr/sbin/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_binary_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232040\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/local/bin/ recursively\n  ansible.builtin.file:\n    path: /usr/local/bin/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_binary_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232040\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/local/sbin/ recursively\n  ansible.builtin.file:\n    path: /usr/local/sbin/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_binary_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232040\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260493","stig_id":"UBTU-22-232040"},"xccdf_org.ssgproject.content_rule_dir_ownership_library_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_ownership_library_dirs","title":"Verify that Shared Library Directories Have Root Ownership","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-5(6)","CM-5(6).1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232060"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260497r991560_rule"]}],"description":"System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are also\nstored in <code>/lib/modules</code>. All files in these directories should be\nowned by the <code>root</code> user. If the  directories, is found to be owned\nby a user other than root correct its\nownership with the following command:\n<pre>$ sudo chown root <i>DIR</i>\n         </pre>\n        ","rationale":"Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Proper ownership of library directories is necessary to protect\nthe integrity of the system.","oval_definition_id":"oval:ssg-dir_ownership_library_dirs:def:1","remediations":[{"remediation_id":"dir_ownership_library_dirs","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\nnewown=\"\"\nif id \"0\" >/dev/null 2>&1; then\n  newown=\"0\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"0 is not a defined user on the system\"\nelse\nfind -P /lib/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /lib64/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /usr/lib/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\nfind -P /usr/lib64/  -type d  ! -user 0 -exec chown --no-dereference \"$newown\" {} \\;\n\nfi\n"},{"remediation_id":"dir_ownership_library_dirs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Set the dir_ownership_library_dirs_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    dir_ownership_library_dirs_newown: '0'\n  tags:\n  - DISA-STIG-UBTU-22-232060\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /lib/ recursively\n  ansible.builtin.file:\n    path: /lib/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_library_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232060\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /lib64/ recursively\n  ansible.builtin.file:\n    path: /lib64/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_library_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232060\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/lib/ recursively\n  ansible.builtin.file:\n    path: /usr/lib/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_library_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232060\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/lib64/ recursively\n  ansible.builtin.file:\n    path: /usr/lib64/\n    follow: false\n    state: directory\n    recurse: true\n    owner: '{{ dir_ownership_library_dirs_newown }}'\n  tags:\n  - DISA-STIG-UBTU-22-232060\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260497","stig_id":"UBTU-22-232060"},"xccdf_org.ssgproject.content_rule_dir_permissions_binary_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_dir_permissions_binary_dirs","title":"Verify that System Executable Directories Have Restrictive Permissions","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000258-GPOS-00099"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260485r991559_rule"]}],"description":"System executables are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin</pre>\nThese directories should not be group-writable or world-writable.\nIf any directory <i>DIR</i> in these directories is found to be\ngroup-writable or world-writable, correct its permission with the\nfollowing command:\n<pre>$ sudo chmod go-w <i>DIR</i>\n         </pre>\n        ","rationale":"System binaries are executed by privileged users, as well as system services,\nand restrictive permissions are necessary to ensure execution of these programs\ncannot be co-opted.","oval_definition_id":"oval:ssg-dir_permissions_binary_dirs:def:1","remediations":[{"remediation_id":"dir_permissions_binary_dirs","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\n\n\n\nfind -H /bin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /sbin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/bin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/sbin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/local/bin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/local/sbin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n"},{"remediation_id":"dir_permissions_binary_dirs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Find /bin/ file(s) recursively\n  ansible.builtin.command: 'find -P /bin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /bin/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /sbin/ file(s) recursively\n  ansible.builtin.command: 'find -P /sbin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /sbin/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/bin/ file(s) recursively\n  ansible.builtin.command: 'find -P /usr/bin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/bin/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/sbin/ file(s) recursively\n  ansible.builtin.command: 'find -P /usr/sbin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/sbin/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/local/bin/ file(s) recursively\n  ansible.builtin.command: 'find -P /usr/local/bin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/local/bin/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/local/sbin/ file(s) recursively\n  ansible.builtin.command: 'find -P /usr/local/sbin/  -perm /u+s,g+ws,o+wt  -type\n    d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/local/sbin/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232010\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260485","stig_id":"UBTU-22-232010"},"xccdf_org.ssgproject.content_rule_file_groupownership_system_commands_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_file_groupownership_system_commands_dirs","title":"Verify that system commands files are group owned by root or a system account","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R50"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-5(6)","CM-5(6).1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232055"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260496r991560_rule"]}],"description":"System commands files are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin\n</pre>\nAll files in these directories should be owned by the <code>root</code> group,\nor a system account.\nIf the directory, or any file in these directories, is found to be owned\nby a group other than root or a a system account correct its ownership\nwith the following command:\n<pre>$ sudo chgrp root <i>FILE</i>\n         </pre>\n        ","rationale":"If the operating system allows any user to make changes to software\nlibraries, then those changes might be implemented without undergoing the\nappropriate testing and approvals that are part of a robust change management\nprocess.\nThis requirement applies to operating systems with software libraries\nthat are accessible and configurable, as in the case of interpreted languages.\nSoftware libraries also include privileged programs which execute with\nescalated privileges. Only qualified and authorized individuals must be\nallowed to obtain access to information system components for purposes\nof initiating changes, including upgrades and modifications.","oval_definition_id":"oval:ssg-file_groupownership_system_commands_dirs:def:1","remediations":[{"remediation_id":"file_groupownership_system_commands_dirs","system":"urn:xccdf:fix:script:sh","fix":"\n\nfind -P /bin/ /sbin/ /usr/bin/ /usr/sbin/ /usr/local/bin/ /usr/local/sbin/ \\! -gid -1000 -type f ! -perm /2000 -exec chgrp root '{}' \\; || true\n"}],"vuln_id":"SV-260496","stig_id":"UBTU-22-232055"},"xccdf_org.ssgproject.content_rule_file_ownership_binary_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_file_ownership_binary_dirs","title":"Verify that System Executables Have Root Ownership","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R50"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["12","13","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.07","DSS06.02"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.7.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-5(6)","CM-5(6).1","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232050"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260495r991560_rule"]}],"description":"System executables are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/libexec\n/usr/local/bin\n/usr/local/sbin\n/usr/sbin</pre>\nAll files in these directories should be owned by the <code>root</code> user.\nIf any file <i>FILE</i> in these directories is found\nto be owned by a user other than root, correct its ownership with the\nfollowing command:\n<pre>$ sudo chown root <i>FILE</i>\n         </pre>\n        ","rationale":"System binaries are executed by privileged users as well as system services,\nand restrictive permissions are necessary to ensure that their\nexecution of these programs cannot be co-opted.","oval_definition_id":"oval:ssg-file_ownership_binary_dirs:def:1","remediations":[{"remediation_id":"file_ownership_binary_dirs","system":"urn:xccdf:fix:script:sh","fix":"\nfind /bin/ /usr/bin/ /usr/local/bin/ /sbin/ /usr/sbin/ /usr/local/sbin/ \\! -uid -1000 -execdir chown root {} \\;\n"}],"vuln_id":"SV-260495","stig_id":"UBTU-22-232050"},"xccdf_org.ssgproject.content_rule_file_ownership_library_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_file_ownership_library_dirs","title":"Verify that Shared Library Files Have Root Ownership","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["12","13","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.07","DSS06.02"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.7.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-5(6)","CM-5(6).1","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232070"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260499r991560_rule"]}],"description":"System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are also\nstored in <code>/lib/modules</code>. All files in these directories should be\nowned by the <code>root</code> user. If the directory, or any file in these\ndirectories, is found to be owned by a user other than root correct its\nownership with the following command:\n<pre>$ sudo chown root <i>FILE</i>\n         </pre>\n        ","rationale":"Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Proper ownership is necessary to protect the integrity of the system.","oval_definition_id":"oval:ssg-file_ownership_library_dirs:def:1","remediations":[{"remediation_id":"file_ownership_library_dirs","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\nnewown=\"\"\nif id \"0\" >/dev/null 2>&1; then\n  newown=\"0\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"0 is not a defined user on the system\"\nelse\n\nfind -P /lib/  -type f  ! -user 0 -regextype posix-extended -regex '^.*$' -exec chown --no-dereference \"$newown\" {} \\;\n\nfind -P /lib64/  -type f  ! -user 0 -regextype posix-extended -regex '^.*$' -exec chown --no-dereference \"$newown\" {} \\;\n\nfind -P /usr/lib/  -type f  ! -user 0 -regextype posix-extended -regex '^.*$' -exec chown --no-dereference \"$newown\" {} \\;\n\nfind -P /usr/lib64/  -type f  ! -user 0 -regextype posix-extended -regex '^.*$' -exec chown --no-dereference \"$newown\" {} \\;\n\nfi\n"},{"remediation_id":"file_ownership_library_dirs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Set the file_ownership_library_dirs_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    file_ownership_library_dirs_newown: '0'\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /lib/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /lib/  -type f  ! -user 0 -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /lib/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_ownership_library_dirs_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /lib64/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /lib64/  -type f  ! -user 0 -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /lib64/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_ownership_library_dirs_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /usr/lib/  -type f  ! -user 0 -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /usr/lib/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_ownership_library_dirs_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib64/ file(s) matching ^.*$ recursively\n  ansible.builtin.command: find -P /usr/lib64/  -type f  ! -user 0 -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /usr/lib64/ file(s) matching ^.*$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_ownership_library_dirs_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232070\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260499","stig_id":"UBTU-22-232070"},"xccdf_org.ssgproject.content_rule_file_permissions_binary_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_binary_dirs","title":"Verify that System Executables Have Restrictive Permissions","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R50"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["12","13","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.07","DSS06.02"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.7.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-5(6)","CM-5(6).1","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260486r991560_rule"]}],"description":"System executables are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/libexec\n/usr/local/bin\n/usr/local/sbin\n/usr/sbin</pre>\nAll files in these directories should not be group-writable or world-writable.\nIf any file <i>FILE</i> in these directories is found\nto be group-writable or world-writable, correct its permission with the\nfollowing command:\n<pre>$ sudo chmod go-w <i>FILE</i>\n         </pre>\n        ","rationale":"System binaries are executed by privileged users, as well as system services,\nand restrictive permissions are necessary to ensure execution of these programs\ncannot be co-opted.","oval_definition_id":"oval:ssg-file_permissions_binary_dirs:def:1","remediations":[{"remediation_id":"file_permissions_binary_dirs","system":"urn:xccdf:fix:script:sh","fix":"DIRS=\"/bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin /usr/libexec\"\nfor dirPath in $DIRS; do\n\tfind \"$dirPath\" -perm /022 -exec chmod go-w '{}' \\;\ndone\n"}],"vuln_id":"SV-260486","stig_id":"UBTU-22-232015"},"xccdf_org.ssgproject.content_rule_file_permissions_library_dirs":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_library_dirs","title":"Verify that Shared Library Files Have Restrictive Permissions","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["12","13","14","15","16","18","3","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.04","DSS05.07","DSS06.02"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.7.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","CM-5(6)","CM-5(6).1","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260487r991560_rule"]}],"description":"System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are\nstored in <code>/lib/modules</code>. All files in these directories\nshould not be group-writable or world-writable. If any file in these\ndirectories is found to be group-writable or world-writable, correct\nits permission with the following command:\n<pre>$ sudo chmod go-w <i>FILE</i>\n         </pre>\n        ","rationale":"Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Restrictive permissions are necessary to protect the integrity of the system.","oval_definition_id":"oval:ssg-file_permissions_library_dirs:def:1","remediations":[{"remediation_id":"file_permissions_library_dirs","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"\n\n\n\nfind -P /lib/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n\nfind -P /lib64/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n\nfind -P /usr/lib/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n\nfind -P /usr/lib64/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n"},{"remediation_id":"file_permissions_library_dirs","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Find /lib/ file(s) recursively\n  ansible.builtin.command: find -P /lib/  -perm /g+w,o+w  -type f -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /lib/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /lib64/ file(s) recursively\n  ansible.builtin.command: find -P /lib64/  -perm /g+w,o+w  -type f -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /lib64/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib/ file(s) recursively\n  ansible.builtin.command: find -P /usr/lib/  -perm /g+w,o+w  -type f -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/lib/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib64/ file(s) recursively\n  ansible.builtin.command: find -P /usr/lib64/  -perm /g+w,o+w  -type f -regextype\n    posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/lib64/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-22-232020\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260487","stig_id":"UBTU-22-232020"},"xccdf_org.ssgproject.content_rule_root_permissions_syslibrary_files":{"rule_id":"xccdf_org.ssgproject.content_rule_root_permissions_syslibrary_files","title":"Verify the system-wide library files in directories\n\"/lib\", \"/lib64\", \"/usr/lib/\" and \"/usr/lib64\" are group-owned by root or a required system account.","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-5(6)","CM-5(6).1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000259-GPOS-00100"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232075"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260500r991560_rule"]}],"description":"System-wide library files are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nAll system-wide shared library files should be protected from unauthorised\naccess. If any of these files is not group-owned by root or a required system account,\ncorrect its group-owner with the following command:\n<pre>$ sudo chgrp root <i>FILE</i>\n         </pre>\n        ","rationale":"If the operating system were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate testing and\napprovals that are part of a robust change management process.\n\nThis requirement applies to operating systems with software libraries that are\naccessible and configurable, as in the case of interpreted languages. Software libraries\nalso include privileged programs which execute with escalated privileges. Only qualified\nand authorized individuals must be allowed to obtain access to information system components\nfor purposes of initiating changes, including upgrades and modifications.","oval_definition_id":"oval:ssg-root_permissions_syslibrary_files:def:1","remediations":[{"remediation_id":"root_permissions_syslibrary_files","system":"urn:xccdf:fix:script:sh","fix":"find /lib/ /lib64/ /usr/lib/ /usr/lib64/ \\! -gid -1000 -type f -exec chgrp --no-dereference root '{}' \\;\n"}],"vuln_id":"SV-260500","stig_id":"UBTU-22-232075"},"xccdf_org.ssgproject.content_rule_kernel_module_usb-storage_disabled":{"rule_id":"xccdf_org.ssgproject.content_rule_kernel_module_usb-storage_disabled","title":"Disable Modprobe Loading of USB Storage Driver","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000141-CTR-000315"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.1.10"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","DSS01.04","DSS05.03","DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.21"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(3)(i)","164.308(a)(3)(ii)(A)","164.310(d)(1)","164.310(d)(2)","164.312(a)(1)","164.312(a)(2)(iv)","164.312(b)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.13.1.1","A.13.2.1","A.18.1.4","A.6.2.1","A.6.2.2","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","CM-7(a)","CM-7(b)","MP-7"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-3","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000114-GPOS-00059","SRG-OS-000378-GPOS-00163","SRG-OS-000480-GPOS-00227"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["3.4","3.4.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-291010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260540r986276_rule"]}],"description":"To prevent USB storage devices from being used, configure the kernel module loading system\nto prevent automatic loading of the USB storage driver.\n\nTo configure the system to prevent the <code>usb-storage</code>\nkernel module from being loaded, add the following line to the file <code>/etc/modprobe.d/usb-storage.conf</code>:\n<pre>install usb-storage /bin/false</pre>\n\nThis will prevent the <code>modprobe</code> program from loading the <code>usb-storage</code>\nmodule, but will not prevent an administrator (or another program) from using the\n<code>insmod</code> program to load the module manually.","rationale":"USB storage devices such as thumb drives can be used to introduce\nmalicious software.","platforms":["#system_with_kernel"],"oval_definition_id":"oval:ssg-kernel_module_usb-storage_disabled:def:1","remediations":[{"remediation_id":"kernel_module_usb-storage_disabled","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"medium","strategy":"disable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif LC_ALL=C grep -q -m 1 \"^install usb-storage\" /etc/modprobe.d/usb-storage.conf ; then\n\t\n\tsed -i 's#^install usb-storage.*#install usb-storage /bin/false#g' /etc/modprobe.d/usb-storage.conf\nelse\n\techo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/usb-storage.conf\n\techo \"install usb-storage /bin/false\" >> /etc/modprobe.d/usb-storage.conf\nfi\n\nif ! LC_ALL=C grep -q -m 1 \"^blacklist usb-storage$\" /etc/modprobe.d/usb-storage.conf ; then\n\techo \"blacklist usb-storage\" >> /etc/modprobe.d/usb-storage.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"kernel_module_usb-storage_disabled","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-291010\n  - NIST-800-171-3.1.21\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSSv4-3.4\n  - PCI-DSSv4-3.4.2\n  - disable_strategy\n  - kernel_module_usb-storage_disabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n\n- name: Ensure kernel module 'usb-storage' is disabled\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/modprobe.d/usb-storage.conf\n    regexp: install\\s+usb-storage\n    line: install usb-storage /bin/false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-291010\n  - NIST-800-171-3.1.21\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSSv4-3.4\n  - PCI-DSSv4-3.4.2\n  - disable_strategy\n  - kernel_module_usb-storage_disabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n\n- name: Ensure kernel module 'usb-storage' is blacklisted\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/modprobe.d/usb-storage.conf\n    regexp: ^blacklist usb-storage$\n    line: blacklist usb-storage\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-291010\n  - NIST-800-171-3.1.21\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSSv4-3.4\n  - PCI-DSSv4-3.4.2\n  - disable_strategy\n  - kernel_module_usb-storage_disabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n"}],"vuln_id":"SV-260540","stig_id":"UBTU-22-291010"},"xccdf_org.ssgproject.content_rule_sysctl_kernel_dmesg_restrict":{"rule_id":"xccdf_org.ssgproject.content_rule_sysctl_kernel_dmesg_restrict","title":"Restrict Access to Kernel Message Buffer","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"low","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R9"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000243-CTR-000600"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.5"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)","164.308(a)(4)","164.310(b)","164.310(c)","164.312(a)","164.312(e)"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["SI-11(a)","SI-11(b)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000132-GPOS-00067","SRG-OS-000138-GPOS-00069"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-213010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260472r958524_rule"]}],"description":"To set the runtime status of the <code>kernel.dmesg_restrict</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.dmesg_restrict=1</pre>\nTo make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>kernel.dmesg_restrict = 1</pre>\n       ","rationale":"Unprivileged access to the kernel syslog can expose sensitive kernel\naddress information.","platforms":["#system_with_kernel"],"oval_definition_id":"oval:ssg-sysctl_kernel_dmesg_restrict:def:1","remediations":[{"remediation_id":"sysctl_kernel_dmesg_restrict","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"medium","strategy":"disable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Comment out any occurrences of kernel.dmesg_restrict from /etc/sysctl.d/*.conf files\n\nfor f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /etc/ufw/sysctl.conf; do\n\n\n  # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf)\n  if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi\n\n  matching_list=$(grep -P '^(?!#).*[\\s]*kernel.dmesg_restrict.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\")\n      # comment out \"kernel.dmesg_restrict\" matches to preserve user data\n      sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n  fi\ndone\n\n#\n# Set sysctl config file which to save the desired value\n#\n\nSYSCONFIG_FILE=\"/etc/sysctl.conf\"\n\n\n#\n# Set runtime for kernel.dmesg_restrict\n#\nif ! /bin/false ; then\n    /sbin/sysctl -q -n -w kernel.dmesg_restrict=\"1\"\nfi\n\n#\n# If kernel.dmesg_restrict present in /etc/sysctl.conf, change value to \"1\"\n#\telse, add \"kernel.dmesg_restrict = 1\" to /etc/sysctl.conf\n#\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^kernel.dmesg_restrict\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^kernel.dmesg_restrict\\\\>\" \"${SYSCONFIG_FILE}\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^kernel.dmesg_restrict\\\\>.*/$escaped_formatted_output/gi\" \"${SYSCONFIG_FILE}\"\nelse\n    if [[ -s \"${SYSCONFIG_FILE}\" ]] && [[ -n \"$(tail -c 1 -- \"${SYSCONFIG_FILE}\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"${SYSCONFIG_FILE}\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"${SYSCONFIG_FILE}\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sysctl_kernel_dmesg_restrict","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-213010\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n\n- name: List /etc/sysctl.d/*.conf files\n  ansible.builtin.find:\n    paths:\n    - /etc/sysctl.d/\n    - /run/sysctl.d/\n    - /usr/local/lib/sysctl.d/\n    contains: ^[\\s]*kernel.dmesg_restrict.*$\n    patterns: '*.conf'\n    file_type: any\n  register: find_sysctl_d\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213010\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n\n- name: Comment out any occurrences of kernel.dmesg_restrict from config files\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: ^[\\s]*kernel.dmesg_restrict\n    replace: '#kernel.dmesg_restrict'\n  loop: '{{ find_sysctl_d.files }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213010\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n\n- name: Comment out any occurrences of kernel.dmesg_restrict from /etc/ufw/sysctl.conf\n  ansible.builtin.replace:\n    path: /etc/ufw/sysctl.conf\n    regexp: (^[\\s]*kernel.dmesg_restrict.*$)\n    replace: '# \\1'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213010\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n\n- name: Ensure sysctl kernel.dmesg_restrict is set to 1\n  ansible.posix.sysctl:\n    name: kernel.dmesg_restrict\n    value: '1'\n    sysctl_file: /etc/sysctl.conf\n    state: present\n    reload: true\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213010\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n"}],"vuln_id":"SV-260472","stig_id":"UBTU-22-213010"},"xccdf_org.ssgproject.content_rule_sysctl_kernel_randomize_va_space":{"rule_id":"xccdf_org.ssgproject.content_rule_sysctl_kernel_randomize_va_space","title":"Enable Randomized Layout of Virtual Address Space","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R9"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000450-CTR-001105"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["1.5.1"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)","164.308(a)(4)","164.310(b)","164.310(c)","164.312(a)","164.312(e)"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-002-5 R1.1","CIP-002-5 R1.2","CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 4.1","CIP-004-6 4.2","CIP-004-6 R2.2.3","CIP-004-6 R2.2.4","CIP-004-6 R2.3","CIP-004-6 R4","CIP-005-6 R1","CIP-005-6 R1.1","CIP-005-6 R1.2","CIP-007-3 R3","CIP-007-3 R3.1","CIP-007-3 R5.1","CIP-007-3 R5.1.2","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3","CIP-007-3 R8.4","CIP-009-6 R.1.1","CIP-009-6 R4"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","SC-30","SC-30(2)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000433-GPOS-00193","SRG-OS-000480-GPOS-00227"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-2.2.1"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["3.3","3.3.1","3.3.1.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-213020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260474r958928_rule"]}],"description":"To set the runtime status of the <code>kernel.randomize_va_space</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.randomize_va_space=2</pre>\nTo make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>kernel.randomize_va_space = 2</pre>\n        ","rationale":"Address space layout randomization (ASLR) makes it more difficult for an\nattacker to predict the location of attack code they have introduced into a\nprocess&#x27;s address space during an attempt at exploitation. Additionally,\nASLR makes it more difficult for an attacker to know the location of\nexisting code in order to re-purpose it using return oriented programming\n(ROP) techniques.","platforms":["#system_with_kernel"],"oval_definition_id":"oval:ssg-sysctl_kernel_randomize_va_space:def:1","remediations":[{"remediation_id":"sysctl_kernel_randomize_va_space","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"medium","strategy":"disable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Comment out any occurrences of kernel.randomize_va_space from /etc/sysctl.d/*.conf files\n\nfor f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /etc/ufw/sysctl.conf; do\n\n\n  # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf)\n  if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi\n\n  matching_list=$(grep -P '^(?!#).*[\\s]*kernel.randomize_va_space.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\")\n      # comment out \"kernel.randomize_va_space\" matches to preserve user data\n      sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n  fi\ndone\n\n#\n# Set sysctl config file which to save the desired value\n#\n\nSYSCONFIG_FILE=\"/etc/sysctl.conf\"\n\n\n#\n# Set runtime for kernel.randomize_va_space\n#\nif ! /bin/false ; then\n    /sbin/sysctl -q -n -w kernel.randomize_va_space=\"2\"\nfi\n\n#\n# If kernel.randomize_va_space present in /etc/sysctl.conf, change value to \"2\"\n#\telse, add \"kernel.randomize_va_space = 2\" to /etc/sysctl.conf\n#\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^kernel.randomize_va_space\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"2\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^kernel.randomize_va_space\\\\>\" \"${SYSCONFIG_FILE}\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^kernel.randomize_va_space\\\\>.*/$escaped_formatted_output/gi\" \"${SYSCONFIG_FILE}\"\nelse\n    if [[ -s \"${SYSCONFIG_FILE}\" ]] && [[ -n \"$(tail -c 1 -- \"${SYSCONFIG_FILE}\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"${SYSCONFIG_FILE}\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"${SYSCONFIG_FILE}\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sysctl_kernel_randomize_va_space","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-213020\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3\n  - PCI-DSSv4-3.3.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n\n- name: List /etc/sysctl.d/*.conf files\n  ansible.builtin.find:\n    paths:\n    - /etc/sysctl.d/\n    - /run/sysctl.d/\n    - /usr/local/lib/sysctl.d/\n    contains: ^[\\s]*kernel.randomize_va_space.*$\n    patterns: '*.conf'\n    file_type: any\n  register: find_sysctl_d\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213020\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3\n  - PCI-DSSv4-3.3.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n\n- name: Comment out any occurrences of kernel.randomize_va_space from config files\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: ^[\\s]*kernel.randomize_va_space\n    replace: '#kernel.randomize_va_space'\n  loop: '{{ find_sysctl_d.files }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213020\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3\n  - PCI-DSSv4-3.3.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n\n- name: Comment out any occurrences of kernel.randomize_va_space from /etc/ufw/sysctl.conf\n  ansible.builtin.replace:\n    path: /etc/ufw/sysctl.conf\n    regexp: (^[\\s]*kernel.randomize_va_space.*$)\n    replace: '# \\1'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213020\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3\n  - PCI-DSSv4-3.3.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n\n- name: Ensure sysctl kernel.randomize_va_space is set to 2\n  ansible.posix.sysctl:\n    name: kernel.randomize_va_space\n    value: '2'\n    sysctl_file: /etc/sysctl.conf\n    state: present\n    reload: true\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-213020\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3\n  - PCI-DSSv4-3.3.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n"}],"vuln_id":"SV-260474","stig_id":"UBTU-22-213020"},"xccdf_org.ssgproject.content_rule_bios_enable_execution_restrictions":{"rule_id":"xccdf_org.ssgproject.content_rule_bios_enable_execution_restrictions","title":"Enable NX or XD Support in the BIOS","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000450-CTR-001105"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","3","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["BAI10.01","BAI10.02","BAI10.03","BAI10.05"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.2","A.12.5.1","A.12.6.2","A.14.2.2","A.14.2.3","A.14.2.4"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","SC-39"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.IP-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000433-GPOS-00192"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-213025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260475r958928_rule"]}],"description":"Reboot the system and enter the BIOS or Setup configuration menu.\nNavigate the BIOS configuration menu and make sure that the option is enabled. The setting may be located\nunder a Security section. Look for Execute Disable (XD) on Intel-based systems and No Execute (NX)\non AMD-based systems.","rationale":"Computers with the ability to prevent this type of code execution frequently put an option in the BIOS that will\nallow users to turn the feature on or off at will.","platforms":["#not_aarch64_arch_and_not_ppc64le_arch_and_system_with_kernel"],"oval_definition_id":"oval:ssg-bios_enable_execution_restrictions:def:1","vuln_id":"SV-260475","stig_id":"UBTU-22-213025"},"xccdf_org.ssgproject.content_rule_apt_conf_disallow_unauthenticated":{"rule_id":"xccdf_org.ssgproject.content_rule_apt_conf_disallow_unauthenticated","title":"Disable unauthenticated repositories in APT configuration","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"unknown","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000366-GPOS-00153"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-214010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260476r1015003_rule"]}],"description":"Unauthenticated repositories should not be used for updates.","rationale":"Repositories hosts all packages that will be intsalled on the system during update.\n    If a repository is not authenticated, the associated packages can&#x27;t be trusted,\n    and then should not be installed localy.","oval_definition_id":"oval:ssg-apt_conf_disallow_unauthenticated:def:1","vuln_id":"SV-260476","stig_id":"UBTU-22-214010"},"xccdf_org.ssgproject.content_rule_service_kdump_disabled":{"rule_id":"xccdf_org.ssgproject.content_rule_service_kdump_disabled","title":"Disable KDump Kernel Crash Analyzer (kdump)","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","12","14","15","3","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS01.04","DSS05.02","DSS05.03","DSS05.05","DSS06.06"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)","164.308(a)(4)","164.310(b)","164.310(c)","164.312(a)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.5.1","4.3.3.5.2","4.3.3.5.3","4.3.3.5.4","4.3.3.5.5","4.3.3.5.6","4.3.3.5.7","4.3.3.5.8","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.1","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.11","SR 1.12","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.6","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.2","SR 2.3","SR 2.4","SR 2.5","SR 2.6","SR 2.7","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.1.2","A.12.5.1","A.12.6.2","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.6.2.1","A.6.2.2","A.9.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","CM-7(a)","CM-7(b)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-3","PR.IP-1","PR.PT-3","PR.PT-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000269-GPOS-00103","SRG-OS-000480-GPOS-00227"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-213015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260473r1044782_rule"]}],"description":"The <code>kdump-tools</code> service provides a kernel crash dump analyzer. It uses the <code>kexec</code>\nsystem call to boot a secondary kernel (&quot;capture&quot; kernel) following a system\ncrash, which can load information from the crashed kernel for analysis.\n\nThe <code>kdump-tools</code> service can be disabled with the following command:\n<pre>$ sudo systemctl mask --now kdump-tools.service</pre>\n      ","rationale":"Kernel core dumps may contain the full contents of system memory at the\ntime of the crash. Kernel core dumps consume a considerable amount of disk\nspace and may result in denial of service by exhausting the available space\non the target file system partition. Unless the system is used for kernel\ndevelopment or testing, there is little need to run the kdump service.","platforms":["#system_with_kernel"],"oval_definition_id":"oval:ssg-service_kdump_disabled:def:1","remediations":[{"remediation_id":"service_kdump_disabled","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"disable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\nif [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then\n  \"$SYSTEMCTL_EXEC\" stop 'kdump-tools.service'\nfi\n\"$SYSTEMCTL_EXEC\" disable 'kdump-tools.service'\n\"$SYSTEMCTL_EXEC\" mask 'kdump-tools.service'\n# Disable socket activation if we have a unit file for it\nif \"$SYSTEMCTL_EXEC\" -q list-unit-files kdump-tools.socket; then\n    if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then\n      \"$SYSTEMCTL_EXEC\" stop 'kdump-tools.socket'\n    fi\n    \"$SYSTEMCTL_EXEC\" mask 'kdump-tools.socket'\nfi\n# The service may not be running because it has been started and failed,\n# so let's reset the state so OVAL checks pass.\n# Service should be 'inactive', not 'failed' after reboot though.\n\"$SYSTEMCTL_EXEC\" reset-failed 'kdump-tools.service' || true\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"service_kdump_disabled","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include disable_kdump-tools\n\nclass disable_kdump-tools {\n  service {'kdump-tools':\n    enable => false,\n    ensure => 'stopped',\n  }\n}\n"},{"remediation_id":"service_kdump_disabled","system":"urn:redhat:osbuild:blueprint","fix":"\n[customizations.services]\nmasked = [\"kdump-tools\"]\n"},{"remediation_id":"service_kdump_disabled","system":"urn:xccdf:fix:script:kubernetes","complexity":"low","disruption":"medium","strategy":"disable","fix":"apiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    systemd:\n      units:\n      - name: kdump-tools.service\n        enabled: false\n        mask: true\n      - name: kdump-tools.socket\n        enabled: false\n        mask: true\n"},{"remediation_id":"service_kdump_disabled","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-213015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_kdump_disabled\n\n- name: Disable KDump Kernel Crash Analyzer (kdump) - Disable service kdump-tools\n  block:\n\n  - name: Disable KDump Kernel Crash Analyzer (kdump) - Collect systemd Services Present\n      in the System\n    ansible.builtin.command: systemctl -q list-unit-files --type service\n    register: service_exists\n    changed_when: false\n    failed_when: service_exists.rc not in [0, 1]\n    check_mode: false\n\n  - name: Disable KDump Kernel Crash Analyzer (kdump) - Ensure kdump-tools.service\n      is Masked\n    ansible.builtin.systemd:\n      name: kdump-tools.service\n      state: stopped\n      enabled: false\n      masked: true\n    when: service_exists.stdout_lines is search(\"kdump-tools.service\", multiline=True)\n\n  - name: Unit Socket Exists - kdump-tools.socket\n    ansible.builtin.command: systemctl -q list-unit-files kdump-tools.socket\n    register: socket_file_exists\n    changed_when: false\n    failed_when: socket_file_exists.rc not in [0, 1]\n    check_mode: false\n\n  - name: Disable KDump Kernel Crash Analyzer (kdump) - Disable Socket kdump-tools\n    ansible.builtin.systemd:\n      name: kdump-tools.socket\n      enabled: false\n      state: stopped\n      masked: true\n    when: socket_file_exists.stdout_lines is search(\"kdump-tools.socket\", multiline=True)\n  tags:\n  - DISA-STIG-UBTU-22-213015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_kdump_disabled\n  - special_service_block\n  when: '\"linux-base\" in ansible_facts.packages'\n"}],"vuln_id":"SV-260473","stig_id":"UBTU-22-213015"},"xccdf_org.ssgproject.content_rule_package_telnetd_removed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_telnetd_removed","title":"Uninstall the telnet server","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","12","14","15","3","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS01.04","DSS05.02","DSS05.03","DSS05.05","DSS06.06"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.5.1","4.3.3.5.2","4.3.3.5.3","4.3.3.5.4","4.3.3.5.5","4.3.3.5.6","4.3.3.5.7","4.3.3.5.8","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.1","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.11","SR 1.12","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.6","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.2","SR 2.3","SR 2.4","SR 2.5","SR 2.6","SR 2.7","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.1.2","A.12.5.1","A.12.6.2","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.6.2.1","A.6.2.2","A.9.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","CM-7(a)","CM-7(b)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-3","PR.IP-1","PR.PT-3","PR.PT-4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-215035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260483r987796_rule"]}],"description":"The telnet daemon should be uninstalled.","rationale":"<code>telnet</code> allows clear text communications, and does not protect\nany data transmission between client and server. Any confidential data\ncan be listened and no integrity checking is made.&#x27;","oval_definition_id":"oval:ssg-package_telnetd_removed:def:1","remediations":[{"remediation_id":"package_telnetd_removed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"disable","fix":"\n# CAUTION: This remediation script will remove telnetd\n# from the system, and may remove any packages\n# that depend on telnetd. Execute this\n# remediation AFTER testing on a non-production\n# system!\n\n\nDEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnetd\"\n"},{"remediation_id":"package_telnetd_removed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"disable","fix":"\ninclude remove_telnetd\n\nclass remove_telnetd {\n  package { 'telnetd':\n    ensure => 'purged',\n  }\n}\n"},{"remediation_id":"package_telnetd_removed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"disable","fix":"- name: 'Uninstall the telnet server: Ensure telnetd is removed'\n  ansible.builtin.package:\n    name: telnetd\n    state: absent\n  tags:\n  - DISA-STIG-UBTU-22-215035\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - package_telnetd_removed\n"}],"vuln_id":"SV-260483","stig_id":"UBTU-22-215035"},"xccdf_org.ssgproject.content_rule_package_chrony_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_chrony_installed","title":"The Chrony package is installed","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R71"]},{"name":"ism","href":"https://www.cyber.gov.au/acsc/view-all-content/ism","ref_ids":["0988","1405"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000355-GPOS-00143"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FMT_SMF_EXT.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.4"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.6","10.6.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-215015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260479r991589_rule"]}],"description":"System time should be synchronized between all systems in an environment. This is\ntypically done by establishing an authoritative time server or set of servers and having all\nsystems synchronize their clocks to them.\nThe <code>chrony</code> package can be installed with the following command:\n<pre>\n$ apt-get install chrony</pre>\n      ","rationale":"Time synchronization is important to support time sensitive security mechanisms like\nKerberos and also ensures log files have consistent time records across the enterprise,\nwhich aids in forensic investigations.","oval_definition_id":"oval:ssg-package_chrony_installed:def:1","remediations":[{"remediation_id":"package_chrony_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"chrony\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_chrony_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_chrony\n\nclass install_chrony {\n  package { 'chrony':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_chrony_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"chrony\"\nversion = \"*\"\n"},{"remediation_id":"package_chrony_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-215015\n  - PCI-DSS-Req-10.4\n  - PCI-DSSv4-10.6\n  - PCI-DSSv4-10.6.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_chrony_installed\n\n- name: Ensure chrony is installed\n  ansible.builtin.package:\n    name: chrony\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-215015\n  - PCI-DSS-Req-10.4\n  - PCI-DSSv4-10.6\n  - PCI-DSSv4-10.6.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_chrony_installed\n"}],"vuln_id":"SV-260479","stig_id":"UBTU-22-215015"},"xccdf_org.ssgproject.content_rule_package_ntp_removed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_ntp_removed","title":"Remove the ntp service","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"low","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-215025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260481r991589_rule"]}],"description":"The ntpd service should not be installed.","rationale":"Inaccurate time stamps make it more difficult to correlate events\nand can lead to an inaccurate analysis. Determining the correct\ntime a particular event occurred on a system is critical when\nconducting forensic analysis and investigating system events.\nSources outside the configured acceptable allowance (drift)\nmay be inaccurate.\n","oval_definition_id":"oval:ssg-package_ntp_removed:def:1","remediations":[{"remediation_id":"package_ntp_removed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"disable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# CAUTION: This remediation script will remove ntp\n# from the system, and may remove any packages\n# that depend on ntp. Execute this\n# remediation AFTER testing on a non-production\n# system!\n\n\nDEBIAN_FRONTEND=noninteractive apt-get remove -y \"ntp\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_ntp_removed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"disable","fix":"\ninclude remove_ntp\n\nclass remove_ntp {\n  package { 'ntp':\n    ensure => 'purged',\n  }\n}\n"},{"remediation_id":"package_ntp_removed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-215025\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n  - package_ntp_removed\n\n- name: 'Remove the ntp service: Ensure ntp is removed'\n  ansible.builtin.package:\n    name: ntp\n    state: absent\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-215025\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n  - package_ntp_removed\n"}],"vuln_id":"SV-260481","stig_id":"UBTU-22-215025"},"xccdf_org.ssgproject.content_rule_package_timesyncd_removed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_timesyncd_removed","title":"Remove the systemd_timesyncd Service","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"low","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-215020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260480r991589_rule"]}],"description":"The systemd_timesyncd service should not be installed.","rationale":"Inaccurate time stamps make it more difficult to correlate events\nand can lead to an inaccurate analysis. Determining the correct\ntime a particular event occurred on a system is critical when\nconducting forensic analysis and investigating system events.\nSources outside the configured acceptable allowance (drift)\nmay be inaccurate.\n","oval_definition_id":"oval:ssg-package_timesyncd_removed:def:1","remediations":[{"remediation_id":"package_timesyncd_removed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"disable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# CAUTION: This remediation script will remove systemd-timesyncd\n# from the system, and may remove any packages\n# that depend on systemd-timesyncd. Execute this\n# remediation AFTER testing on a non-production\n# system!\n\n\nDEBIAN_FRONTEND=noninteractive apt-get remove -y \"systemd-timesyncd\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_timesyncd_removed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"disable","fix":"\ninclude remove_systemd-timesyncd\n\nclass remove_systemd-timesyncd {\n  package { 'systemd-timesyncd':\n    ensure => 'purged',\n  }\n}\n"},{"remediation_id":"package_timesyncd_removed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"disable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-215020\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n  - package_timesyncd_removed\n\n- name: 'Remove the systemd_timesyncd Service: Ensure systemd-timesyncd is removed'\n  ansible.builtin.package:\n    name: systemd-timesyncd\n    state: absent\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-215020\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n  - package_timesyncd_removed\n"}],"vuln_id":"SV-260480","stig_id":"UBTU-22-215020"},"xccdf_org.ssgproject.content_rule_chronyd_or_ntpd_set_maxpoll":{"rule_id":"xccdf_org.ssgproject.content_rule_chronyd_or_ntpd_set_maxpoll","title":"Configure Time Service Maxpoll Interval","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","14","15","16","3","5","6"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO11.04","BAI03.05","DSS05.04","DSS05.07","MEA02.01"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(1)","AU-8(1)(b)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000355-GPOS-00143","SRG-OS-000356-GPOS-00144","SRG-OS-000359-GPOS-00146"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-252010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260519r1038944_rule"]}],"description":"The <code>maxpoll</code> should be configured to\n16 in <code>/etc/ntp.conf</code> or\n<code>/etc/chrony/chrony.conf</code> (or <code>/etc/chrony/conf.d/</code>) to continuously poll time servers. To configure\n<code>maxpoll</code> in <code>/etc/ntp.conf</code> or <code>/etc/chrony/chrony.conf</code> (or <code>/etc/chrony/conf.d/</code>)\nadd the following after each <code>server</code>, <code>pool</code> or <code>peer</code> entry:\n<pre>maxpoll 16\n       </pre>\nto <code>server</code> directives. If using chrony, any <code>pool</code> directives\nshould be configured too.","rationale":"Inaccurate time stamps make it more difficult to correlate events and can lead to an inaccurate analysis. Determining the correct time a particular event occurred on a system is critical when conducting forensic analysis and investigating system events. Sources outside the configured acceptable allowance (drift) may be inaccurate.\nSynchronizing internal information system clocks provides uniformity of time stamps for information systems with multiple system clocks and systems connected over a network.\nOrganizations should consider endpoints that may not have regular access to the authoritative time server (e.g., mobile, teleworking, and tactical endpoints).","platforms":["#package_chrony_or_package_ntp"],"oval_definition_id":"oval:ssg-chronyd_or_ntpd_set_maxpoll:def:1","remediations":[{"remediation_id":"chronyd_or_ntpd_set_maxpoll","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ( dpkg-query --show --showformat='${db:Status-Status}' 'chrony' 2>/dev/null | grep -q '^installed$' || dpkg-query --show --showformat='${db:Status-Status}' 'ntp' 2>/dev/null | grep -q '^installed$' ); }; then\n\nvar_time_service_set_maxpoll='16'\n\n\n\n\npof=\"/bin/pidof\"\n\n\nCONFIG_FILES=\"/etc/ntp.conf\"\n$pof ntpd || {\n    CHRONY_D_PATH=/etc/chrony/conf.d/\n    \n    mapfile -t CONFIG_FILES < <(find ${CHRONY_D_PATH}.* -type f -name '*.conf')\n    \n    CONFIG_FILES+=(/etc/chrony/chrony.conf)\n}\n\n# get list of ntp files\n\nfor config_file in \"${CONFIG_FILES[@]}\" ; do\n    # Set maxpoll values to var_time_service_set_maxpoll\n    sed -i \"s/^\\(\\(server\\|pool\\|peer\\).*maxpoll\\) [0-9,-][0-9]*\\(.*\\)$/\\1 $var_time_service_set_maxpoll \\3/\" \"$config_file\"\ndone\n\nfor config_file in \"${CONFIG_FILES[@]}\" ; do\n    # Add maxpoll to server, pool or peer entries without maxpoll\n    grep \"^\\(server\\|pool\\|peer\\)\" \"$config_file\" | grep -v maxpoll | while read -r line ; do\n        sed -i \"s/$line/& maxpoll $var_time_service_set_maxpoll/\" \"$config_file\"\n    done\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"chronyd_or_ntpd_set_maxpoll","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_time_service_set_maxpoll # promote to variable\n  set_fact:\n    var_time_service_set_maxpoll: !!str 16\n  tags:\n    - always\n\n- name: Configure Time Service Maxpoll Interval - Check That /etc/ntp.conf Exist\n  ansible.builtin.stat:\n    path: /etc/ntp.conf\n  register: ntp_conf_exist_result\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Update the maxpoll Values in /etc/ntp.conf\n  ansible.builtin.replace:\n    path: /etc/ntp.conf\n    regexp: ^(server.*maxpoll)[ ]+[0-9]+(.*)$\n    replace: \\1 {{ var_time_service_set_maxpoll }}\\2\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - ntp_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Set the maxpoll Values in /etc/ntp.conf\n  ansible.builtin.replace:\n    path: /etc/ntp.conf\n    regexp: (^server\\s+((?!maxpoll).)*)$\n    replace: \\1 maxpoll {{ var_time_service_set_maxpoll }}\\n\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - ntp_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Check That /etc/chrony/chrony.conf\n    Exist\n  ansible.builtin.stat:\n    path: /etc/chrony/chrony.conf\n  register: chrony_conf_exist_result\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Update the maxpoll Values in /etc/chrony/chrony.conf\n  ansible.builtin.replace:\n    path: /etc/chrony/chrony.conf\n    regexp: ^((?:server|pool|peer).*maxpoll)[ ]+[0-9]+(.*)$\n    replace: \\1 {{ var_time_service_set_maxpoll }}\\2\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Set the maxpoll Values in /etc/chrony/chrony.conf\n  ansible.builtin.replace:\n    path: /etc/chrony/chrony.conf\n    regexp: (^(?:server|pool|peer)\\s+((?!maxpoll).)*)$\n    replace: \\1 maxpoll {{ var_time_service_set_maxpoll }}\\n\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Get Conf Files from /etc/chrony/conf.d/\n  ansible.builtin.find:\n    path: /etc/chrony/conf.d/\n    patterns: '*.conf'\n    file_type: file\n  register: chrony_d_conf_files\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Update the maxpoll Values in /etc/chrony/conf.d/\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: ^((?:server|pool|peer).*maxpoll)[ ]+[0-9,-]+(.*)$\n    replace: \\1 {{ var_time_service_set_maxpoll }}\\2\n  loop: '{{ chrony_d_conf_files.files }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_d_conf_files.matched\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Set the maxpoll Values in /etc/chrony/conf.d/\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: (^(?:server|pool|peer)\\s+((?!maxpoll).)*)$\n    replace: \\1 maxpoll {{ var_time_service_set_maxpoll }}\\n\n  loop: '{{ chrony_d_conf_files.files }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_d_conf_files.matched\n  tags:\n  - DISA-STIG-UBTU-22-252010\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260519","stig_id":"UBTU-22-252010"},"xccdf_org.ssgproject.content_rule_chronyd_sync_clock":{"rule_id":"xccdf_org.ssgproject.content_rule_chronyd_sync_clock","title":"Synchronize internal information system clocks","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000356-GPOS-00144"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-252015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260520r1044776_rule"]}],"description":"Synchronizing internal information system clocks provides uniformity\nof time stamps for information systems with multiple system clocks and\nsystems connected over a network.","rationale":"Inaccurate time stamps make it more difficult to correlate events and\ncan lead to an inaccurate analysis. Determining the correct time a\nparticular event occurred on a system is critical when conducting\nforensic analysis and investigating system events.","platforms":["#package_chrony"],"oval_definition_id":"oval:ssg-chronyd_sync_clock:def:1","remediations":[{"remediation_id":"chronyd_sync_clock","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { dpkg-query --show --showformat='${db:Status-Status}' 'chrony' 2>/dev/null | grep -q '^installed$'; }; then\n\nif [ -e \"/etc/chrony/chrony.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*makestep /Id\" \"/etc/chrony/chrony.conf\"\nelse\n    touch \"/etc/chrony/chrony.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/chrony/chrony.conf\"\n\ncp \"/etc/chrony/chrony.conf\" \"/etc/chrony/chrony.conf.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"makestep 1 -1\" >> \"/etc/chrony/chrony.conf\"\n# Clean up after ourselves.\nrm \"/etc/chrony/chrony.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"chronyd_sync_clock","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-252015\n  - chronyd_sync_clock\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Synchronize internal information system clocks\n  block:\n\n  - name: Check for duplicate values\n    ansible.builtin.lineinfile:\n      path: /etc/chrony/chrony.conf\n      create: true\n      regexp: '(?i)^\\s*makestep '\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: dupes\n\n  - name: Deduplicate values from /etc/chrony/chrony.conf\n    ansible.builtin.lineinfile:\n      path: /etc/chrony/chrony.conf\n      create: true\n      regexp: '(?i)^\\s*makestep '\n      state: absent\n    when: dupes.found is defined and dupes.found > 1\n\n  - name: Insert correct line to /etc/chrony/chrony.conf\n    ansible.builtin.lineinfile:\n      path: /etc/chrony/chrony.conf\n      create: true\n      regexp: '(?i)^\\s*makestep '\n      line: makestep 1 -1\n      state: present\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"chrony\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-252015\n  - chronyd_sync_clock\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260520","stig_id":"UBTU-22-252015"},"xccdf_org.ssgproject.content_rule_package_rsh-server_removed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_rsh-server_removed","title":"Uninstall rsh-server Package","result":"pass","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R62"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","12","14","15","3","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS01.04","DSS05.02","DSS05.03","DSS05.05","DSS06.06"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(4)(i)","164.308(b)(1)","164.308(b)(3)","164.310(b)","164.312(e)(1)","164.312(e)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.5.1","4.3.3.5.2","4.3.3.5.3","4.3.3.5.4","4.3.3.5.5","4.3.3.5.6","4.3.3.5.7","4.3.3.5.8","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.1","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.11","SR 1.12","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.6","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.2","SR 2.3","SR 2.4","SR 2.5","SR 2.6","SR 2.7","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.1.2","A.12.5.1","A.12.6.2","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.6.2.1","A.6.2.2","A.9.1.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","CM-7(a)","CM-7(b)","IA-5(1)(c)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-3","PR.IP-1","PR.PT-3","PR.PT-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000095-GPOS-00049"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-215030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260482r958478_rule"]}],"description":"The <code>rsh-server</code> package can be removed with the following command:\n<pre>\n$ apt-get remove rsh-server</pre>\n       ","rationale":"The <code>rsh-server</code> service provides unencrypted remote access service which does not\nprovide for the confidentiality and integrity of user passwords or the remote session and has very weak\nauthentication. If a privileged user were to login using this service, the privileged user password\ncould be compromised. The <code>rsh-server</code> package provides several obsolete and insecure\nnetwork services. Removing it decreases the risk of those services&#x27; accidental (or intentional)\nactivation.","oval_definition_id":"oval:ssg-package_rsh-server_removed:def:1","remediations":[{"remediation_id":"package_rsh-server_removed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"disable","fix":"\n# CAUTION: This remediation script will remove rsh-server\n# from the system, and may remove any packages\n# that depend on rsh-server. Execute this\n# remediation AFTER testing on a non-production\n# system!\n\n\nDEBIAN_FRONTEND=noninteractive apt-get remove -y \"rsh-server\"\n"},{"remediation_id":"package_rsh-server_removed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"disable","fix":"\ninclude remove_rsh-server\n\nclass remove_rsh-server {\n  package { 'rsh-server':\n    ensure => 'purged',\n  }\n}\n"},{"remediation_id":"package_rsh-server_removed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"disable","fix":"- name: 'Uninstall rsh-server Package: Ensure rsh-server is removed'\n  ansible.builtin.package:\n    name: rsh-server\n    state: absent\n  tags:\n  - DISA-STIG-UBTU-22-215030\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-IA-5(1)(c)\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.4\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - package_rsh-server_removed\n"}],"vuln_id":"SV-260482","stig_id":"UBTU-22-215030"},"xccdf_org.ssgproject.content_rule_package_openssh-server_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_openssh-server_installed","title":"Install the OpenSSH Server Package","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["13","14"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.02","DSS05.04","DSS05.07","DSS06.02","DSS06.06"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.1","SR 3.8","SR 4.1","SR 4.2","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.DS-2","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000423-GPOS-00187","SRG-OS-000424-GPOS-00188","SRG-OS-000425-GPOS-00189","SRG-OS-000426-GPOS-00190"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FCS_SSHS_EXT.1","FCS_SSH_EXT.1","FIA_UAU.5","FTP_ITC_EXT.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260523r958908_rule"]}],"description":"The <code>openssh-server</code> package should be installed.\nThe <code>openssh-server</code> package can be installed with the following command:\n<pre>\n$ apt-get install openssh-server</pre>\n      ","rationale":"Without protection of the transmitted information, confidentiality, and\nintegrity may be compromised because unprotected communications can be\nintercepted and either read or altered.","oval_definition_id":"oval:ssg-package_openssh-server_installed:def:1","remediations":[{"remediation_id":"package_openssh-server_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"openssh-server\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_openssh-server_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_openssh-server\n\nclass install_openssh-server {\n  package { 'openssh-server':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_openssh-server_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"openssh-server\"\nversion = \"*\"\n"},{"remediation_id":"package_openssh-server_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255010\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_openssh-server_installed\n\n- name: Ensure openssh-server is installed\n  ansible.builtin.package:\n    name: openssh-server\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255010\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_openssh-server_installed\n"}],"vuln_id":"SV-260523","stig_id":"UBTU-22-255010"},"xccdf_org.ssgproject.content_rule_service_sshd_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_service_sshd_enabled","title":"Enable the OpenSSH Service","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["13","14"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","DSS05.02","DSS05.04","DSS05.07","DSS06.02","DSS06.06"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.13","3.13.8","3.5.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 3.1","SR 3.8","SR 4.1","SR 4.2","SR 5.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","SC-8","SC-8(1)","SC-8(2)","SC-8(3)","SC-8(4)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.DS-2","PR.DS-5"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000423-GPOS-00187","SRG-OS-000424-GPOS-00188","SRG-OS-000425-GPOS-00189","SRG-OS-000426-GPOS-00190"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260524r958908_rule"]}],"description":"The SSH server service, sshd, is commonly needed.\n\nThe <code>sshd</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable sshd.service</pre>\n      ","rationale":"Without protection of the transmitted information, confidentiality, and\nintegrity may be compromised because unprotected communications can be\nintercepted and either read or altered.\n<br>\n       <br>\nThis checklist item applies to both internal and external networks and all types\nof information system components from which information can be transmitted (e.g., servers,\nmobile devices, notebook computers, printers, copiers, scanners, etc). Communication paths\noutside the physical protection of a controlled boundary are exposed to the possibility\nof interception and modification.","oval_definition_id":"oval:ssg-service_sshd_enabled:def:1","remediations":[{"remediation_id":"service_sshd_enabled","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'ssh.service'\nif [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then\n  \"$SYSTEMCTL_EXEC\" start 'ssh.service'\nfi\n\"$SYSTEMCTL_EXEC\" enable 'ssh.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"service_sshd_enabled","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include enable_ssh\n\nclass enable_ssh {\n  service {'ssh':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"},{"remediation_id":"service_sshd_enabled","system":"urn:redhat:osbuild:blueprint","fix":"\n[customizations.services]\nenabled = [\"ssh\"]\n"},{"remediation_id":"service_sshd_enabled","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255015\n  - NIST-800-171-3.1.13\n  - NIST-800-171-3.13.8\n  - NIST-800-171-3.5.4\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-8\n  - NIST-800-53-SC-8(1)\n  - NIST-800-53-SC-8(2)\n  - NIST-800-53-SC-8(3)\n  - NIST-800-53-SC-8(4)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_sshd_enabled\n\n- name: Enable the OpenSSH Service - Enable service ssh\n  block:\n\n  - name: Gather the package facts\n    ansible.builtin.package_facts:\n      manager: auto\n\n  - name: Enable the OpenSSH Service - Enable Service ssh\n    ansible.builtin.systemd:\n      name: ssh\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"openssh-server\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255015\n  - NIST-800-171-3.1.13\n  - NIST-800-171-3.13.8\n  - NIST-800-171-3.5.4\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-8\n  - NIST-800-53-SC-8(1)\n  - NIST-800-53-SC-8(2)\n  - NIST-800-53-SC-8(3)\n  - NIST-800-53-SC-8(4)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_sshd_enabled\n  - special_service_block\n  when: '\"linux-base\" in ansible_facts.packages'\n"}],"vuln_id":"SV-260524","stig_id":"UBTU-22-255015"},"xccdf_org.ssgproject.content_rule_sshd_set_keepalive":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_set_keepalive","title":"Set SSH Client Alive Count Max","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.2.22"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","18","3","5","7","8"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.6"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","BAI03.01","BAI03.02","BAI03.03","DSS01.03","DSS03.05","DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.11"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(4)(i)","164.308(b)(1)","164.308(b)(3)","164.310(b)","164.312(e)(1)","164.312(e)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.3","A.14.1.1","A.14.2.1","A.14.2.5","A.18.1.4","A.6.1.2","A.6.1.5","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.3","CIP-007-3 R5.1","CIP-007-3 R5.2","CIP-007-3 R5.3.1","CIP-007-3 R5.3.2","CIP-007-3 R5.3.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-12","AC-17(a)","AC-2(5)","CM-6(a)","SC-10"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","PR.AC-1","PR.AC-4","PR.AC-6","PR.AC-7","PR.IP-2"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000163-GPOS-00072","SRG-OS-000279-GPOS-00109"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.8"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.2","8.2.8"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260527r986275_rule"]}],"description":"The SSH server sends at most <code>ClientAliveCountMax</code> messages\nduring a SSH session and waits for a response from the SSH client.\nThe option <code>ClientAliveInterval</code> configures timeout after\neach <code>ClientAliveCountMax</code> message. If the SSH server does not\nreceive a response from the client, then the connection is considered unresponsive\nand terminated.\nFor SSH earlier than v8.2, a <code>ClientAliveCountMax</code> value of <code>0</code>\ncauses a timeout precisely when the <code>ClientAliveInterval</code> is set.\nStarting with v8.2, a value of <code>0</code> disables the timeout functionality\ncompletely. If the option is set to a number greater than <code>0</code>, then\nthe session will be disconnected after\n<code>ClientAliveInterval * ClientAliveCountMax</code> seconds without receiving\na keep alive message.","rationale":"This ensures a user login will be terminated as soon as the <code>ClientAliveInterval</code>\nis reached.","oval_definition_id":"oval:ssg-sshd_set_keepalive:def:1","remediations":[{"remediation_id":"sshd_set_keepalive","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nvar_sshd_set_keepalive='1'\n\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"ClientAliveCountMax $var_sshd_set_keepalive\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_set_keepalive","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255030\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSS-Req-8.1.8\n  - PCI-DSSv4-8.2\n  - PCI-DSSv4-8.2.8\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_set_keepalive\n- name: XCCDF Value var_sshd_set_keepalive # promote to variable\n  set_fact:\n    var_sshd_set_keepalive: !!str 1\n  tags:\n    - always\n\n- name: Set SSH Client Alive Count Max\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"ClientAliveCountMax\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter ClientAliveCountMax is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"ClientAliveCountMax\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"ClientAliveCountMax\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"ClientAliveCountMax\"| regex_escape }}\\s+\n      line: ClientAliveCountMax {{ var_sshd_set_keepalive }}\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255030\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSS-Req-8.1.8\n  - PCI-DSSv4-8.2\n  - PCI-DSSv4-8.2.8\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_set_keepalive\n\n- name: Set SSH Client Alive Count Max - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255030\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSS-Req-8.1.8\n  - PCI-DSSv4-8.2\n  - PCI-DSSv4-8.2.8\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_set_keepalive\n"}],"vuln_id":"SV-260527","stig_id":"UBTU-22-255030"},"xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout","title":"Set SSH Client Alive Interval","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.2.22"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","18","3","5","7","8"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.6"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO13.01","BAI03.01","BAI03.02","BAI03.03","DSS01.03","DSS03.05","DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.11"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.3","A.14.1.1","A.14.2.1","A.14.2.5","A.18.1.4","A.6.1.2","A.6.1.5","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.3","CIP-007-3 R5.1","CIP-007-3 R5.2","CIP-007-3 R5.3.1","CIP-007-3 R5.3.2","CIP-007-3 R5.3.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-12","AC-17(a)","AC-17(a)","AC-2(5)","CM-6(a)","CM-6(a)","SC-10"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","PR.AC-1","PR.AC-4","PR.AC-6","PR.AC-7","PR.IP-2"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000126-GPOS-00066","SRG-OS-000163-GPOS-00072","SRG-OS-000279-GPOS-00109","SRG-OS-000395-GPOS-00175"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-8.1.8"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["8.2","8.2.8"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260528r970703_rule"]}],"description":"SSH allows administrators to set a network responsiveness timeout interval.\nAfter this interval has passed, the unresponsive client will be automatically logged out.\n<br>\n        <br>\nTo set this timeout interval, edit the following line in <code>/etc/ssh/sshd_config</code> as\nfollows:\n<pre>ClientAliveInterval <b>600</b>\n        </pre>\n        <br>\n        <br>\nThe timeout <b>interval</b> is given in seconds. For example, have a timeout\nof 10 minutes, set <b>interval</b> to 600.\n<br>\n        <br>\nIf a shorter timeout has already been set for the login shell, that value will\npreempt any SSH setting made in <code>/etc/ssh/sshd_config</code>. Keep in mind that\nsome processes may stop SSH from correctly detecting that the user is idle.","rationale":"Terminating an idle ssh session within a short time period reduces the window of\nopportunity for unauthorized personnel to take control of a management session\nenabled on the console or console port that has been let unattended.","warnings":[{"text":"SSH disconnecting unresponsive clients will not have desired effect without also\nconfiguring ClientAliveCountMax in the SSH service configuration.","category":"dependency"},{"text":"Following conditions may prevent the SSH session to time out:\n<ul><li>Remote processes on the remote machine generates output. As the output has to be transferred over the network to the client, the timeout is reset every time such transfer happens.</li><li>Any <code>scp</code> or <code>sftp</code> activity by the same user to the host resets the timeout.</li></ul>\n       ","category":"general"}],"oval_definition_id":"oval:ssg-sshd_set_idle_timeout:def:1","remediations":[{"remediation_id":"sshd_set_idle_timeout","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nsshd_idle_timeout_value='600'\n\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"ClientAliveInterval $sshd_idle_timeout_value\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_set_idle_timeout","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255035\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSS-Req-8.1.8\n  - PCI-DSSv4-8.2\n  - PCI-DSSv4-8.2.8\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_set_idle_timeout\n- name: XCCDF Value sshd_idle_timeout_value # promote to variable\n  set_fact:\n    sshd_idle_timeout_value: !!str 600\n  tags:\n    - always\n\n- name: Set SSH Client Alive Interval\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"ClientAliveInterval\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter ClientAliveInterval is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"ClientAliveInterval\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"ClientAliveInterval\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"ClientAliveInterval\"| regex_escape }}\\s+\n      line: ClientAliveInterval {{ sshd_idle_timeout_value }}\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255035\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSS-Req-8.1.8\n  - PCI-DSSv4-8.2\n  - PCI-DSSv4-8.2.8\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_set_idle_timeout\n\n- name: Set SSH Client Alive Interval - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255035\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSS-Req-8.1.8\n  - PCI-DSSv4-8.2\n  - PCI-DSSv4-8.2.8\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_set_idle_timeout\n"}],"vuln_id":"SV-260528","stig_id":"UBTU-22-255035"},"xccdf_org.ssgproject.content_rule_sshd_disable_empty_passwords":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_disable_empty_passwords","title":"Disable SSH Access via Empty Passwords","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"high","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.2.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","12","13","14","15","16","18","3","5","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.6"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","BAI10.01","BAI10.02","BAI10.03","BAI10.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","DSS06.02","DSS06.03","DSS06.06"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.1","3.1.5"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(4)(i)","164.308(b)(1)","164.308(b)(3)","164.310(b)","164.312(e)(1)","164.312(e)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.5.3","4.3.3.5.4","4.3.3.5.5","4.3.3.5.6","4.3.3.5.7","4.3.3.5.8","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.1","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.11","SR 1.12","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.6","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.2","SR 2.3","SR 2.4","SR 2.5","SR 2.6","SR 2.7","SR 5.2","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.12.1.2","A.12.5.1","A.12.6.2","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.14.2.2","A.14.2.3","A.14.2.4","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.1","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-17(a)","CM-6(a)","CM-7(a)","CM-7(b)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-4","PR.AC-6","PR.DS-5","PR.IP-1","PR.PT-3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000106-GPOS-00053","SRG-OS-000480-GPOS-00227","SRG-OS-000480-GPOS-00229"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FIA_UAU.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-2.2.4"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260526r991591_rule"]}],"description":"Disallow SSH login with empty passwords.\nThe default SSH configuration disables logins with empty passwords. The appropriate\nconfiguration is used if no value is set for <code>PermitEmptyPasswords</code>.\n<br>\nTo explicitly disallow SSH login from accounts with empty passwords,\nadd or correct the following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<br>\n        <pre>PermitEmptyPasswords no</pre>\nAny accounts with empty passwords should be disabled immediately, and PAM configuration\nshould prevent users from being able to assign themselves empty passwords.","rationale":"Configuring this setting for the SSH daemon provides additional assurance\nthat remote login via SSH will require a password, even in the event of\nmisconfiguration elsewhere.","oval_definition_id":"oval:ssg-sshd_disable_empty_passwords:def:1","remediations":[{"remediation_id":"sshd_disable_empty_passwords","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\nchmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"PermitEmptyPasswords no\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_disable_empty_passwords","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255025\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_empty_passwords\n\n- name: Disable SSH Access via Empty Passwords\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter PermitEmptyPasswords is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n      line: PermitEmptyPasswords no\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255025\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_empty_passwords\n\n- name: Disable SSH Access via Empty Passwords - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255025\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_empty_passwords\n"}],"vuln_id":"SV-260526","stig_id":"UBTU-22-255025"},"xccdf_org.ssgproject.content_rule_sshd_disable_x11_forwarding":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_disable_x11_forwarding","title":"Disable X11 Forwarding","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.2.12"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(b)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00227"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260529r991589_rule"]}],"description":"The X11Forwarding parameter provides the ability to tunnel X11 traffic\nthrough the connection to enable remote graphic connections.\nSSH has the capability to encrypt remote X11 connections when SSH&#x27;s\n<code>X11Forwarding</code> option is enabled.\n<br>\nThe default SSH configuration disables X11Forwarding. The appropriate\nconfiguration is used if no value is set for <code>X11Forwarding</code>.\n<br>\nTo explicitly disable X11 Forwarding, add or correct the following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>X11Forwarding no</pre>\n       ","rationale":"Disable X11 forwarding unless there is an operational requirement to use X11\napplications directly. There is a small risk that the remote X11 servers of\nusers who are logged in via SSH with X11 forwarding could be compromised by\nother users on the X11 server. Note that even if X11 forwarding is disabled,\nusers can always install their own forwarders.","oval_definition_id":"oval:ssg-sshd_disable_x11_forwarding:def:1","remediations":[{"remediation_id":"sshd_disable_x11_forwarding","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\nchmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"X11Forwarding no\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_disable_x11_forwarding","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255040\n  - NIST-800-53-CM-6(b)\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_x11_forwarding\n\n- name: Disable X11 Forwarding\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter X11Forwarding is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n      line: X11Forwarding no\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255040\n  - NIST-800-53-CM-6(b)\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_x11_forwarding\n\n- name: Disable X11 Forwarding - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255040\n  - NIST-800-53-CM-6(b)\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_x11_forwarding\n"}],"vuln_id":"SV-260529","stig_id":"UBTU-22-255040"},"xccdf_org.ssgproject.content_rule_sshd_do_not_permit_user_env":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_do_not_permit_user_env","title":"Do Not Allow SSH Environment Options","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.2.10"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["11","3","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.6"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["BAI10.01","BAI10.02","BAI10.03","BAI10.05"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.12"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(4)(i)","164.308(b)(1)","164.308(b)(3)","164.310(b)","164.312(e)(1)","164.312(e)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.4.3.2","4.3.4.3.3"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.2","A.12.5.1","A.12.6.2","A.14.2.2","A.14.2.3","A.14.2.4"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-17(a)","CM-6(a)","CM-7(a)","CM-7(b)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.IP-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00229"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-2.2.4"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260526r991591_rule"]}],"description":"Ensure that users are not able to override environment variables of the SSH daemon.\n<br>\nThe default SSH configuration disables environment processing. The appropriate\nconfiguration is used if no value is set for <code>PermitUserEnvironment</code>.\n<br>\nTo explicitly disable Environment options, add or correct the following\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>PermitUserEnvironment no</pre>\n       ","rationale":"SSH environment options potentially allow users to bypass\naccess restriction in some configurations.","oval_definition_id":"oval:ssg-sshd_do_not_permit_user_env:def:1","remediations":[{"remediation_id":"sshd_do_not_permit_user_env","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\nchmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"PermitUserEnvironment no\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_do_not_permit_user_env","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255025\n  - NIST-800-171-3.1.12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_do_not_permit_user_env\n\n- name: Do Not Allow SSH Environment Options\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter PermitUserEnvironment is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n      line: PermitUserEnvironment no\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255025\n  - NIST-800-171-3.1.12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_do_not_permit_user_env\n\n- name: Do Not Allow SSH Environment Options - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255025\n  - NIST-800-171-3.1.12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_do_not_permit_user_env\n"}],"vuln_id":"SV-260526","stig_id":"UBTU-22-255025"},"xccdf_org.ssgproject.content_rule_sshd_enable_pam":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_enable_pam","title":"Enable PAM","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.2.6"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000125-GPOS-00065"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["2.2","2.2.6"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255065"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260534r958510_rule"]}],"description":"UsePAM Enables the Pluggable Authentication Module interface. If set to yes this will\nenable PAM authentication using ChallengeResponseAuthentication and\nPasswordAuthentication in addition to PAM account and session module processing for all\nauthentication types.\n\nTo enable PAM authentication, add or correct the following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>UsePAM yes</pre>\n       ","rationale":"When UsePAM is set to yes, PAM runs through account and session types properly. This is\nimportant if you want to restrict access to services based off of IP, time or other factors of\nthe account. Additionally, you can make sure users inherit certain environment variables\non login or disallow access to the server.","oval_definition_id":"oval:ssg-sshd_enable_pam:def:1","remediations":[{"remediation_id":"sshd_enable_pam","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*UsePAM\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*UsePAM\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*UsePAM\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"UsePAM yes\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_enable_pam","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255065\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pam\n\n- name: Enable PAM\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter UsePAM is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n      line: UsePAM yes\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255065\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pam\n\n- name: Enable PAM - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255065\n  - PCI-DSSv4-2.2\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pam\n"}],"vuln_id":"SV-260534","stig_id":"UBTU-22-255065"},"xccdf_org.ssgproject.content_rule_sshd_enable_pubkey_auth":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_enable_pubkey_auth","title":"Enable Public Key Authentication","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000105-GPOS-00052","SRG-OS-000106-GPOS-00053","SRG-OS-000107-GPOS-00054","SRG-OS-000108-GPOS-00055"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-612020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260575r1044770_rule"]}],"description":"Enable SSH login with public keys.\n<br>\nThe default SSH configuration enables authentication based on public keys. The appropriate\nconfiguration is used if no value is set for <code>PubkeyAuthentication</code>.\n<br>\nTo explicitly enable Public Key Authentication, add or correct the following\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>PubkeyAuthentication yes</pre>\n       ","rationale":"Without the use of multifactor authentication, the ease of access to\nprivileged functions is greatly increased. Multifactor authentication\nrequires using two or more factors to achieve authentication.\nA privileged account is defined as an information system account with\nauthorizations of a privileged user. \nSmart cards or hardware tokens paired with digital certificates are\ncommon examples of multifactor implementations.","oval_definition_id":"oval:ssg-sshd_enable_pubkey_auth:def:1","remediations":[{"remediation_id":"sshd_enable_pubkey_auth","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"PubkeyAuthentication yes\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_enable_pubkey_auth","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-612020\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pubkey_auth\n\n- name: Enable Public Key Authentication\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter PubkeyAuthentication is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n      line: PubkeyAuthentication yes\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-612020\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pubkey_auth\n\n- name: Enable Public Key Authentication - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-612020\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pubkey_auth\n"}],"vuln_id":"SV-260575","stig_id":"UBTU-22-612020"},"xccdf_org.ssgproject.content_rule_sshd_enable_warning_banner_net":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_enable_warning_banner_net","title":"Enable SSH Warning Banner","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["5.2.17"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.5.6"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.10","DSS06.10"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.9"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(4)(i)","164.308(b)(1)","164.308(b)(3)","164.310(b)","164.312(e)(1)","164.312(e)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.5","SR 1.7","SR 1.8","SR 1.9"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.9.2.1","A.9.2.4","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-17(a)","AC-8(a)","AC-8(c)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000023-GPOS-00006","SRG-OS-000228-GPOS-00088"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260525r958390_rule"]}],"description":"To enable the warning banner and ensure it is consistent\nacross the system, add or correct the following line in\n\n<code>/etc/ssh/sshd_config</code>:\n\n<pre>Banner /etc/issue.net</pre>\nAnother section contains information on how to create an\nappropriate system-wide warning banner.","rationale":"The warning message reinforces policy awareness during the logon process and\nfacilitates possible legal action against attackers. Alternatively, systems\nwhose ownership should not be obvious should ensure usage of a banner that does\nnot provide easy attribution.","oval_definition_id":"oval:ssg-sshd_enable_warning_banner_net:def:1","remediations":[{"remediation_id":"sshd_enable_warning_banner_net","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"Banner /etc/issue.net\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_enable_warning_banner_net","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255020\n  - NIST-800-171-3.1.9\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-8(a)\n  - NIST-800-53-AC-8(c)\n  - NIST-800-53-CM-6(a)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_warning_banner_net\n\n- name: Enable SSH Warning Banner\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter Banner is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n      line: Banner /etc/issue.net\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255020\n  - NIST-800-171-3.1.9\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-8(a)\n  - NIST-800-53-AC-8(c)\n  - NIST-800-53-CM-6(a)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_warning_banner_net\n\n- name: Enable SSH Warning Banner - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-22-255020\n  - NIST-800-171-3.1.9\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-8(a)\n  - NIST-800-53-AC-8(c)\n  - NIST-800-53-CM-6(a)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_warning_banner_net\n"}],"vuln_id":"SV-260525","stig_id":"UBTU-22-255020"},"xccdf_org.ssgproject.content_rule_sshd_use_approved_ciphers_ordered_stig":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_use_approved_ciphers_ordered_stig","title":"Use Only FIPS 140-2 Validated Ciphers","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000033-GPOS-00014","SRG-OS-000120-GPOS-00061","SRG-OS-000125-GPOS-00065","SRG-OS-000250-GPOS-00093","SRG-OS-000393-GPOS-00173","SRG-OS-000394-GPOS-00174"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255050"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260531r958408_rule"]}],"description":"Limit the ciphers to those algorithms which are FIPS-approved.\nThe following line in <code>/etc/ssh/sshd_config</code>\ndemonstrates use of FIPS-approved ciphers:\n<pre>Ciphers aes256-ctr,aes256-gcm@openssh.com,aes192-ctr,aes128-ctr,aes128-gcm@openssh.com</pre>\nIf this line does not contain these ciphers in exact order,\nis commented out, or is missing, this is a finding.","rationale":"Unapproved mechanisms that are used for authentication to the cryptographic module are not verified and therefore\ncannot be relied upon to provide confidentiality or integrity, and system data may be compromised.\n<br>\nOperating systems utilizing encryption are required to use FIPS-compliant mechanisms for authenticating to\ncryptographic modules.\n<br>\nFIPS 140-2 is the current standard for validating that mechanisms used to access cryptographic modules\nutilize authentication that meets industry and government requirements. For government systems, this allows\nSecurity Levels 1, 2, 3, or 4 for use on Ubuntu 22.04.","warnings":[{"text":"The system needs to be rebooted for these changes to take effect.","category":"general"},{"text":"System Crypto Modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this, the system has to have cryptographic software provided by\na vendor that has undergone this certification. This means providing\ndocumentation, test results, design information, and independent third\nparty review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.","category":"regulatory"}],"oval_definition_id":"oval:ssg-sshd_use_approved_ciphers_ordered_stig:def:1","remediations":[{"remediation_id":"sshd_use_approved_ciphers_ordered_stig","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nsshd_approved_ciphers=\"aes256-ctr,aes256-gcm@openssh.com,aes192-ctr,aes128-ctr,aes128-gcm@openssh.com\"\n\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*Ciphers\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*Ciphers\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*Ciphers\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"Ciphers $sshd_approved_ciphers\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_use_approved_ciphers_ordered_stig","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255050\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_ciphers_ordered_stig\n- name: XCCDF Value sshd_approved_ciphers # promote to variable\n  set_fact:\n    sshd_approved_ciphers: !!str aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se\n  tags:\n    - always\n\n- name: Use Only FIPS 140-2 Validated Ciphers\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter Ciphers is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n      line: Ciphers {{ sshd_approved_ciphers }}\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255050\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_ciphers_ordered_stig\n\n- name: Use Only FIPS 140-2 Validated Ciphers - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255050\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_ciphers_ordered_stig\n"}],"vuln_id":"SV-260531","stig_id":"UBTU-22-255050"},"xccdf_org.ssgproject.content_rule_sshd_use_approved_kex_ordered_stig":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_use_approved_kex_ordered_stig","title":"Use Only FIPS 140-2 Validated Key Exchange Algorithms","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-17(2)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000250-GPOS-00093"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255060"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260533r958408_rule"]}],"description":"Limit the key exchange algorithms to those  which are FIPS-approved.\nAdd or modify the following line in <code>/etc/ssh/sshd_config</code>\n        <pre>KexAlgorithms ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256</pre>\nThis rule ensures that only the key exchange algorithms mentioned\nabove (or their subset) are configured for use, keeping the given\norder of algorithms.","rationale":"FIPS-approved key exchange algorithms are required to be used.\nThe system will attempt to use the first algorithm presented by the client that matches\nthe server list. Listing the values &quot;strongest to weakest&quot; is a method to ensure the use\nof the strongest algorithm available to secure the SSH connection.","warnings":[{"text":"The system needs to be rebooted for these changes to take effect.","category":"general"},{"text":"System crypto modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this requirements, the system has to have cryptographic software\nprovided by a vendor that has undergone this certification. This means\nproviding documentation, test results, design information, and independent\nthird party review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.","category":"regulatory"}],"oval_definition_id":"oval:ssg-sshd_use_approved_kex_ordered_stig:def:1","remediations":[{"remediation_id":"sshd_use_approved_kex_ordered_stig","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nKEX_ALGOS=\"ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256\"\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*KexAlgorithms\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*KexAlgorithms\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*KexAlgorithms\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"KexAlgorithms $KEX_ALGOS\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_use_approved_kex_ordered_stig","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255060\n  - NIST-800-53-AC-17(2)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_kex_ordered_stig\n\n- name: Configure sshd to use FIPS 140-2 approved key exchange algorithms\n  ansible.builtin.lineinfile:\n    path: /etc/ssh/sshd_config\n    line: KexAlgorithms ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256\n    state: present\n    regexp: ^\\s*KexAlgorithms\\s*\n    create: true\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255060\n  - NIST-800-53-AC-17(2)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_kex_ordered_stig\n"}],"vuln_id":"SV-260533","stig_id":"UBTU-22-255060"},"xccdf_org.ssgproject.content_rule_sshd_use_approved_macs_ordered_stig":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_use_approved_macs_ordered_stig","title":"Use Only FIPS 140-2 Validated MACs","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000125-GPOS-00065","SRG-OS-000250-GPOS-00093","SRG-OS-000394-GPOS-00174"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255055"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260532r991554_rule"]}],"description":"Limit the MACs to those hash algorithms which are FIPS-approved.\nThe following line in <code>/etc/ssh/sshd_config</code>\ndemonstrates use of FIPS-approved MACs:\n<pre>MACs hmac-sha2-512,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha2-256-etm@openssh.com</pre>\nIf this line does not contain these MACs in exact order,\nis commented out, or is missing, this is a finding.","rationale":"FIPS-approved cryptographic hash functions are required to be used.\nThe only SSHv2 hash algorithms meeting this requirement is SHA2.","warnings":[{"text":"The system needs to be rebooted for these changes to take effect.","category":"general"},{"text":"System Crypto Modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this, the system has to have cryptographic software provided by\na vendor that has undergone this certification. This means providing\ndocumentation, test results, design information, and independent third\nparty review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.","category":"regulatory"}],"oval_definition_id":"oval:ssg-sshd_use_approved_macs_ordered_stig:def:1","remediations":[{"remediation_id":"sshd_use_approved_macs_ordered_stig","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nsshd_approved_macs=\"hmac-sha2-512,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha2-256-etm@openssh.com\"\n\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\nchmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*MACs\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*MACs\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*MACs\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"MACs $sshd_approved_macs\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_use_approved_macs_ordered_stig","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255055\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_macs_ordered_stig\n- name: XCCDF Value sshd_approved_macs # promote to variable\n  set_fact:\n    sshd_approved_macs: !!str hmac-sha2-512,hmac-sha2-256,hmac-sha1,hmac-sha1-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com\n  tags:\n    - always\n\n- name: Use Only FIPS 140-2 Validated MACs\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter Macs is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n      line: Macs {{ sshd_approved_macs }}\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255055\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_macs_ordered_stig\n\n- name: Use Only FIPS 140-2 Validated MACs - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255055\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_macs_ordered_stig\n"}],"vuln_id":"SV-260532","stig_id":"UBTU-22-255055"},"xccdf_org.ssgproject.content_rule_sshd_x11_use_localhost":{"rule_id":"xccdf_org.ssgproject.content_rule_sshd_x11_use_localhost","title":"Prevent remote hosts from connecting to the proxy display","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(b)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000480-GPOS-00227"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-255045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260530r991589_rule"]}],"description":"The SSH daemon should prevent remote hosts from connecting to the proxy\ndisplay.\n<br>\nThe default SSH configuration for <code>X11UseLocalhost</code> is <code>yes</code>,\nwhich prevents remote hosts from connecting to the proxy display.\n<br>\nTo explicitly prevent remote connections to the proxy display, add or correct\nthe following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<code>X11UseLocalhost yes</code>\n       ","rationale":"When X11 forwarding is enabled, there may be additional exposure to the\nserver and client displays if the sshd proxy display is configured to listen\non the wildcard address. By default, sshd binds the forwarding server to the\nloopback address and sets the hostname part of the <code>DISPLAY</code>\nenvironment variable to localhost. This prevents remote hosts from\nconnecting to the proxy display.","oval_definition_id":"oval:ssg-sshd_x11_use_localhost:def:1","remediations":[{"remediation_id":"sshd_x11_use_localhost","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"restrict","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\nchmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"X11UseLocalhost yes\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sshd_x11_use_localhost","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-255045\n  - NIST-800-53-CM-6(b)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_x11_use_localhost\n\n- name: Prevent remote hosts from connecting to the proxy display\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    ansible.builtin.stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter X11UseLocalhost is present in /etc/ssh/sshd_config.d\n    ansible.builtin.find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    ansible.builtin.lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)(?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    ansible.builtin.lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)(?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n      line: X11UseLocalhost yes\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255045\n  - NIST-800-53-CM-6(b)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_x11_use_localhost\n\n- name: Prevent remote hosts from connecting to the proxy display - set file mode\n    for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n  ansible.builtin.file:\n    path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    mode: '0600'\n    state: touch\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-255045\n  - NIST-800-53-CM-6(b)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_x11_use_localhost\n"}],"vuln_id":"SV-260530","stig_id":"UBTU-22-255045"},"xccdf_org.ssgproject.content_rule_sssd_offline_cred_expiration":{"rule_id":"xccdf_org.ssgproject.content_rule_sssd_offline_cred_expiration","title":"Configure SSSD to Expire Offline Credentials","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","15","16","5"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["DSS05.04","DSS05.05","DSS05.07","DSS05.10","DSS06.03","DSS06.10"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.3.2.2","4.3.3.5.1","4.3.3.5.2","4.3.3.6.1","4.3.3.6.2","4.3.3.6.3","4.3.3.6.4","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.3.6.9","4.3.3.7.2","4.3.3.7.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.10","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.18.1.4","A.7.1.1","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.2","A.9.4.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["CM-6(a)","IA-5(13)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["PR.AC-1","PR.AC-6","PR.AC-7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000383-GPOS-00166"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-631015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260581r958828_rule"]}],"description":"SSSD should be configured to expire offline credentials after 1 day.\n\nTo configure SSSD to expire offline credentials, set\n<code>offline_credentials_expiration</code> to <code>1</code> under the <code>[pam]</code>\nsection in <code>/etc/sssd/sssd.conf</code>. For example:\n<pre>[pam]\noffline_credentials_expiration = 1\n</pre>\n      ","rationale":"If cached authentication information is out-of-date, the validity of the\nauthentication information may be questionable.","oval_definition_id":"oval:ssg-sssd_offline_cred_expiration:def:1","remediations":[{"remediation_id":"sssd_offline_cred_expiration","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"medium","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'sssd-common' 2>/dev/null | grep -q '^installed$'; then\n\n# sssd configuration files must be created with 600 permissions if they don't exist\n# otherwise the sssd module fails to start\nOLD_UMASK=$(umask)\numask u=rw,go=\n\nfound=false\n\n# set value in all files if they contain section or key\nfor f in $(echo -n \"/etc/sssd/sssd.conf /etc/sssd/conf.d/*.conf\"); do\n    if [ ! -e \"$f\" ]; then\n        continue\n    fi\n\n    # find key in section and change value\n    if grep -qzosP \"[[:space:]]*\\[pam\\]([^\\n\\[]*\\n+)+?[[:space:]]*offline_credentials_expiration\" \"$f\"; then\n\n            sed -i \"s/offline_credentials_expiration[^(\\n)]*/offline_credentials_expiration=1/\" \"$f\"\n\n            found=true\n\n    # find section and add key = value to it\n    elif grep -qs \"[[:space:]]*\\[pam\\]\" \"$f\"; then\n\n            sed -i \"/[[:space:]]*\\[pam\\]/a offline_credentials_expiration=1\" \"$f\"\n\n            found=true\n    fi\ndone\n\n# if section not in any file, append section with key = value to FIRST file in files parameter\nif ! $found ; then\n    file=$(echo \"/etc/sssd/sssd.conf /etc/sssd/conf.d/*.conf\" | cut -f1 -d ' ')\n    mkdir -p \"$(dirname \"$file\")\"\n\n    echo -e \"[pam]\\noffline_credentials_expiration=1\" >> \"$file\"\n\nfi\n\numask $OLD_UMASK\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"sssd_offline_cred_expiration","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"medium","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-631015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Test for domain group\n  ansible.builtin.command: grep '\\s*\\[domain\\/[^]]*]' /etc/sssd/sssd.conf\n  register: test_grep_domain\n  failed_when: false\n  changed_when: false\n  check_mode: false\n  when: '\"sssd-common\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-631015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Add default domain group (if no domain there)\n  community.general.ini_file:\n    path: /etc/sssd/sssd.conf\n    section: '{{ item.section }}'\n    option: '{{ item.option }}'\n    value: '{{ item.value }}'\n    create: true\n    mode: 384\n  with_items:\n  - section: sssd\n    option: domains\n    value: default\n  - section: domain/default\n    option: id_provider\n    value: files\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - test_grep_domain.stdout is defined\n  - test_grep_domain.stdout | length < 1\n  tags:\n  - DISA-STIG-UBTU-22-631015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Configure SSD to Expire Offline Credentials\n  community.general.ini_file:\n    dest: /etc/sssd/sssd.conf\n    section: pam\n    option: offline_credentials_expiration\n    value: 1\n    create: true\n    mode: 384\n  when: '\"sssd-common\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-631015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Find all the conf files inside /etc/sssd/conf.d/\n  ansible.builtin.find:\n    paths: /etc/sssd/conf.d/\n    patterns: '*.conf'\n  register: sssd_conf_d_files\n  when: '\"sssd-common\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-631015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Fix offline_credentials_expiration configuration in /etc/sssd/conf.d/\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: '[^#]*offline_credentials_expiration.*'\n    replace: offline_credentials_expiration = 1\n  with_items: '{{ sssd_conf_d_files.files }}'\n  when: '\"sssd-common\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-631015\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n"}],"vuln_id":"SV-260581","stig_id":"UBTU-22-631015"},"xccdf_org.ssgproject.content_rule_package_audit-audispd-plugins_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_audit-audispd-plugins_installed","title":"Ensure the default plugins for the audit dispatcher are Installed","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(5)(ii)(C)","164.310(a)(2)(iv)","164.310(d)(2)(iii)","164.312(b)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000342-GPOS-00133"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260592r958754_rule"]}],"description":"The audit-audispd-plugins package should be installed.","rationale":"Information stored in one location is vulnerable to accidental or incidental deletion or alteration. Off-loading is a common process in information systems with limited audit storage capacity.","oval_definition_id":"oval:ssg-package_audit-audispd-plugins_installed:def:1","remediations":[{"remediation_id":"package_audit-audispd-plugins_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"audispd-plugins\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_audit-audispd-plugins_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_audispd-plugins\n\nclass install_audispd-plugins {\n  package { 'audispd-plugins':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_audit-audispd-plugins_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"audispd-plugins\"\nversion = \"*\"\n"},{"remediation_id":"package_audit-audispd-plugins_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653020\n  - PCI-DSS-Req-10.5.3\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.3\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_audit-audispd-plugins_installed\n\n- name: Ensure audispd-plugins is installed\n  ansible.builtin.package:\n    name: audispd-plugins\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653020\n  - PCI-DSS-Req-10.5.3\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.3\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_audit-audispd-plugins_installed\n"}],"vuln_id":"SV-260592","stig_id":"UBTU-22-653020"},"xccdf_org.ssgproject.content_rule_package_audit_installed":{"rule_id":"xccdf_org.ssgproject.content_rule_package_audit_installed","title":"Ensure the audit Subsystem is Installed","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R33","R73"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.1.1"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(5)(ii)(C)","164.310(a)(2)(iv)","164.310(d)(2)(iii)","164.312(b)"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R3.3","CIP-007-3 R6.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-7(a)","AU-12(2)","AU-14","AU-2(a)","AU-7(1)","AU-7(2)","CM-6(a)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000038-GPOS-00016","SRG-OS-000039-GPOS-00017","SRG-OS-000040-GPOS-00018","SRG-OS-000041-GPOS-00019","SRG-OS-000042-GPOS-00021","SRG-OS-000051-GPOS-00024","SRG-OS-000054-GPOS-00025","SRG-OS-000062-GPOS-00031","SRG-OS-000122-GPOS-00063","SRG-OS-000254-GPOS-00095","SRG-OS-000255-GPOS-00096","SRG-OS-000337-GPOS-00129","SRG-OS-000348-GPOS-00136","SRG-OS-000349-GPOS-00137","SRG-OS-000350-GPOS-00138","SRG-OS-000351-GPOS-00139","SRG-OS-000352-GPOS-00140","SRG-OS-000353-GPOS-00141","SRG-OS-000354-GPOS-00142","SRG-OS-000358-GPOS-00145","SRG-OS-000365-GPOS-00152","SRG-OS-000392-GPOS-00172","SRG-OS-000475-GPOS-00220"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FAU_GEN.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.1"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260590r1015022_rule"]}],"description":"The audit package should be installed.","rationale":"The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparison with potential local access control policy such as SELinux policy.","oval_definition_id":"oval:ssg-package_audit_installed:def:1","remediations":[{"remediation_id":"package_audit_installed","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"auditd\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"package_audit_installed","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include install_auditd\n\nclass install_auditd {\n  package { 'auditd':\n    ensure => 'installed',\n  }\n}\n"},{"remediation_id":"package_audit_installed","system":"urn:redhat:osbuild:blueprint","fix":"\n[[packages]]\nname = \"auditd\"\nversion = \"*\"\n"},{"remediation_id":"package_audit_installed","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653010\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-AU-12(2)\n  - NIST-800-53-AU-14\n  - NIST-800-53-AU-2(a)\n  - NIST-800-53-AU-7(1)\n  - NIST-800-53-AU-7(2)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.1\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_audit_installed\n\n- name: Ensure auditd is installed\n  ansible.builtin.package:\n    name: auditd\n    state: present\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653010\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-AU-12(2)\n  - NIST-800-53-AU-14\n  - NIST-800-53-AU-2(a)\n  - NIST-800-53-AU-7(1)\n  - NIST-800-53-AU-7(2)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.1\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_audit_installed\n"}],"vuln_id":"SV-260590","stig_id":"UBTU-22-653010"},"xccdf_org.ssgproject.content_rule_service_auditd_enabled":{"rule_id":"xccdf_org.ssgproject.content_rule_service_auditd_enabled","title":"Enable auditd Service","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R33","R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000095-CTR-000170","SRG-APP-000409-CTR-000990","SRG-APP-000508-CTR-001300","SRG-APP-000510-CTR-001310"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.1.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.3.1","3.3.2","3.3.6"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(5)(ii)(C)","164.310(a)(2)(iv)","164.310(d)(2)(iii)","164.312(b)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R3.3","CIP-007-3 R6.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(g)","AC-6(9)","AU-10","AU-12(c)","AU-14(1)","AU-2(d)","AU-3","CM-6(a)","SI-4(23)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000038-GPOS-00016","SRG-OS-000039-GPOS-00017","SRG-OS-000040-GPOS-00018","SRG-OS-000041-GPOS-00019","SRG-OS-000042-GPOS-00021","SRG-OS-000051-GPOS-00024","SRG-OS-000054-GPOS-00025","SRG-OS-000062-GPOS-00031","SRG-OS-000122-GPOS-00063","SRG-OS-000254-GPOS-00095","SRG-OS-000255-GPOS-00096","SRG-OS-000337-GPOS-00129","SRG-OS-000348-GPOS-00136","SRG-OS-000349-GPOS-00137","SRG-OS-000350-GPOS-00138","SRG-OS-000351-GPOS-00139","SRG-OS-000352-GPOS-00140","SRG-OS-000353-GPOS-00141","SRG-OS-000354-GPOS-00142","SRG-OS-000358-GPOS-00145","SRG-OS-000365-GPOS-00152","SRG-OS-000392-GPOS-00172","SRG-OS-000475-GPOS-00220"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FAU_GEN.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.1"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260591r1015023_rule"]}],"description":"The <code>auditd</code> service is an essential userspace component of\nthe Linux Auditing System, as it is responsible for writing audit records to\ndisk.\n\nThe <code>auditd</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable auditd.service</pre>\n     ","rationale":"Without establishing what type of events occurred, it would be difficult\nto establish, correlate, and investigate the events leading up to an outage or attack.\nEnsuring the <code>auditd</code> service is active ensures audit records\ngenerated by the kernel are appropriately recorded.\n<br>\n      <br>\nAdditionally, a properly configured audit subsystem ensures that actions of\nindividual system users can be uniquely traced to those users so they\ncan be held accountable for their actions.","platforms":["#package_audit"],"oval_definition_id":"oval:ssg-service_auditd_enabled:def:1","remediations":[{"remediation_id":"service_auditd_enabled","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"enable","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$'; }; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'auditd.service'\nif [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then\n  \"$SYSTEMCTL_EXEC\" start 'auditd.service'\nfi\n\"$SYSTEMCTL_EXEC\" enable 'auditd.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"service_auditd_enabled","system":"urn:xccdf:fix:script:puppet","complexity":"low","disruption":"low","strategy":"enable","fix":"include enable_auditd\n\nclass enable_auditd {\n  service {'auditd':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"},{"remediation_id":"service_auditd_enabled","system":"urn:redhat:osbuild:blueprint","fix":"\n[customizations.services]\nenabled = [\"auditd\"]\n"},{"remediation_id":"service_auditd_enabled","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"enable","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-653015\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.3.2\n  - NIST-800-171-3.3.6\n  - NIST-800-53-AC-2(g)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-AU-3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-4(23)\n  - PCI-DSS-Req-10.1\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_auditd_enabled\n\n- name: Enable auditd Service - Enable service auditd\n  block:\n\n  - name: Gather the package facts\n    ansible.builtin.package_facts:\n      manager: auto\n\n  - name: Enable auditd Service - Enable Service auditd\n    ansible.builtin.systemd:\n      name: auditd\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"auditd\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-653015\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.3.2\n  - NIST-800-171-3.3.6\n  - NIST-800-53-AC-2(g)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-AU-3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-4(23)\n  - PCI-DSS-Req-10.1\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_auditd_enabled\n  - special_service_block\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - '\"auditd\" in ansible_facts.packages'\n"}],"vuln_id":"SV-260591","stig_id":"UBTU-22-653015"},"xccdf_org.ssgproject.content_rule_grub2_audit_argument":{"rule_id":"xccdf_org.ssgproject.content_rule_grub2_audit_argument","title":"Enable Auditing for Processes Which Start Prior to the Audit Daemon","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"low","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.1.3"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","3","4","5","6","7","8"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS05.02","DSS05.03","DSS05.04","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.3.1"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(5)(ii)(C)","164.310(a)(2)(iv)","164.310(d)(2)(iii)","164.312(b)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-17(1)","AU-10","AU-14(1)","CM-6(a)","IR-5(1)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000254-GPOS-00095","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215","SRG-OS-000473-GPOS-00218"]},{"name":"ospp","href":"https://www.niap-ccevs.org/Profile/PP.cfm","ref_ids":["FAU_GEN.1"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.7","10.7.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-212015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260471r991555_rule"]}],"description":"To ensure all processes can be audited, even those which start\nprior to the audit daemon, add the argument <code>audit=1</code> to the default\nGRUB 2 command line for the Linux operating system.\nTo ensure that <code>audit=1</code> is added as a kernel command line\nargument to newly installed kernels, add <code>audit=1</code> to the\ndefault Grub2 command line for Linux operating systems. Modify the line within\n<code>/etc/default/grub</code> as shown below:\n<pre>GRUB_CMDLINE_LINUX=&quot;... audit=1 ...&quot;</pre>\nRun the following command to update command line for already installed kernels:<pre># update-grub</pre>\n     ","rationale":"Each process on the system carries an &quot;auditable&quot; flag which indicates whether\nits activities can be audited. Although <code>auditd</code> takes care of enabling\nthis for all processes which launch after it does, adding the kernel argument\nensures it is set for every process during boot.","platforms":["#grub2"],"oval_definition_id":"oval:ssg-grub2_audit_argument:def:1","remediations":[{"remediation_id":"grub2_audit_argument","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { dpkg-query --show --showformat='${db:Status-Status}' 'grub2-common' 2>/dev/null | grep -q '^installed$'; }; then\n\nif /bin/false ; then\n    KARGS_DIR=\"/usr/lib/bootc/kargs.d/\"\n    if grep -q -E \"audit\" \"$KARGS_DIR/*.toml\" ; then\n        sed -i -E \"s/^(\\s*kargs\\s*=\\s*\\[.*)\\\"audit=[^\\\"]*\\\"(.*]\\s*)/\\1\\\"audit=1\\\"\\2/\" \"$KARGS_DIR/*.toml\"\n    else\n        echo \"kargs = [\\\"audit=1\\\"]\" >> \"$KARGS_DIR/10-audit.toml\"\n    fi\nelse\n\n\n    # Correct the form of default kernel command line in GRUB\n    if grep -q '^\\s*GRUB_CMDLINE_LINUX=.*audit=.*\"'  '/etc/default/grub' ; then\n           # modify the GRUB command-line if an audit= arg already exists\n           sed -i \"s/\\(^\\s*GRUB_CMDLINE_LINUX=\\\".*\\)audit=[^[:space:]]\\+\\(.*\\\"\\)/\\1audit=1\\2/\"  '/etc/default/grub'\n    # Add to already existing GRUB_CMDLINE_LINUX parameters\n    elif grep -q '^\\s*GRUB_CMDLINE_LINUX='  '/etc/default/grub' ; then\n           # no audit=arg is present, append it\n           sed -i \"s/\\(^\\s*GRUB_CMDLINE_LINUX=\\\".*\\)\\\"/\\1 audit=1\\\"/\"  '/etc/default/grub'\n    # Add GRUB_CMDLINE_LINUX parameters line\n    else\n           echo \"GRUB_CMDLINE_LINUX=\\\"audit=1\\\"\" >> '/etc/default/grub'\n    fi\n    update-grub \n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"grub2_audit_argument","system":"urn:redhat:osbuild:blueprint","fix":"[customizations.kernel]\nappend = \"audit=1\"\n"}],"vuln_id":"SV-260471","stig_id":"UBTU-22-212015"},"xccdf_org.ssgproject.content_rule_audit_rules_session_events_btmp":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_session_events_btmp","title":"Record Attempts to Alter Process and Session Initiation Information btmp","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-12.1(iv)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000472-GPOS-00217"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654195"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260641r991581_rule"]}],"description":"The audit system already collects process information for all\nusers and root.\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /var/log/btmp -p wa -k session</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /var/log/btmp -p wa -k session</pre>\n      ","rationale":"Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.","oval_definition_id":"oval:ssg-audit_rules_session_events_btmp:def:1","remediations":[{"remediation_id":"audit_rules_session_events_btmp","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/btmp\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/btmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/btmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/btmp -p wa -k session\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/btmp\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/btmp\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/btmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/btmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/btmp -p wa -k session\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_session_events_btmp","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information btmp -\n    Check if watch rule for /var/log/btmp already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/btmp\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information btmp -\n    Search /etc/audit/rules.d for other rules with specified key session\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)session$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information btmp -\n    Use /etc/audit/rules.d/session.rules as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/session.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information btmp -\n    Use matched file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information btmp -\n    Add watch rule for /var/log/btmp in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/btmp -p wa -k session\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information btmp -\n    Check if watch rule for /var/log/btmp already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/btmp\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information btmp -\n    Add watch rule for /var/log/btmp in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /var/log/btmp -p wa -k session\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654195\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_btmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260641","stig_id":"UBTU-22-654195"},"xccdf_org.ssgproject.content_rule_audit_rules_session_events_utmp":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_session_events_utmp","title":"Record Attempts to Alter Process and Session Initiation Information utmp","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-12.1(iv)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000472-GPOS-00217"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654205"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260643r991581_rule"]}],"description":"The audit system already collects process information for all\nusers and root.\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /var/run/utmp -p wa -k session</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /var/run/utmp -p wa -k session</pre>\n      ","rationale":"Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.","oval_definition_id":"oval:ssg-audit_rules_session_events_utmp:def:1","remediations":[{"remediation_id":"audit_rules_session_events_utmp","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/run/utmp\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/run/utmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/run/utmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/run/utmp -p wa -k session\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/run/utmp\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/run/utmp\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/run/utmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/run/utmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/run/utmp -p wa -k session\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_session_events_utmp","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information utmp -\n    Check if watch rule for /var/run/utmp already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/run/utmp\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information utmp -\n    Search /etc/audit/rules.d for other rules with specified key session\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)session$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information utmp -\n    Use /etc/audit/rules.d/session.rules as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/session.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information utmp -\n    Use matched file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information utmp -\n    Add watch rule for /var/run/utmp in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/run/utmp -p wa -k session\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information utmp -\n    Check if watch rule for /var/run/utmp already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/run/utmp\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information utmp -\n    Add watch rule for /var/run/utmp in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /var/run/utmp -p wa -k session\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654205\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_utmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260643","stig_id":"UBTU-22-654205"},"xccdf_org.ssgproject.content_rule_audit_rules_session_events_wtmp":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_session_events_wtmp","title":"Record Attempts to Alter Process and Session Initiation Information wtmp","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-12.1(iv)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000472-GPOS-00217"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654200"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260642r991581_rule"]}],"description":"The audit system already collects process information for all\nusers and root.\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /var/log/wtmp -p wa -k session</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /var/log/wtmp -p wa -k session</pre>\n      ","rationale":"Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.","oval_definition_id":"oval:ssg-audit_rules_session_events_wtmp:def:1","remediations":[{"remediation_id":"audit_rules_session_events_wtmp","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/wtmp\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/wtmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/wtmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/wtmp -p wa -k session\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/wtmp\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/wtmp\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/wtmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/wtmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/wtmp -p wa -k session\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_session_events_wtmp","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information wtmp -\n    Check if watch rule for /var/log/wtmp already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/wtmp\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information wtmp -\n    Search /etc/audit/rules.d for other rules with specified key session\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)session$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information wtmp -\n    Use /etc/audit/rules.d/session.rules as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/session.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information wtmp -\n    Use matched file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information wtmp -\n    Add watch rule for /var/log/wtmp in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/wtmp -p wa -k session\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information wtmp -\n    Check if watch rule for /var/log/wtmp already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/wtmp\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Process and Session Initiation Information wtmp -\n    Add watch rule for /var/log/wtmp in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /var/log/wtmp -p wa -k session\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654200\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-12.1(iv)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_session_events_wtmp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260642","stig_id":"UBTU-22-654200"},"xccdf_org.ssgproject.content_rule_audit_rules_sudoers":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_sudoers","title":"Ensure auditd Collects System Administrator Actions - /etc/sudoers","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000503-CTR-001275"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000004-GPOS-00004","SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000239-GPOS-00089","SRG-OS-000240-GPOS-00090","SRG-OS-000241-GPOS-00091","SRG-OS-000303-GPOS-00120","SRG-OS-000304-GPOS-00121","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000476-GPOS-00221"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654220"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260646r991575_rule"]}],"description":"At a minimum, the audit system should collect administrator actions\nfor all users and root.\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /etc/sudoers -p wa -k actions</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /etc/sudoers -p wa -k actions</pre>\n      ","rationale":"The actions taken by system administrators should be audited to keep a record\nof what was executed on the system, as well as, for accountability purposes.\nEditing the sudoers file may be sign of an attacker trying to\nestablish persistent methods to a system, auditing the editing of the sudoers\nfiles mitigates this risk.","oval_definition_id":"oval:ssg-audit_rules_sudoers:def:1","remediations":[{"remediation_id":"audit_rules_sudoers","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/sudoers -p wa -k actions\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/actions.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/sudoers\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/actions.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/actions.rules\"\n    # If the actions.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/sudoers -p wa -k actions\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_sudoers","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers - Check\n    if watch rule for /etc/sudoers already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/sudoers\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers - Search\n    /etc/audit/rules.d for other rules with specified key actions\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)actions$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers - Use /etc/audit/rules.d/actions.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/actions.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers - Use matched\n    file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers - Add watch\n    rule for /etc/sudoers in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/sudoers -p wa -k actions\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers - Check\n    if watch rule for /etc/sudoers already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/sudoers\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers - Add watch\n    rule for /etc/sudoers in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /etc/sudoers -p wa -k actions\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654220\n  - audit_rules_sudoers\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260646","stig_id":"UBTU-22-654220"},"xccdf_org.ssgproject.content_rule_audit_rules_sudoers_d":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_sudoers_d","title":"Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000503-CTR-001275"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000004-GPOS-00004","SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000239-GPOS-00089","SRG-OS-000240-GPOS-00090","SRG-OS-000241-GPOS-00091","SRG-OS-000303-GPOS-00120","SRG-OS-000304-GPOS-00121","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000476-GPOS-00221"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654225"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260647r991575_rule"]}],"description":"At a minimum, the audit system should collect administrator actions\nfor all users and root.\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /etc/sudoers.d/ -p wa -k actions</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /etc/sudoers.d/ -p wa -k actions</pre>\n      ","rationale":"The actions taken by system administrators should be audited to keep a record\nof what was executed on the system, as well as, for accountability purposes.\nEditing the sudoers file may be sign of an attacker trying to\nestablish persistent methods to a system, auditing the editing of the sudoers\nfiles mitigates this risk.","oval_definition_id":"oval:ssg-audit_rules_sudoers_d:def:1","remediations":[{"remediation_id":"audit_rules_sudoers_d","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers.d/\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers.d/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers.d/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/sudoers.d/ -p wa -k actions\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/actions.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/sudoers.d/\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/actions.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/actions.rules\"\n    # If the actions.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers.d/\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers.d/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers.d/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/sudoers.d/ -p wa -k actions\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_sudoers_d","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/ - Check\n    if watch rule for /etc/sudoers.d/ already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/sudoers.d/\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/ - Search\n    /etc/audit/rules.d for other rules with specified key actions\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)actions$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/ - Use\n    /etc/audit/rules.d/actions.rules as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/actions.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/ - Use\n    matched file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/ - Add\n    watch rule for /etc/sudoers.d/ in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/sudoers.d/ -p wa -k actions\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/ - Check\n    if watch rule for /etc/sudoers.d/ already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/sudoers.d/\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/ - Add\n    watch rule for /etc/sudoers.d/ in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /etc/sudoers.d/ -p wa -k actions\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654225\n  - audit_rules_sudoers_d\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260647","stig_id":"UBTU-22-654225"},"xccdf_org.ssgproject.content_rule_audit_rules_suid_privilege_function":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_suid_privilege_function","title":"Record Events When Privileged Executables Are Run","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000343-CTR-000780","SRG-APP-000381-CTR-000905"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(3)","AU-7(a)","AU-7(b)","AU-8(b)","CM-5(1)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000326-GPOS-00126","SRG-OS-000327-GPOS-00127","SRG-OS-000755-GPOS-00220"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.2"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654230"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260648r958730_rule"]}],"description":"Verify the system generates an audit record when privileged functions are executed.\n\nIf audit is using the &quot;auditctl&quot; tool to load the rules, run the following command:\n\n<pre>$ sudo grep execve /etc/audit/audit.rules</pre>\n\nIf audit is using the &quot;augenrules&quot; tool to load the rules, run the following command:\n\n<pre>$ sudo grep -r execve /etc/audit/rules.d</pre>\n       <pre>-a always,exit -F arch=b32 -S execve -C uid!=euid -F euid=0 -k setuid</pre>\n       <pre>-a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -k setuid</pre>\n       <pre>-a always,exit -F arch=b32 -S execve -C gid!=egid -F egid=0 -k setgid</pre>\n       <pre>-a always,exit -F arch=b64 -S execve -C gid!=egid -F egid=0 -k setgid</pre>\n\n\nIf both the &quot;b32&quot; and &quot;b64&quot; audit rules for &quot;SUID&quot; files are not defined, this is a finding.\nIf both the &quot;b32&quot; and &quot;b64&quot; audit rules for &quot;SGID&quot; files are not defined, this is a finding.","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have\ncompromised information system accounts, is a serious and ongoing concern\nand can have significant adverse impacts on organizations. Auditing the use\nof privileged functions is one way to detect such misuse and identify the\nrisk from insider threats and the advanced persistent threat.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_suid_privilege_function:def:1","remediations":[{"remediation_id":"audit_rules_suid_privilege_function","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n    \n\tOTHER_FILTERS=\"-C uid!=euid -F euid=0\"\n\t\n\tAUID_FILTERS=\"\"\n\tSYSCALL=\"execve\"\n    \n\tKEY=\"setuid\"\n\t\n\tSYSCALL_GROUPING=\"\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n    \n\tOTHER_FILTERS=\"-C gid!=egid -F egid=0\"\n\t\n\tAUID_FILTERS=\"\"\n\tSYSCALL=\"execve\"\n    \n\tKEY=\"setgid\"\n\t\n\tSYSCALL_GROUPING=\"\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_suid_privilege_function","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654230\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(3)\n  - NIST-800-53-AU-7(a)\n  - NIST-800-53-AU-7(b)\n  - NIST-800-53-AU-8(b)\n  - NIST-800-53-CM-5(1)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.2\n  - audit_rules_suid_privilege_function\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Service facts\n  ansible.builtin.service_facts: null\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654230\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(3)\n  - NIST-800-53-AU-7(a)\n  - NIST-800-53-AU-7(b)\n  - NIST-800-53-AU-8(b)\n  - NIST-800-53-CM-5(1)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.2\n  - audit_rules_suid_privilege_function\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set suid_audit_rules fact\n  ansible.builtin.set_fact:\n    suid_audit_rules:\n    - rule: -a always,exit -F arch=b32 -S execve -C gid!=egid -F egid=0 -k setgid\n      regex: ^[\\s]*-a[\\s]+always,exit[\\s]+-F[\\s]+arch=b32[\\s]+-S[\\s]+execve[\\s]+-C[\\s]+gid!=egid[\\s]+-F[\\s]+egid=0[\\s]+(?:-k[\\s]+|-F[\\s]+key=)[\\S]+[\\s]*$\n    - rule: -a always,exit -F arch=b64 -S execve -C gid!=egid -F egid=0 -k setgid\n      regex: ^[\\s]*-a[\\s]+always,exit[\\s]+-F[\\s]+arch=b64[\\s]+-S[\\s]+execve[\\s]+-C[\\s]+gid!=egid[\\s]+-F[\\s]+egid=0[\\s]+(?:-k[\\s]+|-F[\\s]+key=)[\\S]+[\\s]*$\n    - rule: -a always,exit -F arch=b32 -S execve -C uid!=euid -F euid=0 -k setuid\n      regex: ^[\\s]*-a[\\s]+always,exit[\\s]+-F[\\s]+arch=b32[\\s]+-S[\\s]+execve[\\s]+-C[\\s]+uid!=euid[\\s]+-F[\\s]+euid=0[\\s]+(?:-k[\\s]+|-F[\\s]+key=)[\\S]+[\\s]*$\n    - rule: -a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -k setuid\n      regex: ^[\\s]*-a[\\s]+always,exit[\\s]+-F[\\s]+arch=b64[\\s]+-S[\\s]+execve[\\s]+-C[\\s]+uid!=euid[\\s]+-F[\\s]+euid=0[\\s]+(?:-k[\\s]+|-F[\\s]+key=)[\\S]+[\\s]*$\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654230\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(3)\n  - NIST-800-53-AU-7(a)\n  - NIST-800-53-AU-7(b)\n  - NIST-800-53-AU-8(b)\n  - NIST-800-53-CM-5(1)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.2\n  - audit_rules_suid_privilege_function\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Update /etc/audit/rules.d/privileged.rules to audit privileged functions\n  ansible.builtin.lineinfile:\n    path: /etc/audit/rules.d/privileged.rules\n    line: '{{  item.rule  }}'\n    regexp: '{{ item.regex }}'\n    mode: '0600'\n    create: true\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ('\"auditd.service\" in ansible_facts.services' or '\"augenrules.service\" in ansible_facts.services')\n  register: augenrules_audit_rules_privilege_function_update_result\n  with_items: '{{ suid_audit_rules }}'\n  tags:\n  - DISA-STIG-UBTU-22-654230\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(3)\n  - NIST-800-53-AU-7(a)\n  - NIST-800-53-AU-7(b)\n  - NIST-800-53-AU-8(b)\n  - NIST-800-53-CM-5(1)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.2\n  - audit_rules_suid_privilege_function\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Update /etc/audit/audit.rules to audit privileged functions\n  ansible.builtin.lineinfile:\n    path: /etc/audit/audit.rules\n    line: '{{  item.rule  }}'\n    regexp: '{{ item.regex }}'\n    create: true\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ('\"auditd.service\" in ansible_facts.services' or '\"augenrules.service\" in ansible_facts.services')\n  register: auditctl_audit_rules_privilege_function_update_result\n  with_items: '{{ suid_audit_rules }}'\n  tags:\n  - DISA-STIG-UBTU-22-654230\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(3)\n  - NIST-800-53-AU-7(a)\n  - NIST-800-53-AU-7(b)\n  - NIST-800-53-AU-8(b)\n  - NIST-800-53-CM-5(1)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.2\n  - audit_rules_suid_privilege_function\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Restart Auditd\n  ansible.builtin.command: /usr/sbin/service auditd restart\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - (augenrules_audit_rules_privilege_function_update_result.changed or auditctl_audit_rules_privilege_function_update_result.changed)\n  - ansible_facts.services[\"auditd.service\"].state == \"running\"\n  tags:\n  - DISA-STIG-UBTU-22-654230\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(3)\n  - NIST-800-53-AU-7(a)\n  - NIST-800-53-AU-7(b)\n  - NIST-800-53-AU-8(b)\n  - NIST-800-53-CM-5(1)\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.2\n  - audit_rules_suid_privilege_function\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260648","stig_id":"UBTU-22-654230"},"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group","title":"Record Events that Modify User/Group Information - /etc/group","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000503-CTR-001275"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.8"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","18","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","DSS06.03","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.2.2","4.3.3.3.9","4.3.3.5.1","4.3.3.5.2","4.3.3.5.8","4.3.3.6.6","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.1.2","A.6.2.1","A.6.2.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-1","PR.AC-3","PR.AC-4","PR.AC-6","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000004-GPOS-00004","SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000239-GPOS-00089","SRG-OS-000240-GPOS-00090","SRG-OS-000241-GPOS-00091","SRG-OS-000303-GPOS-00120","SRG-OS-000304-GPOS-00121","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000476-GPOS-00221"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.5"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654130"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260628r958368_rule"]}],"description":"\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>\n      ","rationale":"In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.","oval_definition_id":"oval:ssg-audit_rules_usergroup_modification_group:def:1","remediations":[{"remediation_id":"audit_rules_usergroup_modification_group","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/group\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/group $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/group$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/group -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/group\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/group\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/group $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/group$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/group -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_usergroup_modification_group","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/group - Check if watch\n    rule for /etc/group already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/group\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/group - Search /etc/audit/rules.d\n    for other rules with specified key audit_rules_usergroup_modification\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/group - Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/group - Use matched\n    file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/group - Add watch\n    rule for /etc/group in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/group -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/group - Check if watch\n    rule for /etc/group already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/group\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/group - Add watch\n    rule for /etc/group in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /etc/group -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654130\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260628","stig_id":"UBTU-22-654130"},"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow","title":"Record Events that Modify User/Group Information - /etc/gshadow","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000503-CTR-001275"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.8"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","18","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","DSS06.03","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.2.2","4.3.3.3.9","4.3.3.5.1","4.3.3.5.2","4.3.3.5.8","4.3.3.6.6","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.1.2","A.6.2.1","A.6.2.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-1","PR.AC-3","PR.AC-4","PR.AC-6","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000004-GPOS-00004","SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000239-GPOS-00089","SRG-OS-000240-GPOS-00090","SRG-OS-000241-GPOS-00091","SRG-OS-000303-GPOS-00120","SRG-OS-000304-GPOS-00121","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000476-GPOS-00221"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.5"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654135"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260629r958368_rule"]}],"description":"\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>\n      ","rationale":"In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.","oval_definition_id":"oval:ssg-audit_rules_usergroup_modification_gshadow:def:1","remediations":[{"remediation_id":"audit_rules_usergroup_modification_gshadow","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/gshadow\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/gshadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/gshadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/gshadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/gshadow\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/gshadow\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/gshadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/gshadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/gshadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_usergroup_modification_gshadow","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/gshadow - Check if\n    watch rule for /etc/gshadow already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/gshadow\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/gshadow - Search /etc/audit/rules.d\n    for other rules with specified key audit_rules_usergroup_modification\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/gshadow - Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/gshadow - Use matched\n    file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/gshadow - Add watch\n    rule for /etc/gshadow in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/gshadow - Check if\n    watch rule for /etc/gshadow already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/gshadow\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/gshadow - Add watch\n    rule for /etc/gshadow in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654135\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260629","stig_id":"UBTU-22-654135"},"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd","title":"Record Events that Modify User/Group Information - /etc/security/opasswd","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000496-CTR-001240","SRG-APP-000497-CTR-001245","SRG-APP-000498-CTR-001250","SRG-APP-000503-CTR-001275"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.8"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","18","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","DSS06.03","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.2.2","4.3.3.3.9","4.3.3.5.1","4.3.3.5.2","4.3.3.5.8","4.3.3.6.6","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.1.2","A.6.2.1","A.6.2.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-1","PR.AC-3","PR.AC-4","PR.AC-6","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000004-GPOS-00004","SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000239-GPOS-00089","SRG-OS-000240-GPOS-00090","SRG-OS-000241-GPOS-00091","SRG-OS-000303-GPOS-00120","SRG-OS-000304-GPOS-00121","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000476-GPOS-00221"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.5"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654140"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260630r958368_rule"]}],"description":"\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>\n      ","rationale":"In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.","oval_definition_id":"oval:ssg-audit_rules_usergroup_modification_opasswd:def:1","remediations":[{"remediation_id":"audit_rules_usergroup_modification_opasswd","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/security/opasswd\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/security/opasswd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/security/opasswd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/security/opasswd\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/security/opasswd\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/security/opasswd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/security/opasswd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_usergroup_modification_opasswd","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/security/opasswd -\n    Check if watch rule for /etc/security/opasswd already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/security/opasswd\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/security/opasswd -\n    Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/security/opasswd -\n    Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient\n    for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/security/opasswd -\n    Use matched file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/security/opasswd -\n    Add watch rule for /etc/security/opasswd in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/security/opasswd -\n    Check if watch rule for /etc/security/opasswd already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/security/opasswd\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/security/opasswd -\n    Add watch rule for /etc/security/opasswd in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654140\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260630","stig_id":"UBTU-22-654140"},"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd","title":"Record Events that Modify User/Group Information - /etc/passwd","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000503-CTR-001275"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.8"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","18","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","DSS06.03","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.2.2","4.3.3.3.9","4.3.3.5.1","4.3.3.5.2","4.3.3.5.8","4.3.3.6.6","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.1.2","A.6.2.1","A.6.2.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-1","PR.AC-3","PR.AC-4","PR.AC-6","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000004-GPOS-00004","SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000239-GPOS-00089","SRG-OS-000240-GPOS-00090","SRG-OS-000241-GPOS-00091","SRG-OS-000274-GPOS-00104","SRG-OS-000275-GPOS-00105","SRG-OS-000276-GPOS-00106","SRG-OS-000277-GPOS-00107","SRG-OS-000303-GPOS-00120","SRG-OS-000304-GPOS-00121","SRG-OS-000304-GPOS-00121","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000476-GPOS-00221"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.5"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654145"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260631r958368_rule"]}],"description":"\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>\n      ","rationale":"In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.","oval_definition_id":"oval:ssg-audit_rules_usergroup_modification_passwd:def:1","remediations":[{"remediation_id":"audit_rules_usergroup_modification_passwd","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/passwd\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/passwd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/passwd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/passwd -p wa -k audit_rules_usergroup_modification_passwd\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification_passwd.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/passwd\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification_passwd.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification_passwd.rules\"\n    # If the audit_rules_usergroup_modification_passwd.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/passwd\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/passwd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/passwd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/passwd -p wa -k audit_rules_usergroup_modification_passwd\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_usergroup_modification_passwd","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/passwd - Check if\n    watch rule for /etc/passwd already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/passwd\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/passwd - Search /etc/audit/rules.d\n    for other rules with specified key audit_rules_usergroup_modification_passwd\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification_passwd$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/passwd - Use /etc/audit/rules.d/audit_rules_usergroup_modification_passwd.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification_passwd.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/passwd - Use matched\n    file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/passwd - Add watch\n    rule for /etc/passwd in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification_passwd\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/passwd - Check if\n    watch rule for /etc/passwd already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/passwd\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/passwd - Add watch\n    rule for /etc/passwd in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification_passwd\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260631","stig_id":"UBTU-22-654145"},"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow","title":"Record Events that Modify User/Group Information - /etc/shadow","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000503-CTR-001275"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.8"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","18","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","DSS06.03","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.2.2","4.3.3.3.9","4.3.3.5.1","4.3.3.5.2","4.3.3.5.8","4.3.3.6.6","4.3.3.7.2","4.3.3.7.3","4.3.3.7.4","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.1","SR 1.13","SR 1.2","SR 1.3","SR 1.4","SR 1.5","SR 1.7","SR 1.8","SR 1.9","SR 2.1","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.1.2","A.6.2.1","A.6.2.2","A.7.1.1","A.9.1.2","A.9.2.1","A.9.2.2","A.9.2.3","A.9.2.4","A.9.2.6","A.9.3.1","A.9.4.1","A.9.4.2","A.9.4.3","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-1","PR.AC-3","PR.AC-4","PR.AC-6","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000004-GPOS-00004","SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000239-GPOS-00089","SRG-OS-000240-GPOS-00090","SRG-OS-000241-GPOS-00091","SRG-OS-000303-GPOS-00120","SRG-OS-000304-GPOS-00121","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000476-GPOS-00221"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.5"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654150"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260632r958368_rule"]}],"description":"\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>\n      ","rationale":"In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.","oval_definition_id":"oval:ssg-audit_rules_usergroup_modification_shadow:def:1","remediations":[{"remediation_id":"audit_rules_usergroup_modification_shadow","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/shadow\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/shadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/shadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/shadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/shadow\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/shadow\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/shadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/etc/shadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /etc/shadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_usergroup_modification_shadow","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/shadow - Check if\n    watch rule for /etc/shadow already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/shadow\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/shadow - Search /etc/audit/rules.d\n    for other rules with specified key audit_rules_usergroup_modification\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/shadow - Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/shadow - Use matched\n    file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/shadow - Add watch\n    rule for /etc/shadow in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/shadow - Check if\n    watch rule for /etc/shadow already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/shadow\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Events that Modify User/Group Information - /etc/shadow - Add watch\n    rule for /etc/shadow in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654150\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260632","stig_id":"UBTU-22-654150"},"xccdf_org.ssgproject.content_rule_audit_rules_var_log_journal":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_var_log_journal","title":"Ensure auditd Collects records for events that affect \"/var/log/journal\"","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654190"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260640r991589_rule"]}],"description":"Auditing the systemd journal files provides logging that can be used for\nforensic purposes. Verify the system generates audit records for all events\nthat affect &quot;/var/log/journal&quot; by using the following command:\n\n<pre>\n$ sudo auditctl -l | grep journal\n-w /var/log/journal/ -p wa -k systemd_journal\n</pre>\n\nIf the command does not return a line that matches the example or the line\nis commented out, this is a finding.\n\nNote: The &quot;-k&quot; value is arbitrary and can be different from the example\noutput above.\n\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /var/log/journal -p wa -k systemd_journal</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /var/log/journal -p wa -k systemd_journal</pre>\n      ","rationale":"Once an attacker establishes access to a system, the attacker often attempts\nto create a persistent method of reestablishing access. One way to accomplish\nthis is for the attacker to modify system level binaries and their operation.\nAuditing the systemd journal files provides logging that can be used for\nforensic purposes.","oval_definition_id":"oval:ssg-audit_rules_var_log_journal:def:1","remediations":[{"remediation_id":"audit_rules_var_log_journal","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/journal/\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/journal/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/journal/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/journal/ -p wa -k audit_rules_var_log_journal\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_var_log_journal.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/journal/\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_var_log_journal.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_var_log_journal.rules\"\n    # If the audit_rules_var_log_journal.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/journal/\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/journal/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/journal/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/journal/ -p wa -k audit_rules_var_log_journal\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_var_log_journal","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects records for events that affect \"/var/log/journal\" -\n    Check if watch rule for /var/log/journal/ already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/journal/\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects records for events that affect \"/var/log/journal\" -\n    Search /etc/audit/rules.d for other rules with specified key audit_rules_var_log_journal\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_var_log_journal$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects records for events that affect \"/var/log/journal\" -\n    Use /etc/audit/rules.d/audit_rules_var_log_journal.rules as the recipient for\n    the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_var_log_journal.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects records for events that affect \"/var/log/journal\" -\n    Use matched file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects records for events that affect \"/var/log/journal\" -\n    Add watch rule for /var/log/journal/ in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/journal/ -p wa -k audit_rules_var_log_journal\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects records for events that affect \"/var/log/journal\" -\n    Check if watch rule for /var/log/journal/ already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/journal/\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects records for events that affect \"/var/log/journal\" -\n    Add watch rule for /var/log/journal/ in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /var/log/journal/ -p wa -k audit_rules_var_log_journal\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654190\n  - audit_rules_var_log_journal\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260640","stig_id":"UBTU-22-654190"},"xccdf_org.ssgproject.content_rule_audit_sudo_log_events":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_sudo_log_events","title":"Record Attempts to perform maintenance activities","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.3"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000392-GPOS-00172","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.2","Req-10.2.5.b"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654235"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260649r986298_rule"]}],"description":"The Ubuntu 22.04 operating system must generate audit records for\nprivileged activities, nonlocal maintenance, diagnostic sessions and\nother system-level access.\n\nVerify the operating system audits activities performed during nonlocal\nmaintenance and diagnostic sessions. Run the following command:\n<pre>$ sudo auditctl -l | grep sudo.log\n-w /var/log/sudo.log -p wa -k maintenance</pre>\n\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /var/log/sudo.log -p wa -k maintenance</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /var/log/sudo.log -p wa -k maintenance</pre>\n      ","rationale":"If events associated with nonlocal administrative access or diagnostic\nsessions are not logged, a major tool for assessing and investigating\nattacks would not be available.\nThis requirement addresses auditing-related issues associated with\nmaintenance tools used specifically for diagnostic and repair actions\non organizational information systems.\nNonlocal maintenance and diagnostic activities are those activities\nconducted by individuals communicating through a network, either an\nexternal network (e.g., the internet) or an internal network. Local\nmaintenance and diagnostic activities are those activities carried\nout by individuals physically present at the information system or\ninformation system component and not communicating across a network\nconnection.\nThis requirement applies to hardware/software diagnostic test\nequipment or tools. This requirement does not cover hardware/software\ncomponents that may support information system maintenance, yet are a\npart of the system, for example, the software implementing &quot;ping,&quot;\n&quot;ls,&quot; &quot;ipconfig,&quot; or the hardware and software implementing the\nmonitoring port of an Ethernet switch.","oval_definition_id":"oval:ssg-audit_sudo_log_events:def:1","remediations":[{"remediation_id":"audit_sudo_log_events","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/sudo.log\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/sudo.log $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/sudo.log$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/sudo.log -p wa -k maintenance\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/maintenance.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/sudo.log\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/maintenance.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/maintenance.rules\"\n    # If the maintenance.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/sudo.log\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/sudo.log $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/sudo.log$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/sudo.log -p wa -k maintenance\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_sudo_log_events","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to perform maintenance activities - Check if watch rule for\n    /var/log/sudo.log already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/sudo.log\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to perform maintenance activities - Search /etc/audit/rules.d\n    for other rules with specified key maintenance\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)maintenance$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to perform maintenance activities - Use /etc/audit/rules.d/maintenance.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/maintenance.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to perform maintenance activities - Use matched file as the\n    recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to perform maintenance activities - Add watch rule for /var/log/sudo.log\n    in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/sudo.log -p wa -k maintenance\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to perform maintenance activities - Check if watch rule for\n    /var/log/sudo.log already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/sudo.log\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to perform maintenance activities - Add watch rule for /var/log/sudo.log\n    in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /var/log/sudo.log -p wa -k maintenance\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654235\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260649","stig_id":"UBTU-22-654235"},"xccdf_org.ssgproject.content_rule_directory_permissions_var_log_audit":{"rule_id":"xccdf_org.ssgproject.content_rule_directory_permissions_var_log_audit","title":"System Audit Logs Must Have Mode 0750 or Less Permissive","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.4"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","18","19","3","4","5","6","7","8"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","APO11.04","APO12.06","BAI03.05","BAI08.02","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS05.04","DSS05.07","DSS06.02","MEA02.01"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.3.3.9","4.3.3.5.8","4.3.3.7.3","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 5.2","SR 6.1"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.16.1.4","A.16.1.5","A.16.1.7","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R5.1.1","CIP-003-8 R5.2","CIP-003-8 R5.3","CIP-004-6 R2.3","CIP-004-6 R3.3","CIP-007-3 R2.1","CIP-007-3 R2.2","CIP-007-3 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.1","CIP-007-3 R5.1.2","CIP-007-3 R6.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","AU-9","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","PR.AC-4","PR.DS-5","PR.PT-1","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000057-GPOS-00027","SRG-OS-000058-GPOS-00028","SRG-OS-000059-GPOS-00029"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653060"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260600r958438_rule"]}],"description":"\nIf <code>log_group</code> in <code>/etc/audit/auditd.conf</code> is set to a group other than the <code>root</code>\ngroup account, change the mode of the audit log files with the following command:\n<pre>$ sudo chmod 0750 /var/log/audit</pre>\n       <br>\nOtherwise, change the mode of the audit log files with the following command:\n<pre>$ sudo chmod 0700 /var/log/audit</pre>\n      ","rationale":"If users can write to audit logs, audit trails can be modified or destroyed.","oval_definition_id":"oval:ssg-directory_permissions_var_log_audit:def:1","remediations":[{"remediation_id":"directory_permissions_var_log_audit","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif LC_ALL=C grep -iw ^log_file /etc/audit/auditd.conf; then\n  DIR=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ' | rev | cut -d\"/\" -f2- | rev)\nelse\n  DIR=\"/var/log/audit\"\nfi\n\n\nif LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then\n  GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\n  if ! [ \"${GROUP}\" == 'root' ] ; then\n    chmod 0750 $DIR\n  else\n    chmod 0700 $DIR\n  fi\nelse\n  chmod 0700 $DIR\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260600","stig_id":"UBTU-22-653060"},"xccdf_org.ssgproject.content_rule_file_group_ownership_var_log_audit_stig":{"rule_id":"xccdf_org.ssgproject.content_rule_file_group_ownership_var_log_audit_stig","title":"System Audit Logs Must Be Group Owned By Root","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000057-GPOS-00027","SRG-OS-000058-GPOS-00028","SRG-OS-000059-GPOS-00029","SRG-OS-000206-GPOS-00084"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653055"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260599r958434_rule"]}],"description":"All audit logs must be group owned by root user.\n\nDetermine where the audit logs are stored with the following command:\n<pre>$ sudo grep -iw log_file /etc/audit/auditd.conf\nlog_file = /var/log/audit/audit.log</pre>\n\nUsing the path of the directory containing the audit logs, determine if the audit log files\nare owned by the &quot;root&quot; group by using the following command:\n<pre>$ sudo stat -c &quot;%n %G&quot; /var/log/audit/*\n/var/log/audit/audit.log root</pre>\nIf the audit log files are owned by a group other than &quot;root&quot;, this is a finding.\n\nTo remediate, configure the audit log directory and its underlying files to be owned by &quot;root&quot;\ngroup.\n\nSet the &quot;log_group&quot; parameter of the audit configuration file to the &quot;root&quot; value so when a\nnew log file is created, its group owner is properly set:\n<pre>$ sudo sed -i &#x27;/^log_group/D&#x27; /etc/audit/auditd.conf\n$ sudo sed -i /^log_file/a&#x27;log_group = root&#x27; /etc/audit/auditd.conf</pre>\n\nLast, signal the audit daemon to reload the configuration file to update the group owners\nof existing files:\n<pre>$ sudo systemctl kill auditd -s SIGHUP</pre>\n      ","rationale":"Unauthorized disclosure of audit records can reveal system and configuration data to\nattackers, thus compromising its confidentiality.","oval_definition_id":"oval:ssg-file_group_ownership_var_log_audit_stig:def:1","remediations":[{"remediation_id":"file_group_ownership_var_log_audit_stig","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif LC_ALL=C grep -iw log_file /etc/audit/auditd.conf; then\n  FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\nelse\n  FILE=\"/var/log/audit/audit.log\"\nfi\n\nif [ -e \"/etc/audit/auditd.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*log_group\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\"\nelse\n    touch \"/etc/audit/auditd.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/audit/auditd.conf\"\n\ncp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"log_group = root\" >> \"/etc/audit/auditd.conf\"\n# Clean up after ourselves.\nrm \"/etc/audit/auditd.conf.bak\"\n\nchgrp root $FILE\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260599","stig_id":"UBTU-22-653055"},"xccdf_org.ssgproject.content_rule_file_groupownership_audit_configuration":{"rule_id":"xccdf_org.ssgproject.content_rule_file_groupownership_audit_configuration","title":"Audit Configuration Files Must Be Owned By Group root","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.7"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000063-GPOS-00032"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653075"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260603r958444_rule"]}],"description":"All audit configuration files must be owned by group root.\n<pre>chown :root /etc/audit/audit*.{rules,conf} /etc/audit/rules.d/*</pre>\n      ","rationale":"Without the capability to restrict which roles and individuals can\nselect which events are audited, unauthorized personnel may be able\nto prevent the auditing of critical events.\nMisconfigured audits may degrade the system&#x27;s performance by\noverwhelming the audit log. Misconfigured audits may also make it more\ndifficult to establish, correlate, and investigate the events relating\nto an incident or identify those responsible for one.","oval_definition_id":"oval:ssg-file_groupownership_audit_configuration:def:1","remediations":[{"remediation_id":"file_groupownership_audit_configuration","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nnewgroup=\"\"\nif getent group \"0\" >/dev/null 2>&1; then\n  newgroup=\"0\"\nfi\n\nif [[ -z \"${newgroup}\" ]]; then\n  >&2 echo \"0 is not a defined group on the system\"\nelse\nfind -P /etc/audit/ -maxdepth 1 -type f  ! -group 0 -regextype posix-extended -regex '^.*audit(\\.rules|d\\.conf)$' -exec chgrp --no-dereference \"$newgroup\" {} \\;\nfind -P /etc/audit/rules.d/ -maxdepth 1 -type f  ! -group 0 -regextype posix-extended -regex '^.*\\.rules$' -exec chgrp --no-dereference \"$newgroup\" {} \\;\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_groupownership_audit_configuration","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653075\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_groupownership_audit_configuration_newgroup variable if represented\n    by gid\n  ansible.builtin.set_fact:\n    file_groupownership_audit_configuration_newgroup: '0'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653075\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  ansible.builtin.command: find -P /etc/audit/ -maxdepth 1 -type f  ! -group 0 -regextype\n    posix-extended -regex \"^.*audit(\\.rules|d\\.conf)$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653075\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    group: '{{ file_groupownership_audit_configuration_newgroup }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653075\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  ansible.builtin.command: find -P /etc/audit/rules.d/ -maxdepth 1 -type f  ! -group\n    0 -regextype posix-extended -regex \"^.*\\.rules$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653075\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    group: '{{ file_groupownership_audit_configuration_newgroup }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653075\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260603","stig_id":"UBTU-22-653075"},"xccdf_org.ssgproject.content_rule_file_ownership_audit_configuration":{"rule_id":"xccdf_org.ssgproject.content_rule_file_ownership_audit_configuration","title":"Audit Configuration Files Must Be Owned By Root","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.6"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000063-GPOS-00032"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653070"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260602r958444_rule"]}],"description":"All audit configuration files must be owned by root user.\n\nTo properly set the owner of <code>/etc/audit/</code>, run the command:\n\n  <pre>$ sudo chown root /etc/audit/ </pre>\n  \n\n\nTo properly set the owner of <code>/etc/audit/rules.d/</code>, run the command:\n\n  <pre>$ sudo chown root /etc/audit/rules.d/ </pre>\n      ","rationale":"Without the capability to restrict which roles and individuals can\nselect which events are audited, unauthorized personnel may be able\nto prevent the auditing of critical events.\nMisconfigured audits may degrade the system&#x27;s performance by\noverwhelming the audit log. Misconfigured audits may also make it more\ndifficult to establish, correlate, and investigate the events relating\nto an incident or identify those responsible for one.","oval_definition_id":"oval:ssg-file_ownership_audit_configuration:def:1","remediations":[{"remediation_id":"file_ownership_audit_configuration","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nnewown=\"\"\nif id \"0\" >/dev/null 2>&1; then\n  newown=\"0\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"0 is not a defined user on the system\"\nelse\n\nfind -P /etc/audit/ -maxdepth 1 -type f  ! -user 0 -regextype posix-extended -regex '^.*audit(\\.rules|d\\.conf)$' -exec chown --no-dereference \"$newown\" {} \\;\n\nfind -P /etc/audit/rules.d/ -maxdepth 1 -type f  ! -user 0 -regextype posix-extended -regex '^.*\\.rules$' -exec chown --no-dereference \"$newown\" {} \\;\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_ownership_audit_configuration","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653070\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_ownership_audit_configuration_newown variable if represented\n    by uid\n  ansible.builtin.set_fact:\n    file_ownership_audit_configuration_newown: '0'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653070\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  ansible.builtin.command: find -P /etc/audit/ -maxdepth 1 -type f  ! -user 0 -regextype\n    posix-extended -regex \"^.*audit(\\.rules|d\\.conf)$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653070\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_ownership_audit_configuration_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653070\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  ansible.builtin.command: find -P /etc/audit/rules.d/ -maxdepth 1 -type f  ! -user\n    0 -regextype posix-extended -regex \"^.*\\.rules$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653070\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  ansible.builtin.file:\n    path: '{{ item }}'\n    follow: false\n    owner: '{{ file_ownership_audit_configuration_newown }}'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653070\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260602","stig_id":"UBTU-22-653070"},"xccdf_org.ssgproject.content_rule_file_ownership_var_log_audit_stig":{"rule_id":"xccdf_org.ssgproject.content_rule_file_ownership_var_log_audit_stig","title":"System Audit Logs Must Be Owned By Root","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.2"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","18","19","3","4","5","6","7","8"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO01.06","APO11.04","APO12.06","BAI03.05","BAI08.02","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS05.04","DSS05.07","DSS06.02","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.3.1"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.3.3.9","4.3.3.5.8","4.3.3.7.3","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.1","SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 5.2","SR 6.1"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.10.1.1","A.11.1.4","A.11.1.5","A.11.2.1","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.1.3","A.13.2.1","A.13.2.3","A.13.2.4","A.14.1.2","A.14.1.3","A.16.1.4","A.16.1.5","A.16.1.7","A.6.1.2","A.7.1.1","A.7.1.2","A.7.3.1","A.8.2.2","A.8.2.3","A.9.1.1","A.9.1.2","A.9.2.3","A.9.4.1","A.9.4.4","A.9.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(1)","AU-9(4)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","PR.AC-4","PR.DS-5","PR.PT-1","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000057-GPOS-00027","SRG-OS-000058-GPOS-00028","SRG-OS-000059-GPOS-00029","SRG-OS-000206-GPOS-00084"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653050"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260598r958434_rule"]}],"description":"All audit logs must be owned by root user. The path for audit log can be\nconfigured via <code>log_file</code> parameter in <pre>/etc/audit/auditd.conf</pre>\nor by default, the path for audit log is <pre>/var/log/audit/</pre>.\n\nTo properly set the owner of <code>/var/log/audit/*</code>, run the command:\n\n  <pre>$ sudo chown root /var/log/audit/* </pre>\n      ","rationale":"Unauthorized disclosure of audit records can reveal system and configuration data to\nattackers, thus compromising its confidentiality.","oval_definition_id":"oval:ssg-file_ownership_var_log_audit_stig:def:1","remediations":[{"remediation_id":"file_ownership_var_log_audit_stig","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif LC_ALL=C grep -iw log_file /etc/audit/auditd.conf; then\n    FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\n    chown root $FILE*\nelse\n    chown root /var/log/audit/audit.log*\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260598","stig_id":"UBTU-22-653050"},"xccdf_org.ssgproject.content_rule_file_permissions_var_log_audit_stig":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_var_log_audit_stig","title":"System Audit Logs Must Have Mode 0600 or Less Permissive","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000057-GPOS-00027","SRG-OS-000058-GPOS-00028"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260597r958434_rule"]}],"description":"Determine where the audit logs are stored with the following command:\n<pre>$ sudo grep -iw log_file /etc/audit/auditd.conf\nlog_file = /var/log/audit/audit.log</pre>\n\nUsing the path of the directory containing the audit logs, determine\nif the audit log files have a mode of &quot;600&quot; or less by using the following command:\n<pre>$ sudo stat -c &quot;%n %a&quot; /var/log/audit/*</pre>\n      ","rationale":"If users can write to audit logs, audit trails can be modified or destroyed.","oval_definition_id":"oval:ssg-file_permissions_var_log_audit_stig:def:1","remediations":[{"remediation_id":"file_permissions_var_log_audit_stig","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nif LC_ALL=C grep -iqw ^log_file /etc/audit/auditd.conf; then\n    FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\nelse\n    FILE=\"/var/log/audit/audit.log\"\nfi\n\nchmod 0600 -- \"$(dirname \"$FILE\")\"/*\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260597","stig_id":"UBTU-22-653045"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod","title":"Record Events that Modify the System's Discretionary Access Controls - chmod","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654155"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260633r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.  Here the system calls\nhave been placed independent of other system calls.  Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_chmod:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_chmod","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"chmod\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_chmod","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit chmod tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chmod for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chmod for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260633","stig_id":"UBTU-22-654155"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown","title":"Record Events that Modify the System's Discretionary Access Controls - chown","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654160"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260634r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.  Here the system calls\nhave been placed independent of other system calls.  Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_chown:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_chown","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"chown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_chown","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit chown tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chown for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chown for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260634","stig_id":"UBTU-22-654160"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod","title":"Record Events that Modify the System's Discretionary Access Controls - fchmod","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654155"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260633r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_fchmod:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_fchmod","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchmod\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_fchmod","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchmod tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmod for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmod for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260633","stig_id":"UBTU-22-654155"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat","title":"Record Events that Modify the System's Discretionary Access Controls - fchmodat","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654155"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260633r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_fchmodat:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_fchmodat","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchmodat\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_fchmodat","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchmodat tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmodat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmodat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260633","stig_id":"UBTU-22-654155"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown","title":"Record Events that Modify the System's Discretionary Access Controls - fchown","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654160"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260634r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_fchown:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_fchown","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_fchown","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchown tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchown for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchown for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260634","stig_id":"UBTU-22-654160"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat","title":"Record Events that Modify the System's Discretionary Access Controls - fchownat","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654160"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260634r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_fchownat:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_fchownat","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchownat\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_fchownat","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchownat tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchownat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchownat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260634","stig_id":"UBTU-22-654160"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr","title":"Record Events that Modify the System's Discretionary Access Controls - fremovexattr","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000496-CTR-001240","SRG-APP-000497-CTR-001245","SRG-APP-000498-CTR-001250","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000463-GPOS-00207","SRG-OS-000466-GPOS-00210","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654180"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260638r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br>\n        <br>\nIf the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_fremovexattr:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_fremovexattr","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"fremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_fremovexattr","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fremovexattr tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fremovexattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fremovexattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260638","stig_id":"UBTU-22-654180"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr","title":"Record Events that Modify the System's Discretionary Access Controls - fsetxattr","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000496-CTR-001240","SRG-APP-000497-CTR-001245","SRG-APP-000498-CTR-001250","SRG-APP-000500-CTR-001260","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000463-GPOS-00207","SRG-OS-000466-GPOS-00210","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654180"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260638r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_fsetxattr:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_fsetxattr","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"fsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_fsetxattr","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fsetxattr tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fsetxattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fsetxattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260638","stig_id":"UBTU-22-654180"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown","title":"Record Events that Modify the System's Discretionary Access Controls - lchown","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654160"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260634r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_lchown:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_lchown","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lchown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_lchown","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lchown tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lchown for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lchown for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654160\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260634","stig_id":"UBTU-22-654160"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr","title":"Record Events that Modify the System's Discretionary Access Controls - lremovexattr","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000496-CTR-001240","SRG-APP-000497-CTR-001245","SRG-APP-000498-CTR-001250","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000463-GPOS-00207","SRG-OS-000466-GPOS-00210","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654180"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260638r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br>\n        <br>\nIf the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_lremovexattr:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_lremovexattr","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"lremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_lremovexattr","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lremovexattr tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lremovexattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lremovexattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260638","stig_id":"UBTU-22-654180"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr","title":"Record Events that Modify the System's Discretionary Access Controls - lsetxattr","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000496-CTR-001240","SRG-APP-000497-CTR-001245","SRG-APP-000498-CTR-001250","SRG-APP-000500-CTR-001260","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000463-GPOS-00207","SRG-OS-000466-GPOS-00210","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654180"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260638r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_lsetxattr:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_lsetxattr","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"lsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_lsetxattr","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lsetxattr tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lsetxattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lsetxattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260638","stig_id":"UBTU-22-654180"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr","title":"Record Events that Modify the System's Discretionary Access Controls - removexattr","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000496-CTR-001240","SRG-APP-000497-CTR-001245","SRG-APP-000498-CTR-001250","SRG-APP-000499-CTR-001255","SRG-APP-000500-CTR-001260","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000463-GPOS-00207","SRG-OS-000466-GPOS-00210","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215","SRG-OS-000474-GPOS-00219"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654180"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260638r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing line to a file with suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_removexattr:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_removexattr","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"removexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"removexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_removexattr","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit removexattr tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for removexattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for removexattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260638","stig_id":"UBTU-22-654180"},"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr","title":"Record Events that Modify the System's Discretionary Access Controls - setxattr","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000091-CTR-000160","SRG-APP-000492-CTR-001220","SRG-APP-000493-CTR-001225","SRG-APP-000494-CTR-001230","SRG-APP-000495-CTR-001235","SRG-APP-000500-CTR-001260","SRG-APP-000507-CTR-001295"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.9"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.5.5"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.3","10.3.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654180"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260638r958446_rule"]}],"description":"At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre>\n       ","rationale":"The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_dac_modification_setxattr:def:1","remediations":[{"remediation_id":"audit_rules_dac_modification_setxattr","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"setxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"setxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_dac_modification_setxattr","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit setxattr tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for setxattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for setxattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-22-654180\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260638","stig_id":"UBTU-22-654180"},"xccdf_org.ssgproject.content_rule_audit_rules_execution_chacl":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_execution_chacl","title":"Record Any Attempts to Run chacl","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.17"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654015"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260605r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).","oval_definition_id":"oval:ssg-audit_rules_execution_chacl:def:1","remediations":[{"remediation_id":"audit_rules_execution_chacl","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/chacl -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_execution_chacl","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654015\n  - audit_rules_execution_chacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Any Attempts to Run chacl - Perform remediation of Audit rules for\n    /usr/bin/chacl\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chacl -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654015\n  - audit_rules_execution_chacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260605","stig_id":"UBTU-22-654015"},"xccdf_org.ssgproject.content_rule_audit_rules_execution_setfacl":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_execution_setfacl","title":"Record Any Attempts to Run setfacl","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.16"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654085"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260619r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).","oval_definition_id":"oval:ssg-audit_rules_execution_setfacl:def:1","remediations":[{"remediation_id":"audit_rules_execution_setfacl","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/setfacl -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_execution_setfacl","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654085\n  - audit_rules_execution_setfacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Any Attempts to Run setfacl - Perform remediation of Audit rules for\n    /usr/bin/setfacl\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/setfacl -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654085\n  - audit_rules_execution_setfacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260619","stig_id":"UBTU-22-654085"},"xccdf_org.ssgproject.content_rule_audit_rules_execution_chcon":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_execution_chcon","title":"Record Any Attempts to Run chcon","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000496-CTR-001240","SRG-APP-000497-CTR-001245","SRG-APP-000498-CTR-001250","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.15"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000463-GPOS-00207","SRG-OS-000465-GPOS-00209","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260607r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_execution_chcon:def:1","remediations":[{"remediation_id":"audit_rules_execution_chcon","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/chcon -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_execution_chcon","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654025\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_execution_chcon\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Any Attempts to Run chcon - Perform remediation of Audit rules for\n    /usr/bin/chcon\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chcon -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654025\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_execution_chcon\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260607","stig_id":"UBTU-22-654025"},"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename","title":"Ensure auditd Collects File Deletion Events by User - rename","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.13"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.1.1","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.MA-2","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000467-GPOS-00211","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654185"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260639r991577_rule"]}],"description":"At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ","rationale":"Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.","platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_file_deletion_events_rename:def:1","remediations":[{"remediation_id":"audit_rules_file_deletion_events_rename","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"rename\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat renameat2 rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_file_deletion_events_rename","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit rename tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rename for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rename for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260639","stig_id":"UBTU-22-654185"},"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat","title":"Ensure auditd Collects File Deletion Events by User - renameat","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.13"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.1.1","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.MA-2","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000467-GPOS-00211","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654185"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260639r991577_rule"]}],"description":"At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ","rationale":"Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.","oval_definition_id":"oval:ssg-audit_rules_file_deletion_events_renameat:def:1","remediations":[{"remediation_id":"audit_rules_file_deletion_events_renameat","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"renameat\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat renameat2 rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_file_deletion_events_renameat","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit renameat tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for renameat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for renameat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260639","stig_id":"UBTU-22-654185"},"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rmdir":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rmdir","title":"Ensure auditd Collects File Deletion Events by User - rmdir","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.1.1","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.MA-2","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000467-GPOS-00211","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654185"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260639r991577_rule"]}],"description":"At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ","rationale":"Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.","platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_file_deletion_events_rmdir:def:1","remediations":[{"remediation_id":"audit_rules_file_deletion_events_rmdir","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"rmdir\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat renameat2 rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_file_deletion_events_rmdir","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit rmdir tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rmdir for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rmdir for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260639","stig_id":"UBTU-22-654185"},"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink","title":"Ensure auditd Collects File Deletion Events by User - unlink","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.13"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.1.1","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.MA-2","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000467-GPOS-00211","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654185"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260639r991577_rule"]}],"description":"At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ","rationale":"Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.","platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_file_deletion_events_unlink:def:1","remediations":[{"remediation_id":"audit_rules_file_deletion_events_unlink","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"unlink\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat renameat2 rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_file_deletion_events_unlink","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit unlink tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlink for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlink for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260639","stig_id":"UBTU-22-654185"},"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat","title":"Ensure auditd Collects File Deletion Events by User - unlinkat","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.13"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.5","4.3.3.6.6","4.3.3.6.7","4.3.3.6.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.4","A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.1.1","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.MA-2","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000467-GPOS-00211","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654185"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260639r991577_rule"]}],"description":"At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 for 32-bit\nsystem, or having two lines for both b32 and b64 in case your system is 64-bit:\n<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ","rationale":"Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.","oval_definition_id":"oval:ssg-audit_rules_file_deletion_events_unlinkat:def:1","remediations":[{"remediation_id":"audit_rules_file_deletion_events_unlinkat","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"unlinkat\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat renameat2 rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_file_deletion_events_unlinkat","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit unlinkat tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlinkat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlinkat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - renameat2\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654185\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260639","stig_id":"UBTU-22-654185"},"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat","title":"Record Unsuccessful Access Attempts to Files - creat","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.7"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000461-GPOS-00205","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.1","Req-10.2.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654165"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260635r958446_rule"]}],"description":"At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ","rationale":"Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_unsuccessful_file_modification_creat:def:1","remediations":[{"remediation_id":"audit_rules_unsuccessful_file_modification_creat","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"creat\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_unsuccessful_file_modification_creat","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit creat tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260635","stig_id":"UBTU-22-654165"},"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate","title":"Record Unsuccessful Access Attempts to Files - ftruncate","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.7"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000461-GPOS-00205","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.1","Req-10.2.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654165"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260635r958446_rule"]}],"description":"At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ","rationale":"Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_unsuccessful_file_modification_ftruncate:def:1","remediations":[{"remediation_id":"audit_rules_unsuccessful_file_modification_ftruncate","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"ftruncate\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_unsuccessful_file_modification_ftruncate","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit ftruncate tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260635","stig_id":"UBTU-22-654165"},"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open","title":"Record Unsuccessful Access Attempts to Files - open","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.7"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000461-GPOS-00205","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.1","Req-10.2.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654165"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260635r958446_rule"]}],"description":"At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ","rationale":"Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"platforms":["#not_aarch64_arch"],"oval_definition_id":"oval:ssg-audit_rules_unsuccessful_file_modification_open:def:1","remediations":[{"remediation_id":"audit_rules_unsuccessful_file_modification_open","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$' && { ! ( ( grep -sqE \"^.*\\.aarch64$\" /proc/sys/kernel/osrelease || grep -sqE \"^aarch64$\" /proc/sys/kernel/arch; ) ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"open\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_unsuccessful_file_modification_open","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit open tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260635","stig_id":"UBTU-22-654165"},"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at","title":"Record Unsuccessful Access Attempts to Files - open_by_handle_at","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000461-GPOS-00205","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.1","Req-10.2.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654165"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260635r958446_rule"]}],"description":"At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ","rationale":"Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_unsuccessful_file_modification_open_by_handle_at:def:1","remediations":[{"remediation_id":"audit_rules_unsuccessful_file_modification_open_by_handle_at","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"open_by_handle_at\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_unsuccessful_file_modification_open_by_handle_at","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit open_by_handle_at tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EACCES for 32bit\n    platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EACCES for 64bit\n    platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260635","stig_id":"UBTU-22-654165"},"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat","title":"Record Unsuccessful Access Attempts to Files - openat","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.7"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000461-GPOS-00205","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.1","Req-10.2.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654165"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260635r958446_rule"]}],"description":"At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ","rationale":"Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_unsuccessful_file_modification_openat:def:1","remediations":[{"remediation_id":"audit_rules_unsuccessful_file_modification_openat","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"openat\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_unsuccessful_file_modification_openat","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit openat tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260635","stig_id":"UBTU-22-654165"},"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate","title":"Record Unsuccessful Access Attempts to Files - truncate","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.7"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000458-GPOS-00203","SRG-OS-000461-GPOS-00205","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.1","Req-10.2.4"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654165"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260635r958446_rule"]}],"description":"At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ","rationale":"Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.","warnings":[{"text":"Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.","category":"general"}],"oval_definition_id":"oval:ssg-audit_rules_unsuccessful_file_modification_truncate:def:1","remediations":[{"remediation_id":"audit_rules_unsuccessful_file_modification_truncate","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"truncate\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_unsuccessful_file_modification_truncate","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit truncate tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"}],"vuln_id":"SV-260635","stig_id":"UBTU-22-654165"},"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete","title":"Ensure auditd Collects Information on Kernel Module Unloading - delete_module","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000504-CTR-001280"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.19"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215","SRG-OS-000471-GPOS-00216","SRG-OS-000477-GPOS-00222"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654170"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260636r958446_rule"]}],"description":"To capture kernel module unloading events, use following line, setting ARCH to\neither b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S delete_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n\n\nPlace to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured\nto use the <code>augenrules</code> program (the default), add the line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,\nadd the line to file <code>/etc/audit/audit.rules</code>.","rationale":"The removal of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.","oval_definition_id":"oval:ssg-audit_rules_kernel_module_loading_delete:def:1","remediations":[{"remediation_id":"audit_rules_kernel_module_loading_delete","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\t\n\tSYSCALL=\"delete_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"delete_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_kernel_module_loading_delete","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654170\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit delete_module tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654170\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for delete_module for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654170\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for delete_module for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654170\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260636","stig_id":"UBTU-22-654170"},"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit","title":"Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000504-CTR-001280"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215","SRG-OS-000471-GPOS-00216","SRG-OS-000477-GPOS-00222"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654175"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260637r958446_rule"]}],"description":"If the <code>auditd</code> daemon is configured to use the <code>augenrules</code> program\nto read audit rules during daemon startup (the default), add the following lines to a file\nwith suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code> to capture kernel module\nloading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n    If the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility to read audit\nrules during daemon startup, add the following lines to <code>/etc/audit/audit.rules</code> file\nin order to capture kernel module loading and unloading events, setting ARCH to either b32 or\nb64 as appropriate for your system:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n       ","rationale":"The addition/removal of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.","oval_definition_id":"oval:ssg-audit_rules_kernel_module_loading_finit:def:1","remediations":[{"remediation_id":"audit_rules_kernel_module_loading_finit","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\t\n\tSYSCALL=\"finit_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"init_module finit_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_kernel_module_loading_finit","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit finit_module tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for finit_module for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for finit_module for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260637","stig_id":"UBTU-22-654175"},"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init","title":"Ensure auditd Collects Information on Kernel Module Loading - init_module","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000504-CTR-001280"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.19"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215","SRG-OS-000471-GPOS-00216","SRG-OS-000477-GPOS-00222"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654175"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260637r958446_rule"]}],"description":"To capture kernel module loading events, use following line, setting ARCH to\neither b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S init_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n\n\nPlace to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured\nto use the <code>augenrules</code> program (the default), add the line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,\nadd the line to file <code>/etc/audit/audit.rules</code>.","rationale":"The addition of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.","oval_definition_id":"oval:ssg-audit_rules_kernel_module_loading_init:def:1","remediations":[{"remediation_id":"audit_rules_kernel_module_loading_init","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\t\n\tSYSCALL=\"init_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"init_module finit_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_kernel_module_loading_init","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit init_module tasks\n  ansible.builtin.set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for init_module for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for init_module for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-22-654175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260637","stig_id":"UBTU-22-654175"},"xccdf_org.ssgproject.content_rule_audit_rules_login_events_faillog":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_login_events_faillog","title":"Record Attempts to Alter Logon and Logout Events - faillog","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654210"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260644r958446_rule"]}],"description":"The audit system already collects login information for all users\nand root.\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /var/log/faillog -p wa -k logins</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /var/log/faillog -p wa -k logins</pre>\n       ","rationale":"Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.","oval_definition_id":"oval:ssg-audit_rules_login_events_faillog:def:1","remediations":[{"remediation_id":"audit_rules_login_events_faillog","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/faillog\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/faillog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/faillog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/faillog -p wa -k logins\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/faillog\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/faillog\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/faillog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/faillog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/faillog -p wa -k logins\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_login_events_faillog","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - faillog - Check if watch\n    rule for /var/log/faillog already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/faillog\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - faillog - Search /etc/audit/rules.d\n    for other rules with specified key logins\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)logins$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - faillog - Use /etc/audit/rules.d/logins.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/logins.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - faillog - Use matched file\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - faillog - Add watch rule\n    for /var/log/faillog in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/faillog -p wa -k logins\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - faillog - Check if watch\n    rule for /var/log/faillog already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/faillog\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - faillog - Add watch rule\n    for /var/log/faillog in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /var/log/faillog -p wa -k logins\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654210\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260644","stig_id":"UBTU-22-654210"},"xccdf_org.ssgproject.content_rule_audit_rules_login_events_lastlog":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_login_events_lastlog","title":"Record Attempts to Alter Logon and Logout Events - lastlog","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000503-CTR-001275","SRG-APP-000506-CTR-001290"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.12"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","APO12.06","APO13.01","BAI03.05","BAI08.02","DSS01.03","DSS01.04","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS03.05","DSS05.02","DSS05.03","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.3.6.6","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 1.13","SR 2.10","SR 2.11","SR 2.12","SR 2.6","SR 2.8","SR 2.9","SR 3.1","SR 3.5","SR 3.8","SR 4.1","SR 4.3","SR 5.1","SR 5.2","SR 5.3","SR 6.1","SR 6.2","SR 7.1","SR 7.6"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.11.2.6","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.13.1.1","A.13.2.1","A.14.1.3","A.14.2.7","A.15.2.1","A.15.2.2","A.16.1.4","A.16.1.5","A.16.1.7","A.6.2.1","A.6.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.AC-3","PR.PT-1","PR.PT-4","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000470-GPOS-00214","SRG-OS-000471-GPOS-00215","SRG-OS-000473-GPOS-00218"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.2.3"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.2","10.2.1","10.2.1.3"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654215"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260645r958446_rule"]}],"description":"The audit system already collects login information for all users\nand root.\n\n\n\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n\n<pre>-w /var/log/lastlog -p wa -k logins</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code>:\n\n<pre>-w /var/log/lastlog -p wa -k logins</pre>\n       ","rationale":"Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.","oval_definition_id":"oval:ssg-audit_rules_login_events_lastlog:def:1","remediations":[{"remediation_id":"audit_rules_login_events_lastlog","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/lastlog\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/lastlog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/lastlog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/lastlog -p wa -k logins\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/lastlog\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/lastlog\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/lastlog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/lastlog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /var/log/lastlog -p wa -k logins\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_login_events_lastlog","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - lastlog - Check if watch\n    rule for /var/log/lastlog already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/lastlog\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - lastlog - Search /etc/audit/rules.d\n    for other rules with specified key logins\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)logins$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - lastlog - Use /etc/audit/rules.d/logins.rules\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/logins.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - lastlog - Use matched file\n    as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - lastlog - Add watch rule\n    for /var/log/lastlog in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/lastlog -p wa -k logins\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - lastlog - Check if watch\n    rule for /var/log/lastlog already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/lastlog\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Attempts to Alter Logon and Logout Events - lastlog - Add watch rule\n    for /var/log/lastlog in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /var/log/lastlog -p wa -k logins\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654215\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2\n  - PCI-DSSv4-10.2.1\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260645","stig_id":"UBTU-22-654215"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_apparmor_parser":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_apparmor_parser","title":"Record Any Attempts to Run apparmor_parser","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000064-GPOS-00033"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654010"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260604r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/sbin/apparmor_parser -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/sbin/apparmor_parser -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_apparmor_parser:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_apparmor_parser","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/sbin/apparmor_parser -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_apparmor_parser","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654010\n  - audit_rules_privileged_commands_apparmor_parser\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Any Attempts to Run apparmor_parser - Perform remediation of Audit\n    rules for /sbin/apparmor_parser\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/sbin/apparmor_parser -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/sbin/apparmor_parser -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/apparmor_parser\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/sbin/apparmor_parser -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/sbin/apparmor_parser -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/apparmor_parser\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654010\n  - audit_rules_privileged_commands_apparmor_parser\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260604","stig_id":"UBTU-22-654010"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chage":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chage","title":"Ensure auditd Collects Information on the Use of Privileged Commands - chage","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235","SRG-APP-000501-CTR-001265","SRG-APP-000502-CTR-001270"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000468-GPOS-00212","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260606r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_chage:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_chage","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/chage -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_chage","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654020\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - chage\n    - Perform remediation of Audit rules for /usr/bin/chage\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chage -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chage -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chage -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654020\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260606","stig_id":"UBTU-22-654020"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chfn":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chfn","title":"Ensure auditd Collects Information on the Use of Privileged Commands - chfn","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(a)","AU-12(c)","AU-3","MA-4(1)(a)"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260608r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\n\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_chfn:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_chfn","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/chfn -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_chfn","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654030\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_chfn\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - chfn\n    - Perform remediation of Audit rules for /usr/bin/chfn\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chfn -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chfn -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chfn -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654030\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_chfn\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260608","stig_id":"UBTU-22-654030"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chsh":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chsh","title":"Ensure auditd Collects Information on the Use of Privileged Commands - chsh","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260609r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_chsh:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_chsh","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/chsh -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_chsh","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654035\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chsh\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - chsh\n    - Perform remediation of Audit rules for /usr/bin/chsh\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chsh -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chsh -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chsh -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654035\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chsh\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260609","stig_id":"UBTU-22-654035"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_crontab":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_crontab","title":"Ensure auditd Collects Information on the Use of Privileged Commands - crontab","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260610r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_crontab:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_crontab","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/crontab -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_crontab","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654040\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_crontab\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - crontab\n    - Perform remediation of Audit rules for /usr/bin/crontab\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/crontab -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/crontab -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/crontab -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654040\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_crontab\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260610","stig_id":"UBTU-22-654040"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_fdisk":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_fdisk","title":"Ensure auditd Collects Information on the Use of Privileged Commands - fdisk","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000477-GPOS-00222"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654045"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260611r991586_rule"]}],"description":"Configure the operating system to audit the execution of the partition\nmanagement program &quot;fdisk&quot;.","rationale":"Without generating audit records that are specific to the security\nand mission needs of the organization, it would be difficult to\nestablish, correlate, and investigate the events relating to an\nincident or identify those responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_fdisk:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_fdisk","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/fdisk\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/fdisk $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/fdisk$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /sbin/fdisk -p x -k modules\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/modules.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/sbin/fdisk\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/modules.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/modules.rules\"\n    # If the modules.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/fdisk\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/fdisk $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/fdisk$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /sbin/fdisk -p x -k modules\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_fdisk","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - fdisk\n    - Check if watch rule for /sbin/fdisk already exists in /etc/audit/rules.d/\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/sbin/fdisk\\s+-p\\s+x(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - fdisk\n    - Search /etc/audit/rules.d for other rules with specified key modules\n  ansible.builtin.find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)modules$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - fdisk\n    - Use /etc/audit/rules.d/modules.rules as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - /etc/audit/rules.d/modules.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - fdisk\n    - Use matched file as the recipient for the rule\n  ansible.builtin.set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - fdisk\n    - Add watch rule for /sbin/fdisk in /etc/audit/rules.d/\n  ansible.builtin.lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /sbin/fdisk -p x -k modules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - fdisk\n    - Check if watch rule for /sbin/fdisk already exists in /etc/audit/audit.rules\n  ansible.builtin.find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/sbin/fdisk\\s+-p\\s+x(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - fdisk\n    - Add watch rule for /sbin/fdisk in /etc/audit/audit.rules\n  ansible.builtin.lineinfile:\n    line: -w /sbin/fdisk -p x -k modules\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0600'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-22-654045\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260611","stig_id":"UBTU-22-654045"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_gpasswd":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_gpasswd","title":"Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654050"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260612r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_gpasswd:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_gpasswd","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/gpasswd -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_gpasswd","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654050\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_gpasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd\n    - Perform remediation of Audit rules for /usr/bin/gpasswd\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/gpasswd -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/gpasswd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/gpasswd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654050\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_gpasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260612","stig_id":"UBTU-22-654050"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_kmod":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_kmod","title":"Ensure auditd Collects Information on the Use of Privileged Commands - kmod","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000504-CTR-001280"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(a)","AU-12.1(ii)","AU-12.1(iv)AU-12(c)","AU-3","AU-3.1","MA-4(1)(a)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215","SRG-OS-000471-GPOS-00216","SRG-OS-000477-GPOS-00222"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654055"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260613r991586_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\n\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_kmod:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_kmod","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/kmod -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_kmod","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654055\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12.1(ii)\n  - NIST-800-53-AU-12.1(iv)AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-AU-3.1\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_kmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - kmod\n    - Perform remediation of Audit rules for /usr/bin/kmod\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/kmod -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/kmod -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/kmod -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654055\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12.1(ii)\n  - NIST-800-53-AU-12.1(iv)AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-AU-3.1\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_kmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260613","stig_id":"UBTU-22-654055"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_modprobe":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_modprobe","title":"Ensure auditd Collects Information on the Use of Privileged Commands - modprobe","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R73"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.19"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(a)","AU-12(c)","AU-12.1(ii)","AU-12.1(iv)","AU-3","AU-3.1","MA-4(1)(a)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654060"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260614r991586_rule"]}],"description":"At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-w /sbin/modprobe -p x -k modules</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-w /sbin/modprobe -p x -k modules</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_modprobe:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_modprobe","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/modprobe\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/modprobe $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/modprobe$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /sbin/modprobe -p x -k modules\" >> \"$audit_rules_file\"\n\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/modules.rules' to list of files for inspection.\n\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/sbin/modprobe\" /etc/audit/rules.d/*.rules)\n\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/modules.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/modules.rules\"\n    # If the modules.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0600 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/modprobe\" \"$audit_rules_file\"\n\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/modprobe $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/modprobe$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n\n        echo \"-w /sbin/modprobe -p x -k modules\" >> \"$audit_rules_file\"\n\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260614","stig_id":"UBTU-22-654060"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_mount":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_mount","title":"Ensure auditd Collects Information on the Use of Privileged Commands - mount","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654065"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260615r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_mount:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_mount","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/mount -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_mount","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654065\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_mount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - mount\n    - Perform remediation of Audit rules for /usr/bin/mount\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/mount -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/mount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/mount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654065\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_mount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260615","stig_id":"UBTU-22-654065"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_newgrp":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_newgrp","title":"Ensure auditd Collects Information on the Use of Privileged Commands - newgrp","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654070"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260616r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_newgrp:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_newgrp","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/newgrp -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_newgrp","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654070\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_newgrp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - newgrp\n    - Perform remediation of Audit rules for /usr/bin/newgrp\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/newgrp -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/newgrp -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/newgrp -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654070\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_newgrp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260616","stig_id":"UBTU-22-654070"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_pam_timestamp_check":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_pam_timestamp_check","title":"Ensure auditd Collects Information on the Use of Privileged Commands - pam_timestamp_check","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654075"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260617r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_pam_timestamp_check:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_pam_timestamp_check","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/sbin/pam_timestamp_check -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_pam_timestamp_check","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654075\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_pam_timestamp_check\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - pam_timestamp_check\n    - Perform remediation of Audit rules for /usr/sbin/pam_timestamp_check\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=unset\n        (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/sbin/pam_timestamp_check\n        -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/pam_timestamp_check\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=unset\n        (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000\n        -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/pam_timestamp_check\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654075\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_pam_timestamp_check\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260617","stig_id":"UBTU-22-654075"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_passwd":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_passwd","title":"Ensure auditd Collects Information on the Use of Privileged Commands - passwd","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-004-6 R2.2.2","CIP-004-6 R2.2.3","CIP-007-3 R.1.3","CIP-007-3 R5","CIP-007-3 R5.1.1","CIP-007-3 R5.1.3","CIP-007-3 R5.2.1","CIP-007-3 R5.2.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-2(4)","AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654080"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260618r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_passwd:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_passwd","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/passwd -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_passwd","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654080\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - passwd\n    - Perform remediation of Audit rules for /usr/bin/passwd\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/passwd -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/passwd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/passwd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654080\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260618","stig_id":"UBTU-22-654080"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_agent":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_agent","title":"Record Any Attempts to Run ssh-agent","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654090"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260620r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\n\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_ssh_agent:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_ssh_agent","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/ssh-agent -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_ssh_agent","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654090\n  - audit_rules_privileged_commands_ssh_agent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Record Any Attempts to Run ssh-agent - Perform remediation of Audit rules\n    for /usr/bin/ssh-agent\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/ssh-agent -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/ssh-agent -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/ssh-agent -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654090\n  - audit_rules_privileged_commands_ssh_agent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260620","stig_id":"UBTU-22-654090"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_keysign":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_keysign","title":"Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654095"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260621r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_ssh_keysign:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_ssh_keysign","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/lib/openssh/ssh-keysign -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_ssh_keysign","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654095\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_ssh_keysign\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign\n    - Perform remediation of Audit rules for /usr/lib/openssh/ssh-keysign\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/lib/openssh/ssh-keysign\n        -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/lib/openssh/ssh-keysign\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid>=1000\n        -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/lib/openssh/ssh-keysign\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654095\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_ssh_keysign\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260621","stig_id":"UBTU-22-654095"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_su":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_su","title":"Ensure auditd Collects Information on the Use of Privileged Commands - su","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215","SRG-OS-000755-GPOS-00220"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654100"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260622r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_su:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_su","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/su -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_su","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_su\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - su\n    - Perform remediation of Audit rules for /usr/bin/su\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/su -F perm=x -F auid>=1000\n        -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/su -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/su -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_su\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260622","stig_id":"UBTU-22-654100"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudo":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudo","title":"Ensure auditd Collects Information on the Use of Privileged Commands - sudo","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"anssi","href":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","ref_ids":["R33"]},{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085","SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215","SRG-OS-000755-GPOS-00220"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654105"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260623r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_sudo:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_sudo","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/sudo -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_sudo","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654105\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudo\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - sudo\n    - Perform remediation of Audit rules for /usr/bin/sudo\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/sudo -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudo -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudo -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654105\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudo\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260623","stig_id":"UBTU-22-654105"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudoedit":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudoedit","title":"Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215","SRG-OS-000755-GPOS-00220"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654110"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260624r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_sudoedit:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_sudoedit","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/sudoedit -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_sudoedit","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654110\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudoedit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit\n    - Perform remediation of Audit rules for /usr/bin/sudoedit\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/sudoedit -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudoedit -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudoedit -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654110\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudoedit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260624","stig_id":"UBTU-22-654110"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_umount":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_umount","title":"Ensure auditd Collects Information on the Use of Privileged Commands - umount","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000029-CTR-000085"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.6"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","12","13","14","15","16","2","3","5","6","7","8","9"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO10.01","APO10.03","APO10.04","APO10.05","APO11.04","BAI03.05","DSS01.03","DSS03.05","DSS05.02","DSS05.04","DSS05.05","DSS05.07","MEA01.01","MEA01.02","MEA01.03","MEA01.04","MEA01.05","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.1.7"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.308(a)(1)(ii)(D)","164.308(a)(3)(ii)(A)","164.308(a)(5)(ii)(C)","164.312(a)(2)(i)","164.312(b)","164.312(d)","164.312(e)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.3.2.6.7","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 6.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.14.2.7","A.15.2.1","A.15.2.2"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AC-6(9)","AU-12(c)","AU-2(d)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.CM-1","DE.CM-3","DE.CM-7","ID.SC-4","PR.PT-1"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654115"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260625r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_umount:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_umount","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/bin/umount -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_umount","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654115\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_umount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - umount\n    - Perform remediation of Audit rules for /usr/bin/umount\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/umount -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/umount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/umount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654115\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_umount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260625","stig_id":"UBTU-22-654115"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_update":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_update","title":"Ensure auditd Collects Information on the Use of Privileged Commands - unix_update","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000064-GPOS-00033","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654120"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260626r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_unix_update:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_unix_update","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/sbin/unix_update -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_unix_update","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654120\n  - audit_rules_privileged_commands_unix_update\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - unix_update\n    - Perform remediation of Audit rules for /usr/sbin/unix_update\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/sbin/unix_update -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/unix_update\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/unix_update\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654120\n  - audit_rules_privileged_commands_unix_update\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260626","stig_id":"UBTU-22-654120"},"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_usermod":{"rule_id":"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_usermod","title":"Ensure auditd Collects Information on the Use of Privileged Commands - usermod","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"app-srg-ctr","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security","ref_ids":["SRG-APP-000495-CTR-001235","SRG-APP-000499-CTR-001255"]},{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.3.18"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000037-GPOS-00015","SRG-OS-000042-GPOS-00020","SRG-OS-000062-GPOS-00031","SRG-OS-000392-GPOS-00172","SRG-OS-000462-GPOS-00206","SRG-OS-000466-GPOS-00210","SRG-OS-000471-GPOS-00215"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-654125"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260627r958446_rule"]}],"description":"\n\n\nAt a minimum, the audit system should collect the execution of privileged\ncommands for all users and root.\n\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\na line of the following form to a file with suffix <code>.rules</code>\nin the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the\nfollowing form to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ","rationale":"Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.","oval_definition_id":"oval:ssg-audit_rules_privileged_commands_usermod:def:1","remediations":[{"remediation_id":"audit_rules_privileged_commands_usermod","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\n# Retrieve hardware architecture of the underlying system\nOTHER_FILTERS=\"-F path=/usr/sbin/usermod -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0600 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod 0600 ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"audit_rules_privileged_commands_usermod","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-654125\n  - audit_rules_privileged_commands_usermod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure auditd Collects Information on the Use of Privileged Commands - usermod\n    - Perform remediation of Audit rules for /usr/sbin/usermod\n  block:\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    ansible.builtin.find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    ansible.builtin.set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    ansible.builtin.set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    ansible.builtin.set_fact: found_paths=\"{{ find_command.results | map(attribute='files')\n      | flatten | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    ansible.builtin.set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    ansible.builtin.set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/sbin/usermod -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    ansible.builtin.set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    ansible.builtin.find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    ansible.builtin.set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    ansible.builtin.set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched')\n      | map(attribute='item') | list }}\"\n\n  - name: Declare missing syscalls\n    ansible.builtin.set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found)\n      }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n      mode: g-rwx,o-rwx\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    ansible.builtin.lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: g-rwx,o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-654125\n  - audit_rules_privileged_commands_usermod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260627","stig_id":"UBTU-22-654125"},"xccdf_org.ssgproject.content_rule_auditd_audispd_configure_remote_server":{"rule_id":"xccdf_org.ssgproject.content_rule_auditd_audispd_configure_remote_server","title":"Configure audispd Plugin To Send Logs To Remote Server","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000342-GPOS-00133","SRG-OS-000479-GPOS-00224"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653020"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260592r958754_rule"]}],"description":"Configure the audispd plugin to off-load audit records onto a different\nsystem or media from the system being audited.\n\nFirst, set the <code>active</code> option in\n<pre>/etc/audisp/plugins.d/au-remote.conf</pre>\n\nSet the <code>remote_server</code> option in <pre>/etc/audit/audisp-remote.conf</pre>\nwith an IP address or hostname of the system that the audispd plugin should\nsend audit records to. For example\n<pre>remote_server = <i>logcollector</i>\n       </pre>\n      ","rationale":"Information stored in one location is vulnerable to accidental or incidental\ndeletion or alteration.Off-loading is a common process in information systems\nwith limited audit storage capacity.","oval_definition_id":"oval:ssg-auditd_audispd_configure_remote_server:def:1","remediations":[{"remediation_id":"auditd_audispd_configure_remote_server","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nvar_audispd_remote_server='logcollector'\n\n\nAUDITCONFIG=/etc/audit/audisp-remote.conf\n\n\nAUREMOTECONFIG=/etc/audit/plugins.d/au-remote.conf\n\nif [ -e \"$AUREMOTECONFIG\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*active\\s*=\\s*/Id\" \"$AUREMOTECONFIG\"\nelse\n    printf '%s\\n' \"Path '$AUREMOTECONFIG' wasn't found on this system. Refusing to continue.\" >&2\n    return 1\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"$AUREMOTECONFIG\"\n\ncp \"$AUREMOTECONFIG\" \"$AUREMOTECONFIG.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"active = yes\" >> \"$AUREMOTECONFIG\"\n# Clean up after ourselves.\nrm \"$AUREMOTECONFIG.bak\"\n\n\nif [ -e \"$AUDITCONFIG\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*remote_server\\s*=\\s*/Id\" \"$AUDITCONFIG\"\nelse\n    printf '%s\\n' \"Path '$AUDITCONFIG' wasn't found on this system. Refusing to continue.\" >&2\n    return 1\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"$AUDITCONFIG\"\n\ncp \"$AUDITCONFIG\" \"$AUDITCONFIG.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"remote_server = $var_audispd_remote_server\" >> \"$AUDITCONFIG\"\n# Clean up after ourselves.\nrm \"$AUDITCONFIG.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"auditd_audispd_configure_remote_server","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653020\n  - auditd_audispd_configure_remote_server\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n- name: XCCDF Value var_audispd_remote_server # promote to variable\n  set_fact:\n    var_audispd_remote_server: !!str logcollector\n  tags:\n    - always\n\n- name: Configure audispd Plugin To Send Logs To Remote Server - Uncomment active\n    for offloading to remote server\n  ansible.builtin.lineinfile:\n    path: /etc/audit/plugins.d/au-remote.conf\n    regexp: ^(#.*)(active\\s*=)\n    line: \\2\n    backrefs: true\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653020\n  - auditd_audispd_configure_remote_server\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Configure audispd Plugin To Send Logs To Remote Server - Set active to true\n    for offloading to remote server\n  ansible.builtin.lineinfile:\n    path: /etc/audit/plugins.d/au-remote.conf\n    regexp: ^(.*)(active\\s*=)(?!.*yes)\n    line: \\2 yes\n    create: true\n    state: present\n    backrefs: true\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653020\n  - auditd_audispd_configure_remote_server\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Configure audispd Plugin To Send Logs To Remote Server - Make sure that a\n    remote server is configured for Audispd\n  ansible.builtin.lineinfile:\n    path: /etc/audit/audisp-remote.conf\n    line: remote_server = {{ var_audispd_remote_server }}\n    regexp: ^\\s*remote_server\\s*=.*$\n    create: true\n    state: present\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653020\n  - auditd_audispd_configure_remote_server\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260592","stig_id":"UBTU-22-653020"},"xccdf_org.ssgproject.content_rule_auditd_audispd_configure_sufficiently_large_partition":{"rule_id":"xccdf_org.ssgproject.content_rule_auditd_audispd_configure_sufficiently_large_partition","title":"Configure a Sufficiently Large Partition for Audit Logs","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000341-GPOS-00132","SRG-OS-000342-GPOS-00133"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260595r958752_rule"]}],"description":"The Ubuntu 22.04 operating system must allocate audit record storage\ncapacity to store at least one weeks worth of audit records when audit\nrecords are not immediately sent to a central audit record storage\nfacility.\n\nThe partition size needed to capture a week&#x27;s worth of audit records is\nbased on the activity level of the system and the total storage capacity\navailable.\n\n\nDetermine which partition the audit records are being written to with the\nfollowing command:\n\n<pre>$ sudo grep log_file /etc/audit/auditd.conf\nlog_file = /var/log/audit/audit.log</pre>\n\nCheck the size of the partition that audit records are written to with the\nfollowing command:\n\n<pre>$ sudo df -h /var/log/audit/\n/dev/sda2 24G 10.4G 13.6G 43% /var/log/audit</pre>\n      ","rationale":"Information stored in one location is vulnerable to accidental or incidental\ndeletion or alteration. Off-loading is a common process in information\nsystems with limited audit storage capacity.","vuln_id":"SV-260595","stig_id":"UBTU-22-653035"},"xccdf_org.ssgproject.content_rule_auditd_data_disk_full_action":{"rule_id":"xccdf_org.ssgproject.content_rule_auditd_data_disk_full_action","title":"Configure auditd Disk Full Action when Disk Space Is Full","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO11.04","APO12.06","APO13.01","BAI03.05","BAI04.04","BAI08.02","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS05.04","DSS05.07","MEA02.01"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 7.1","SR 7.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.3","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.16.1.4","A.16.1.5","A.16.1.7","A.17.2.1"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-5(1)","AU-5(2)","AU-5(4)","AU-5(b)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","PR.DS-4","PR.PT-1","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000047-GPOS-00023"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653030"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260594r1038966_rule"]}],"description":"The <code>auditd</code> service can be configured to take an action\nwhen disk space is running low but prior to running out of space completely.\nEdit the file <code>/etc/audit/auditd.conf</code>. Add or modify the following line,\nsubstituting <i>ACTION</i> appropriately:\n<pre>disk_full_action = <i>ACTION</i>\n       </pre>\nSet this value to <code>single</code> to cause the system to switch to single-user\nmode for corrective action. Acceptable values also include\n\n<code>syslog</code>, <code>exec</code>, <code>single</code>, and <code>halt</code>\n\nFor certain systems, the need for availability\noutweighs the need to log all actions, and a different setting should be\ndetermined. Details regarding all possible values for <i>ACTION</i> are described in the\n<code>auditd.conf</code> man page.","rationale":"Taking appropriate action in case of a filled audit storage volume will minimize\nthe possibility of losing audit records.","oval_definition_id":"oval:ssg-auditd_data_disk_full_action:def:1","remediations":[{"remediation_id":"auditd_data_disk_full_action","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nvar_auditd_disk_full_action='halt'\n\n\nvar_auditd_disk_full_action=\"$(echo $var_auditd_disk_full_action | cut -d \\| -f 1)\"\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^disk_full_action\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_disk_full_action\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^disk_full_action\\\\>\" \"/etc/audit/auditd.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^disk_full_action\\\\>.*/$escaped_formatted_output/gi\" \"/etc/audit/auditd.conf\"\nelse\n    if [[ -s \"/etc/audit/auditd.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/audit/auditd.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/audit/auditd.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/audit/auditd.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260594","stig_id":"UBTU-22-653030"},"xccdf_org.ssgproject.content_rule_auditd_data_retention_action_mail_acct":{"rule_id":"xccdf_org.ssgproject.content_rule_auditd_data_retention_action_mail_acct","title":"Configure auditd mail_acct Action on Low Disk Space","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.2.3"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO11.04","APO12.06","APO13.01","BAI03.05","BAI04.04","BAI08.02","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS05.04","DSS05.07","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.3.1"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.312(a)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 7.1","SR 7.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.3","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.16.1.4","A.16.1.5","A.16.1.7","A.17.2.1"]},{"name":"nerc-cip","href":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ref_ids":["CIP-003-8 R1.3","CIP-003-8 R3","CIP-003-8 R3.1","CIP-003-8 R3.2","CIP-003-8 R3.3","CIP-003-8 R5.1.1","CIP-003-8 R5.3","CIP-004-6 R2.2.3","CIP-004-6 R2.3","CIP-007-3 R5.1","CIP-007-3 R5.1.2","CIP-007-3 R5.2","CIP-007-3 R5.3.1","CIP-007-3 R5.3.2","CIP-007-3 R5.3.3"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-5(2)","AU-5(a)","CM-6(a)","IA-5(1)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","PR.DS-4","PR.PT-1","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000046-GPOS-00022","SRG-OS-000343-GPOS-00134"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.7.a"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653025"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260593r958424_rule"]}],"description":"The <code>auditd</code> service can be configured to send email to\na designated account in certain situations. Add or correct the following line\nin <code>/etc/audit/auditd.conf</code> to ensure that administrators are notified\nvia email for those situations:\n<pre>action_mail_acct = root\n       </pre>\n      ","rationale":"Email sent to the root account is typically aliased to the\nadministrators of the system, who can take appropriate action.","oval_definition_id":"oval:ssg-auditd_data_retention_action_mail_acct:def:1","remediations":[{"remediation_id":"auditd_data_retention_action_mail_acct","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nvar_auditd_action_mail_acct='root'\n\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^action_mail_acct\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_action_mail_acct\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^action_mail_acct\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^action_mail_acct\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    if [[ -s \"$AUDITCONFIG\" ]] && [[ -n \"$(tail -c 1 -- \"$AUDITCONFIG\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"$AUDITCONFIG\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260593","stig_id":"UBTU-22-653025"},"xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action":{"rule_id":"xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action","title":"Configure auditd space_left Action on Low Disk Space","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.2.3"]},{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8"]},{"name":"cjis","href":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","ref_ids":["5.4.1.1"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO11.04","APO12.06","APO13.01","BAI03.05","BAI04.04","BAI08.02","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS05.04","DSS05.07","MEA02.01"]},{"name":"cui","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","ref_ids":["3.3.1"]},{"name":"hipaa","href":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","ref_ids":["164.312(a)(2)(ii)"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 7.1","SR 7.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.3","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.16.1.4","A.16.1.5","A.16.1.7","A.17.2.1"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-5(1)","AU-5(2)","AU-5(4)","AU-5(b)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","PR.DS-4","PR.PT-1","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000343-GPOS-00134"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.7"]},{"name":"pcidss4","href":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","ref_ids":["10.5","10.5.1"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260596r971542_rule"]}],"description":"The <code>auditd</code> service can be configured to take an action\nwhen disk space <i>starts</i> to run low.\nEdit the file <code>/etc/audit/auditd.conf</code>. Modify the following line,\nsubstituting <i>ACTION</i> appropriately:\n<pre>space_left_action = <i>ACTION</i>\n       </pre>\nPossible values for <i>ACTION</i> are described in the <code>auditd.conf</code> man page.\nThese include:\n<ul><li><code>syslog</code></li><li><code>email</code></li><li><code>exec</code></li><li><code>suspend</code></li><li><code>single</code></li><li><code>halt</code></li></ul>\nSet this to <code>email</code> (instead of the default,\nwhich is <code>suspend</code>) as it is more likely to get prompt attention. Acceptable values\nalso include <code>suspend</code>, <code>single</code>, and <code>halt</code>.","rationale":"Notifying administrators of an impending disk space problem may\nallow them to take corrective action prior to any disruption.","oval_definition_id":"oval:ssg-auditd_data_retention_space_left_action:def:1","remediations":[{"remediation_id":"auditd_data_retention_space_left_action","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nvar_auditd_space_left_action='email'\n\n\nvar_auditd_space_left_action=\"$(echo $var_auditd_space_left_action | cut -d \\| -f 1)\"\n#\n# If space_left_action present in /etc/audit/auditd.conf, change value\n# to var_auditd_space_left_action, else\n# add \"space_left_action = $var_auditd_space_left_action\" to /etc/audit/auditd.conf\n#\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^space_left_action\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_space_left_action\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^space_left_action\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^space_left_action\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    if [[ -s \"$AUDITCONFIG\" ]] && [[ -n \"$(tail -c 1 -- \"$AUDITCONFIG\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"$AUDITCONFIG\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"}],"vuln_id":"SV-260596","stig_id":"UBTU-22-653040"},"xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_percentage":{"rule_id":"xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_percentage","title":"Configure auditd space_left on Low Disk Space","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis-csc","href":"https://www.cisecurity.org/controls/","ref_ids":["1","11","12","13","14","15","16","19","2","3","4","5","6","7","8"]},{"name":"cobit5","href":"https://www.isaca.org/resources/cobit","ref_ids":["APO11.04","APO12.06","APO13.01","BAI03.05","BAI04.04","BAI08.02","DSS02.02","DSS02.04","DSS02.07","DSS03.01","DSS05.04","DSS05.07","MEA02.01"]},{"name":"isa-62443-2009","href":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","ref_ids":["4.2.3.10","4.3.3.3.9","4.3.3.5.8","4.3.4.4.7","4.3.4.5.6","4.3.4.5.7","4.3.4.5.8","4.4.2.1","4.4.2.2","4.4.2.4"]},{"name":"isa-62443-2013","href":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ref_ids":["SR 2.10","SR 2.11","SR 2.12","SR 2.8","SR 2.9","SR 6.1","SR 7.1","SR 7.2"]},{"name":"iso27001-2013","href":"https://www.iso.org/contents/data/standard/05/45/54534.html","ref_ids":["A.12.1.3","A.12.4.1","A.12.4.2","A.12.4.3","A.12.4.4","A.12.7.1","A.16.1.4","A.16.1.5","A.16.1.7","A.17.2.1"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-5(1)","AU-5(2)","AU-5(4)","AU-5(b)","CM-6(a)"]},{"name":"nist-csf","href":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","ref_ids":["DE.AE-3","DE.AE-5","PR.DS-4","PR.PT-1","RS.AN-1","RS.AN-4"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000343-GPOS-00134"]},{"name":"pcidss","href":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","ref_ids":["Req-10.7"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653040"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260596r971542_rule"]}],"description":"The <code>auditd</code> service can be configured to take an action\nwhen disk space is running low but prior to running out of space completely.\nEdit the file <code>/etc/audit/auditd.conf</code>. Add or modify the following line,\nsubstituting <i>PERCENTAGE</i> appropriately:\n<pre>space_left = <i>PERCENTAGE</i>%</pre>\nSet this value to at least 25 to cause the system to\nnotify the user of an issue.","rationale":"Notifying administrators of an impending disk space problem may allow them to\ntake corrective action prior to any disruption.","oval_definition_id":"oval:ssg-auditd_data_retention_space_left_percentage:def:1","remediations":[{"remediation_id":"auditd_data_retention_space_left_percentage","system":"urn:xccdf:fix:script:sh","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'auditd' 2>/dev/null | grep -q '^installed$' && dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nvar_auditd_space_left_percentage='25'\n\n\ngrep -q \"^space_left[[:space:]]*=.*$\" /etc/audit/auditd.conf && \\\n  sed -i \"s/^space_left[[:space:]]*=.*$/space_left = $var_auditd_space_left_percentage%/g\" /etc/audit/auditd.conf || \\\n  echo \"space_left = $var_auditd_space_left_percentage%\" >> /etc/audit/auditd.conf\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"auditd_data_retention_space_left_percentage","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"restrict","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653040\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_space_left_percentage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_space_left_percentage # promote to variable\n  set_fact:\n    var_auditd_space_left_percentage: !!str 25\n  tags:\n    - always\n\n- name: Configure auditd space_left on Low Disk Space\n  ansible.builtin.lineinfile:\n    dest: /etc/audit/auditd.conf\n    line: space_left = {{ var_auditd_space_left_percentage }}%\n    regexp: ^\\s*space_left\\s*=\\s*.*$\n    state: present\n    create: true\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653040\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_space_left_percentage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"}],"vuln_id":"SV-260596","stig_id":"UBTU-22-653040"},"xccdf_org.ssgproject.content_rule_auditd_offload_logs":{"rule_id":"xccdf_org.ssgproject.content_rule_auditd_offload_logs","title":"Offload audit Logs to External Media","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000479-GPOS-00224"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-651035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260587r959008_rule"]}],"description":"The operating system must have a crontab script running weekly to\noffload audit events of standalone systems.","rationale":"Information stored in one location is vulnerable to accidental or\nincidental deletion or alteration.\nOffloading is a common process in information systems with limited\naudit storage capacity.","warnings":[{"text":"Due to different needs and possibilities, automated remediation is not\navailable for this configuration check.","category":"general"}],"oval_definition_id":"oval:ssg-auditd_offload_logs:def:1","vuln_id":"SV-260587","stig_id":"UBTU-22-651035"},"xccdf_org.ssgproject.content_rule_file_ownership_audit_binaries":{"rule_id":"xccdf_org.ssgproject.content_rule_file_ownership_audit_binaries","title":"Verify that audit tools are owned by root","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.9"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000256-GPOS-00097","SRG-OS-000257-GPOS-00098"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232110"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260507r991557_rule"]}],"description":"The Ubuntu 22.04 operating system audit tools must have the proper\nownership configured to protected against unauthorized access.\n\nVerify it by running the following command:\n<pre>$ stat -c &quot;%n %U&quot; /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/audispd /sbin/augenrules /sbin/audisp-syslog\n\n/sbin/auditctl root\n/sbin/aureport root\n/sbin/ausearch root\n/sbin/autrace root\n/sbin/auditd root\n/sbin/audispd root\n/sbin/augenrules root\n\n</pre>\n\nAudit tools needed to successfully view and manipulate audit information\nsystem activity and records. Audit tools include custom queries and report\ngenerators","rationale":"Protecting audit information also includes identifying and protecting the\ntools used to view and manipulate log data. Therefore, protecting audit\ntools is necessary to prevent unauthorized operation on audit information.\n\nOperating systems providing tools to interface with audit information\nwill leverage user permissions and roles identifying the user accessing the\ntools and the corresponding rights the user enjoys to make access decisions\nregarding the access to audit tools.","oval_definition_id":"oval:ssg-file_ownership_audit_binaries:def:1","remediations":[{"remediation_id":"file_ownership_audit_binaries","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nnewown=\"\"\nif id \"0\" >/dev/null 2>&1; then\n  newown=\"0\"\nfi\n\nif [[ -z \"$newown\" ]]; then\n  >&2 echo \"0 is not a defined user on the system\"\nelse\nif ! stat -c \"%u %U\" \"/sbin/auditctl\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /sbin/auditctl\nfi\nif ! stat -c \"%u %U\" \"/sbin/aureport\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /sbin/aureport\nfi\nif ! stat -c \"%u %U\" \"/sbin/ausearch\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /sbin/ausearch\nfi\nif ! stat -c \"%u %U\" \"/sbin/autrace\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /sbin/autrace\nfi\nif ! stat -c \"%u %U\" \"/sbin/auditd\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /sbin/auditd\nfi\nif ! stat -c \"%u %U\" \"/sbin/audispd\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /sbin/audispd\nfi\nif ! stat -c \"%u %U\" \"/sbin/augenrules\" | grep -E -w -q \"0\"; then\n    chown --no-dereference \"$newown\" /sbin/augenrules\nfi\n\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_ownership_audit_binaries","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set the file_ownership_audit_binaries_newown variable if represented by uid\n  ansible.builtin.set_fact:\n    file_ownership_audit_binaries_newown: '0'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/auditctl\n  ansible.builtin.stat:\n    path: /sbin/auditctl\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /sbin/auditctl\n  ansible.builtin.file:\n    path: /sbin/auditctl\n    follow: false\n    owner: '{{ file_ownership_audit_binaries_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/aureport\n  ansible.builtin.stat:\n    path: /sbin/aureport\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /sbin/aureport\n  ansible.builtin.file:\n    path: /sbin/aureport\n    follow: false\n    owner: '{{ file_ownership_audit_binaries_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/ausearch\n  ansible.builtin.stat:\n    path: /sbin/ausearch\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /sbin/ausearch\n  ansible.builtin.file:\n    path: /sbin/ausearch\n    follow: false\n    owner: '{{ file_ownership_audit_binaries_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/autrace\n  ansible.builtin.stat:\n    path: /sbin/autrace\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /sbin/autrace\n  ansible.builtin.file:\n    path: /sbin/autrace\n    follow: false\n    owner: '{{ file_ownership_audit_binaries_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/auditd\n  ansible.builtin.stat:\n    path: /sbin/auditd\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /sbin/auditd\n  ansible.builtin.file:\n    path: /sbin/auditd\n    follow: false\n    owner: '{{ file_ownership_audit_binaries_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/audispd\n  ansible.builtin.stat:\n    path: /sbin/audispd\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /sbin/audispd\n  ansible.builtin.file:\n    path: /sbin/audispd\n    follow: false\n    owner: '{{ file_ownership_audit_binaries_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/augenrules\n  ansible.builtin.stat:\n    path: /sbin/augenrules\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /sbin/augenrules\n  ansible.builtin.file:\n    path: /sbin/augenrules\n    follow: false\n    owner: '{{ file_ownership_audit_binaries_newown }}'\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232110\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260507","stig_id":"UBTU-22-232110"},"xccdf_org.ssgproject.content_rule_file_permissions_audit_binaries":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_audit_binaries","title":"Verify that audit tools Have Mode 0755 or less","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.8"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000256-GPOS-00097","SRG-OS-000257-GPOS-00098"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-232035"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260492r991557_rule"]}],"description":"The Ubuntu 22.04 operating system audit tools must have the proper\npermissions configured to protected against unauthorized access.\n\nVerify it by running the following command:\n<pre>$ stat -c &quot;%n %a&quot; /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/audispd /sbin/augenrules\n\n/sbin/auditctl 755\n/sbin/aureport 755\n/sbin/ausearch 755\n/sbin/autrace 755\n/sbin/auditd 755\n/sbin/audispd 755\n/sbin/augenrules 755\n</pre>\n\nAudit tools needed to successfully view and manipulate audit information\nsystem activity and records. Audit tools include custom queries and report\ngenerators","rationale":"Protecting audit information also includes identifying and protecting the\ntools used to view and manipulate log data. Therefore, protecting audit\ntools is necessary to prevent unauthorized operation on audit information.\n\nOperating systems providing tools to interface with audit information\nwill leverage user permissions and roles identifying the user accessing the\ntools and the corresponding rights the user enjoys to make access decisions\nregarding the access to audit tools.","oval_definition_id":"oval:ssg-file_permissions_audit_binaries:def:1","remediations":[{"remediation_id":"file_permissions_audit_binaries","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nchmod u-s,g-ws,o-wt /sbin/auditctl\n\nchmod u-s,g-ws,o-wt /sbin/aureport\n\nchmod u-s,g-ws,o-wt /sbin/ausearch\n\nchmod u-s,g-ws,o-wt /sbin/autrace\n\nchmod u-s,g-ws,o-wt /sbin/auditd\n\nchmod u-s,g-ws,o-wt /sbin/audispd\n\nchmod u-s,g-ws,o-wt /sbin/augenrules\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_permissions_audit_binaries","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/auditctl\n  ansible.builtin.stat:\n    path: /sbin/auditctl\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/auditctl\n  ansible.builtin.file:\n    path: /sbin/auditctl\n    mode: u-s,g-ws,o-wt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/aureport\n  ansible.builtin.stat:\n    path: /sbin/aureport\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/aureport\n  ansible.builtin.file:\n    path: /sbin/aureport\n    mode: u-s,g-ws,o-wt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/ausearch\n  ansible.builtin.stat:\n    path: /sbin/ausearch\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/ausearch\n  ansible.builtin.file:\n    path: /sbin/ausearch\n    mode: u-s,g-ws,o-wt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/autrace\n  ansible.builtin.stat:\n    path: /sbin/autrace\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/autrace\n  ansible.builtin.file:\n    path: /sbin/autrace\n    mode: u-s,g-ws,o-wt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/auditd\n  ansible.builtin.stat:\n    path: /sbin/auditd\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/auditd\n  ansible.builtin.file:\n    path: /sbin/auditd\n    mode: u-s,g-ws,o-wt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/audispd\n  ansible.builtin.stat:\n    path: /sbin/audispd\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/audispd\n  ansible.builtin.file:\n    path: /sbin/audispd\n    mode: u-s,g-ws,o-wt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/augenrules\n  ansible.builtin.stat:\n    path: /sbin/augenrules\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/augenrules\n  ansible.builtin.file:\n    path: /sbin/augenrules\n    mode: u-s,g-ws,o-wt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-232035\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260492","stig_id":"UBTU-22-232035"},"xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_auditd":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_auditd","title":"Verify Permissions on /etc/audit/auditd.conf","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(b)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000063-GPOS-00032"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653065"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260601r958444_rule"]}],"description":"\nTo properly set the permissions of <code>/etc/audit/auditd.conf</code>, run the command:\n<pre>$ sudo chmod 0640 /etc/audit/auditd.conf</pre>\n      ","rationale":"Without the capability to restrict the roles and individuals that can select which events\nare audited, unauthorized personnel may be able to prevent the auditing of critical\nevents. Misconfigured audits may degrade the system&#x27;s performance by overwhelming\nthe audit log. Misconfigured audits may also make it more difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.","oval_definition_id":"oval:ssg-file_permissions_etc_audit_auditd:def:1","remediations":[{"remediation_id":"file_permissions_etc_audit_auditd","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nchmod u-xs,g-xws,o-xwrt /etc/audit/auditd.conf\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_permissions_etc_audit_auditd","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_auditd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /etc/audit/auditd.conf\n  ansible.builtin.stat:\n    path: /etc/audit/auditd.conf\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_auditd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xs,g-xws,o-xwrt on /etc/audit/auditd.conf\n  ansible.builtin.file:\n    path: /etc/audit/auditd.conf\n    mode: u-xs,g-xws,o-xwrt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_auditd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260601","stig_id":"UBTU-22-653065"},"xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_rules":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_rules","title":"Verify Permissions on /etc/audit/audit.rules","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653065"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260601r958444_rule"]}],"description":"\nTo properly set the permissions of <code>/etc/audit/audit.rules</code>, run the command:\n<pre>$ sudo chmod 0640 /etc/audit/audit.rules</pre>\n      ","rationale":"Without the capability to restrict the roles and individuals that can select which events\nare audited, unauthorized personnel may be able to prevent the auditing of critical\nevents. Misconfigured audits may degrade the system&#x27;s performance by overwhelming\nthe audit log. Misconfigured audits may also make it more difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.","oval_definition_id":"oval:ssg-file_permissions_etc_audit_rules:def:1","remediations":[{"remediation_id":"file_permissions_etc_audit_rules","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nchmod u-xs,g-xws,o-xwrt /etc/audit/audit.rules\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_permissions_etc_audit_rules","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - configure_strategy\n  - file_permissions_etc_audit_rules\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /etc/audit/audit.rules\n  ansible.builtin.stat:\n    path: /etc/audit/audit.rules\n  register: file_exists\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - configure_strategy\n  - file_permissions_etc_audit_rules\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xs,g-xws,o-xwrt on /etc/audit/audit.rules\n  ansible.builtin.file:\n    path: /etc/audit/audit.rules\n    mode: u-xs,g-xws,o-xwrt\n  when:\n  - '\"linux-base\" in ansible_facts.packages'\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - configure_strategy\n  - file_permissions_etc_audit_rules\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260601","stig_id":"UBTU-22-653065"},"xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_rulesd":{"rule_id":"xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_rulesd","title":"Verify Permissions on /etc/audit/rules.d/*.rules","result":"notapplicable","time":"2025-11-28T16:31:25+00:00","severity":"medium","weight":1,"references":[{"name":"cis","href":"https://www.cisecurity.org/benchmark/ubuntu_linux/","ref_ids":["4.1.4.5"]},{"name":"nist","href":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","ref_ids":["AU-12(b)"]},{"name":"os-srg","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","ref_ids":["SRG-OS-000063-GPOS-00032"]},{"name":"stigid","href":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","ref_ids":["UBTU-22-653065"]},{"name":"stigref","href":"https://www.cyber.mil/stigs/srg-stig-tools/","ref_ids":["SV-260601r958444_rule"]}],"description":"\nTo properly set the permissions of <code>/etc/audit/rules.d/*.rules</code>, run the command:\n<pre>$ sudo chmod 0600 /etc/audit/rules.d/*.rules</pre>\n      ","rationale":"Without the capability to restrict the roles and individuals that can select which events\nare audited, unauthorized personnel may be able to prevent the auditing of critical\nevents. Misconfigured audits may degrade the system&#x27;s performance by overwhelming\nthe audit log. Misconfigured audits may also make it more difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.","oval_definition_id":"oval:ssg-file_permissions_etc_audit_rulesd:def:1","remediations":[{"remediation_id":"file_permissions_etc_audit_rulesd","system":"urn:xccdf:fix:script:sh","complexity":"low","disruption":"low","strategy":"configure","fix":"# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}' 'linux-base' 2>/dev/null | grep -q '^installed$'; then\n\nfind -P /etc/audit/rules.d/ -maxdepth 1 -perm /u+xs,g+xwrs,o+xwrt  -type f -regextype posix-extended -regex '^.*rules$' -exec chmod u-xs,g-xwrs,o-xwrt {} \\;\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"},{"remediation_id":"file_permissions_etc_audit_rulesd","system":"urn:xccdf:fix:script:ansible","complexity":"low","disruption":"low","strategy":"configure","fix":"- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_rulesd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/rules.d/ file(s)\n  ansible.builtin.command: find -P /etc/audit/rules.d/ -maxdepth 1 -perm /u+xs,g+xwrs,o+xwrt  -type\n    f -regextype posix-extended -regex \"^.*rules$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_rulesd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /etc/audit/rules.d/ file(s)\n  ansible.builtin.file:\n    path: '{{ item }}'\n    mode: u-xs,g-xwrs,o-xwrt\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when: '\"linux-base\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-22-653065\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_rulesd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"}],"vuln_id":"SV-260601","stig_id":"UBTU-22-653065"}},"references":{"anssi":"https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf","cis":"https://www.cisecurity.org/benchmark/ubuntu_linux/","cis-csc":"https://www.cisecurity.org/controls/","cjis":"https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf","cobit5":"https://www.isaca.org/resources/cobit","isa-62443-2009":"https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat","isa-62443-2013":"https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu","ism":"https://www.cyber.gov.au/acsc/view-all-content/ism","iso27001-2013":"https://www.iso.org/contents/data/standard/05/45/54534.html","nist":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf","nist-csf":"https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf","os-srg":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os","pcidss":"https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf","pcidss4":"https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf","stigid":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux","stigref":"https://www.cyber.mil/stigs/srg-stig-tools/","cui":"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf","hipaa":"https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf","nerc-cip":"https://www.nerc.com/pa/Stand/AlignRep/One%20Stop%20Shop.xlsx","ospp":"https://www.niap-ccevs.org/Profile/PP.cfm","app-srg-ctr":"https://www.cyber.mil/stigs/downloads/?_dl_facet_stigs=app-security"}}