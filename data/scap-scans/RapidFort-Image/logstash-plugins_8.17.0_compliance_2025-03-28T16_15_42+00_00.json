{
    "profile_info": {
      "profile_id": "xccdf_org.ssgproject.content_profile_stig",
      "description": "This Security Technical Implementation Guide is published as a tool to\nimprove the security of Department of Defense (DoD) information systems.\nThe requirements are derived from the National Institute of Standards and\nTechnology (NIST) 800-53 and related documents.",
      "title": "Canonical Ubuntu 20.04 LTS Security Technical Implementation Guide (STIG) V1R11"
    },
    "scan_result": {
      "title": "OSCAP Scan Result",
      "identity": "root",
      "profile_id": "xccdf_org.ssgproject.content_profile_stig",
      "target": "787afd0b1a27",
      "cpe_platforms": [
        "#package_shadow-utils",
        "#package_pam",
        "cpe:/o:canonical:ubuntu_linux:20.04::~~lts~~~",
        "#wifi-iface"
      ],
      "scanner": "OpenSCAP",
      "scanner_version": "1.4.0",
      "benchmark_url": "#scap_org.open-scap_comp_ssg-ubuntu2004-xccdf.xml",
      "benchmark_id": "xccdf_org.ssgproject.content_benchmark_UBUNTU_20-04",
      "benchmark_version": "0.1.74",
      "start_time": "2025-03-28T16:15:42+00:00",
      "end_time": "2025-03-28T16:15:43+00:00",
      "test_system": "cpe:/a:redhat:openscap:1.4.0",
      "score_system": "urn:xccdf:scoring:default",
      "score": 81.041664,
      "score_max": 100,
      "target_addresses": {
        "MAC": [
          "00:00:00:00:00:00"
        ],
        "IPv4": [
          "127.0.0.1"
        ],
        "IPv6": [
          "::1"
        ]
      },
      "guid": "1ee31be1-725e-46b6-bc8c-75a190fa673f",
      "target_name": "soteriasoft.jfrog.io/openrmfpro/logstash/logstash-plugins:8.17.0",
      "rfcat_version": "1.24.12"
    },
    "rules": {
      "xccdf_org.ssgproject.content_rule_package_aide_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_aide_installed",
        "title": "Install AIDE",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R76",
              "R79"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.4.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.10.1.3"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "BAI01.06",
              "BAI02.01",
              "BAI03.05",
              "BAI06.01",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS01.03",
              "DSS03.05",
              "DSS04.07",
              "DSS05.02",
              "DSS05.03",
              "DSS05.05",
              "DSS05.07",
              "DSS06.02",
              "DSS06.06"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001744",
              "CCI-002696",
              "CCI-002699"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.4.3.2",
              "4.3.4.3.3",
              "4.3.4.4.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.1",
              "SR 3.3",
              "SR 3.4",
              "SR 3.8",
              "SR 4.1",
              "SR 6.2",
              "SR 7.6"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "1034",
              "1288",
              "1341",
              "1417"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.12.1.2",
              "A.12.2.1",
              "A.12.4.1",
              "A.12.5.1",
              "A.12.6.2",
              "A.14.1.2",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.14.2.7",
              "A.15.2.1",
              "A.8.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-7",
              "PR.DS-1",
              "PR.DS-6",
              "PR.DS-8",
              "PR.IP-1",
              "PR.IP-3"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000445-GPOS-00199"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-11.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "11.5.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010450"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238371r880913_rule"
            ]
          }
        ],
        "description": "The <code>aide</code> package can be installed with the following command:\n<pre>\n$ apt-get install aide</pre>\n         ",
        "rationale": "The AIDE package must be installed if it is to be available for integrity checking.",
        "oval_definition_id": "oval:ssg-package_aide_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_aide_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure aide is installed\n  package:\n    name: aide\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_aide_installed\n"
          },
          {
            "remediation_id": "package_aide_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_aide\n\nclass install_aide {\n  package { 'aide':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_aide_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"aide\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_aide_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238371",
        "stig_id": "UBTU-20-010450"
      },
      "xccdf_org.ssgproject.content_rule_aide_build_database": {
        "rule_id": "xccdf_org.ssgproject.content_rule_aide_build_database",
        "title": "Build and Test AIDE Database",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R76",
              "R79"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.4.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.10.1.3"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "BAI01.06",
              "BAI02.01",
              "BAI03.05",
              "BAI06.01",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS01.03",
              "DSS03.05",
              "DSS04.07",
              "DSS05.02",
              "DSS05.03",
              "DSS05.05",
              "DSS05.07",
              "DSS06.02",
              "DSS06.06"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.4.3.2",
              "4.3.4.3.3",
              "4.3.4.4.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.1",
              "SR 3.3",
              "SR 3.4",
              "SR 3.8",
              "SR 4.1",
              "SR 6.2",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.12.1.2",
              "A.12.2.1",
              "A.12.4.1",
              "A.12.5.1",
              "A.12.6.2",
              "A.14.1.2",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.14.2.7",
              "A.15.2.1",
              "A.8.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-7",
              "PR.DS-1",
              "PR.DS-6",
              "PR.DS-8",
              "PR.IP-1",
              "PR.IP-3"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000445-GPOS-00199"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-11.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "11.5.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010450"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238371r880913_rule"
            ]
          }
        ],
        "description": "Run the following command to generate a new database:\n\n<pre>$ sudo aideinit</pre>\n\nBy default, the database will be written to the file\n\n<code>/var/lib/aide/aide.db.new</code>.\n\nStoring the database, the configuration file <code>/etc/aide.conf</code>, and the binary\n<code>/usr/bin/aide.wrapper</code>\n(or hashes of these files), in a secure location (such as on read-only media) provides additional assurance about their integrity.\nThe newly-generated database can be installed as follows:\n\n<pre>$ sudo cp /var/lib/aide/aide.db.new /var/lib/aide/aide.db</pre>\n\nTo initiate a manual check, run the following command:\n<pre>$ sudo /usr/bin/aide.wrapper --check</pre>\nIf this check produces any unexpected output, investigate.",
        "rationale": "For AIDE to be effective, an initial database of &quot;known-good&quot; information about files\nmust be captured and it should be able to be verified against the installed files.",
        "oval_definition_id": "oval:ssg-aide_build_database:def:1",
        "remediations": [
          {
            "remediation_id": "aide_build_database",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Build and Test AIDE Database - Ensure AIDE Is Installed\n  ansible.builtin.apt:\n    name: aide\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Check if DB Path in /etc/aide/aide.conf Is\n    Already Set\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database=)(.*)$\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: database_replace\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Check if DB Out Path in /etc/aide/aide.conf\n    Is Already Set\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database_out=)(.*)$\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: database_out_replace\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Fix DB Path in Config File if Necessary\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database)(\\s*)=(\\s*)(.*)$\n    line: \\2\\3=\\4file:/var/lib/aide/aide.db\n    backrefs: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - database_replace.found > 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Fix DB Out Path in Config File if Necessary\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^#?(\\s*)(database_out)(\\s*)=(\\s*)(.*)$\n    line: \\2\\3=\\4file:/var/lib/aide/aide.db.new\n    backrefs: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - database_out_replace.found > 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Ensure the Default DB Path is Added\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    line: database=file:/var/lib/aide/aide.db\n    create: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - database_replace.found == 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Ensure the Default Out Path is Added\n  ansible.builtin.lineinfile:\n    path: /etc/aide/aide.conf\n    line: database_out=file:/var/lib/aide/aide.db.new\n    create: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - database_out_replace.found == 0\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database - Build and Test AIDE Database\n  ansible.builtin.command: /usr/sbin/aideinit -y -f\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010450\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "aide_build_database",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\nAIDE_CONFIG=/etc/aide/aide.conf\nDEFAULT_DB_PATH=/var/lib/aide/aide.db\n\n# Fix db path in the config file, if necessary\nif ! grep -q '^database=file:' ${AIDE_CONFIG}; then\n    # replace_or_append gets confused by 'database=file' as a key, so should not be used.\n    #replace_or_append \"${AIDE_CONFIG}\" '^database=file' \"${DEFAULT_DB_PATH}\" '@CCENUM@' '%s:%s'\n    echo \"database=file:${DEFAULT_DB_PATH}\" >> ${AIDE_CONFIG}\nfi\n\n# Fix db out path in the config file, if necessary\nif ! grep -q '^database_out=file:' ${AIDE_CONFIG}; then\n    echo \"database_out=file:${DEFAULT_DB_PATH}.new\" >> ${AIDE_CONFIG}\nfi\n\n/usr/sbin/aideinit -y -f\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238371",
        "stig_id": "UBTU-20-010450"
      },
      "xccdf_org.ssgproject.content_rule_aide_check_audit_tools": {
        "rule_id": "xccdf_org.ssgproject.content_rule_aide_check_audit_tools",
        "title": "Configure AIDE to Verify the Audit Tools",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001496"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-9(3)",
              "AU-9(3).1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000278-GPOS-00108"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010205"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238303r877393_rule"
            ]
          }
        ],
        "description": "The operating system file integrity tool must be configured to protect the integrity of the audit tools.",
        "rationale": "Protecting the integrity of the tools used for auditing purposes is a\ncritical step toward ensuring the integrity of audit information. Audit\ninformation includes all information (e.g., audit records, audit settings,\nand audit reports) needed to successfully audit information system\nactivity.\n\nAudit tools include but are not limited to vendor-provided and open-source\naudit tools needed to successfully view and manipulate audit information\nsystem activity and records. Audit tools include custom queries and report\ngenerators.\n\nIt is not uncommon for attackers to replace the audit tools or inject code\ninto the existing tools to provide the capability to hide or erase system\nactivity from the audit logs.\n\nTo address this risk, audit tools must be cryptographically signed to\nprovide the capability to identify when the audit tools have been modified,\nmanipulated, or replaced. An example is a checksum hash of the file or\nfiles.",
        "oval_definition_id": "oval:ssg-aide_check_audit_tools:def:1",
        "remediations": [
          {
            "remediation_id": "aide_check_audit_tools",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Configure AIDE to Verify the Audit Tools - Gather List of Packages\n  tags:\n  - DISA-STIG-UBTU-20-010205\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  ansible.builtin.package_facts:\n    manager: auto\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n\n- name: Ensure aide is installed\n  package:\n    name: '{{ item }}'\n    state: present\n  with_items:\n  - aide\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010205\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set audit_tools fact\n  set_fact:\n    audit_tools:\n    - /usr/sbin/audispd\n    - /usr/sbin/auditctl\n    - /usr/sbin/auditd\n    - /usr/sbin/augenrules\n    - /usr/sbin/aureport\n    - /usr/sbin/ausearch\n    - /usr/sbin/autrace\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010205\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure existing AIDE configuration for audit tools are correct\n  lineinfile:\n    path: /etc/aide/aide.conf\n    regexp: ^{{ item }}\\s\n    line: '{{ item }} p+i+n+u+g+s+b+acl+xattrs+sha512'\n  with_items: '{{ audit_tools }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010205\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure AIDE to properly protect audit tools\n  lineinfile:\n    path: /etc/aide/aide.conf\n    line: '{{ item }} p+i+n+u+g+s+b+acl+xattrs+sha512'\n  with_items: '{{ audit_tools }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010205\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-AU-9(3).1\n  - aide_check_audit_tools\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "aide_check_audit_tools",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\n\n\n\n\n\n\n\n\n\nif grep -i '^.*/usr/sbin/auditctl.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/auditctl.*#/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/auditd.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/auditd.*#/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/ausearch.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/ausearch.*#/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/aureport.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/aureport.*#/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/autrace.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/autrace.*#/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/augenrules.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/augenrules.*#/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nif grep -i '^.*/usr/sbin/audispd.*$' /etc/aide/aide.conf; then\nsed -i \"s#.*/usr/sbin/audispd.*#/usr/sbin/audispd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf\nelse\necho \"/usr/sbin/audispd p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238303",
        "stig_id": "UBTU-20-010205"
      },
      "xccdf_org.ssgproject.content_rule_aide_disable_silentreports": {
        "rule_id": "xccdf_org.ssgproject.content_rule_aide_disable_silentreports",
        "title": "Configure AIDE To Notify Personnel if Baseline Configurations Are Altered",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001744",
              "CCI-002702"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000363-GPOS-00150",
              "SRG-OS-000447-GPOS-00201"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010437"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238358r917812_rule"
            ]
          }
        ],
        "description": "The operating system file integrity tool must be configured to notify designated personnel of any changes to configurations.",
        "rationale": "Detecting changes in the system can help avoid unintended, and negative consequences\nthat could affect the security state of the operating system",
        "oval_definition_id": "oval:ssg-aide_disable_silentreports:def:1",
        "remediations": [
          {
            "remediation_id": "aide_disable_silentreports",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Configure AIDE To Notify Personnel if Baseline Configurations Are Altered\n  block:\n\n  - name: Check for duplicate values\n    lineinfile:\n      path: /etc/default/aide\n      create: true\n      regexp: ^\\s*SILENTREPORTS=\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: dupes\n\n  - name: Deduplicate values from /etc/default/aide\n    lineinfile:\n      path: /etc/default/aide\n      create: true\n      regexp: ^\\s*SILENTREPORTS=\n      state: absent\n    when: dupes.found is defined and dupes.found > 1\n\n  - name: Insert correct line to /etc/default/aide\n    lineinfile:\n      path: /etc/default/aide\n      create: true\n      regexp: ^\\s*SILENTREPORTS=\n      line: SILENTREPORTS=no\n      state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010437\n  - aide_disable_silentreports\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "aide_disable_silentreports",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif [ -e \"/etc/default/aide\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*SILENTREPORTS=/Id\" \"/etc/default/aide\"\nelse\n    touch \"/etc/default/aide\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/default/aide\"\n\ncp \"/etc/default/aide\" \"/etc/default/aide.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"SILENTREPORTS=no\" >> \"/etc/default/aide\"\n# Clean up after ourselves.\nrm \"/etc/default/aide.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238358",
        "stig_id": "UBTU-20-010437"
      },
      "xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking": {
        "rule_id": "xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking",
        "title": "Configure Periodic Execution of AIDE",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R76"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.4.2"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.10.1.3"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "BAI01.06",
              "BAI02.01",
              "BAI03.05",
              "BAI06.01",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS01.03",
              "DSS03.05",
              "DSS04.07",
              "DSS05.02",
              "DSS05.03",
              "DSS05.05",
              "DSS05.07",
              "DSS06.02",
              "DSS06.06"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001744",
              "CCI-002699",
              "CCI-002702"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.4.3.2",
              "4.3.4.3.3",
              "4.3.4.4.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.1",
              "SR 3.3",
              "SR 3.4",
              "SR 3.8",
              "SR 4.1",
              "SR 6.2",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.12.1.2",
              "A.12.2.1",
              "A.12.4.1",
              "A.12.5.1",
              "A.12.6.2",
              "A.14.1.2",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.14.2.7",
              "A.15.2.1",
              "A.8.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "SI-7",
              "SI-7(1)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-7",
              "PR.DS-1",
              "PR.DS-6",
              "PR.DS-8",
              "PR.IP-1",
              "PR.IP-3"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000363-GPOS-00150",
              "SRG-OS-000446-GPOS-00200",
              "SRG-OS-000447-GPOS-00201"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-11.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "11.5.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010074"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238236r853415_rule"
            ]
          }
        ],
        "description": "At a minimum, AIDE should be configured to run a weekly scan.\nTo implement a daily execution of AIDE at 4:05am using cron, add the following line to <code>/etc/crontab</code>:\n<pre>05 4 * * * root /usr/bin/aide.wrapper --config /etc/aide/aide.conf --check</pre>\nTo implement a weekly execution of AIDE at 4:05am using cron, add the following line to <code>/etc/crontab</code>:\n<pre>05 4 * * 0 root /usr/bin/aide.wrapper --config /etc/aide/aide.conf --check</pre>\nAIDE can be executed periodically through other means; this is merely one example.\nThe usage of cron&#x27;s special time codes, such as  <code>@daily</code> and\n<code>@weekly</code> is acceptable.",
        "rationale": "By default, AIDE does not install itself for periodic execution. Periodically\nrunning AIDE is necessary to reveal unexpected changes in installed files.\n<br>\n          <br>\nUnauthorized changes to the baseline configuration could make the system vulnerable\nto various attacks or allow unauthorized access to the operating system. Changes to\noperating system configurations can have unintended side effects, some of which may\nbe relevant to security.\n<br>\n          <br>\nDetecting such changes and providing an automated response can help avoid unintended,\nnegative consequences that could ultimately affect the security state of the operating\nsystem. The operating system&#x27;s Information Management Officer (IMO)/Information System\nSecurity Officer (ISSO) and System Administrators (SAs) must be notified via email and/or\nmonitoring system trap when there is an unauthorized modification of a configuration item.",
        "oval_definition_id": "oval:ssg-aide_periodic_cron_checking:def:1",
        "remediations": [
          {
            "remediation_id": "aide_periodic_cron_checking",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Ensure AIDE is installed\n  package:\n    name: '{{ item }}'\n    state: present\n  with_items:\n  - aide\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010074\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set cron package name - RedHat\n  set_fact:\n    cron_pkg_name: cronie\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_os_family == \"RedHat\" or ansible_os_family == \"Suse\"\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010074\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set cron package name - Debian\n  set_fact:\n    cron_pkg_name: cron\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_os_family == \"Debian\"\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010074\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Install cron\n  package:\n    name: '{{ cron_pkg_name }}'\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010074\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Periodic Execution of AIDE\n  cron:\n    name: run AIDE check\n    minute: 5\n    hour: 4\n    weekday: 0\n    user: root\n    job: /usr/bin/aide.wrapper --check\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.3\n  - DISA-STIG-UBTU-20-010074\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - PCI-DSSv4-11.5.2\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "aide_periodic_cron_checking",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\"\n\n# AiDE usually adds its own cron jobs to /etc/cron.daily. If script is there, this rule is\n# compliant. Otherwise, we copy the script to the /etc/cron.weekly\nif ! grep -Eq '^(\\/usr\\/bin\\/)?aide(\\.wrapper)?\\s+' /etc/cron.*/*; then\n    cp -f /usr/share/aide/config/cron.daily/aide /etc/cron.weekly/\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238236",
        "stig_id": "UBTU-20-010074"
      },
      "xccdf_org.ssgproject.content_rule_is_fips_mode_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_is_fips_mode_enabled",
        "title": "Verify '/proc/sys/crypto/fips_enabled' exists",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002450"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "SC-12(2)",
              "SC-12(3)",
              "SC-13"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000396-GPOS-00176",
              "SRG-OS-000478-GPOS-00223"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010442"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238363r880881_rule"
            ]
          }
        ],
        "description": "On a system where FIPS 140-2 mode is enabled, <code>/proc/sys/crypto/fips_enabled</code> must exist.\nTo verify FIPS mode, run the following command:\n<pre>cat /proc/sys/crypto/fips_enabled</pre>\n        ",
        "rationale": "Use of weak or untested encryption algorithms undermines the purposes of utilizing encryption to\nprotect data. The operating system must implement cryptographic modules adhering to the higher\nstandards approved by the federal government since this provides assurance they have been tested\nand validated.",
        "warnings": [
          {
            "text": "To configure the OS to run in FIPS 140-2 mode, the kernel parameter &quot;fips=1&quot; needs to be added during its installation.\nEnabling FIPS mode on a preexisting system involves a number of modifications to it. Refer to the vendor installation \nguidances.",
            "category": "general"
          },
          {
            "text": "System Crypto Modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this, the system has to have cryptographic software provided by\na vendor that has undergone this certification. This means providing\ndocumentation, test results, design information, and independent third\nparty review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.",
            "category": "regulatory"
          }
        ],
        "oval_definition_id": "oval:ssg-is_fips_mode_enabled:def:1",
        "vuln_id": "SV-238363",
        "stig_id": "UBTU-20-010442"
      },
      "xccdf_org.ssgproject.content_rule_package_mcafeetp_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_mcafeetp_installed",
        "title": "Install McAfee Endpoint Security for Linux (ENSL)",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366",
              "CCI-001263"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "SI-2(2)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000191-GPOS-00080"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010415"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238336r858538_rule"
            ]
          }
        ],
        "description": "Install McAfee Endpoint Security for Linux antivirus software\nwhich is provided for DoD systems and uses signatures to search for the\npresence of viruses on the filesystem.\n\nThe <code>mfetp</code> package can be installed with the following command:\n<pre>\n$ apt-get install mfetp</pre>\n          ",
        "rationale": "Virus scanning software can be used to detect if a system has been compromised by\ncomputer viruses, as well as to limit their spread to other systems.",
        "warnings": [
          {
            "text": "Due to McAfee Endpoint Security for Linux (ENSL) being 3rd party software,\nautomated remediation is not available for this configuration check.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-package_mcafeetp_installed:def:1",
        "vuln_id": "SV-238336",
        "stig_id": "UBTU-20-010415"
      },
      "xccdf_org.ssgproject.content_rule_encrypt_partitions": {
        "rule_id": "xccdf_org.ssgproject.content_rule_encrypt_partitions",
        "title": "Encrypt Partitions",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "13",
              "14"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "BAI02.01",
              "BAI06.01",
              "DSS04.07",
              "DSS05.03",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02",
              "DSS06.06"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.13.16"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001199",
              "CCI-002475",
              "CCI-002476"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(b)(1)",
              "164.310(d)",
              "164.312(a)(1)",
              "164.312(a)(2)(iii)",
              "164.312(a)(2)(iv)",
              "164.312(b)",
              "164.312(c)",
              "164.312(d)",
              "164.314(b)(2)(i)"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.4",
              "SR 4.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R4.2",
              "CIP-007-3 R5.1"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-9(3)",
              "CM-6(a)",
              "SC-13",
              "SC-28",
              "SC-28(1)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.DS-1",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000185-GPOS-00079",
              "SRG-OS-000404-GPOS-00183",
              "SRG-OS-000405-GPOS-00184"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010414"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238335r654180_rule"
            ]
          }
        ],
        "description": "Ubuntu 20.04 natively supports partition encryption through the\nLinux Unified Key Setup-on-disk-format (LUKS) technology. The easiest way to\nencrypt a partition is during installation time.\n<br>\n        <br>\nFor manual installations, select the <code>Encrypt</code> checkbox during\npartition creation to encrypt the partition. When this\noption is selected the system will prompt for a passphrase to use in\ndecrypting the partition. The passphrase will subsequently need to be entered manually\nevery time the system boots.\n\n<br>\n        <br>\nDetailed information on encrypting partitions using LUKS or LUKS ciphers can be found on\nthe Ubuntu 20.04 Documentation web site:<br>\n        <a href=\"https://help.ubuntu.com/community/Full_Disk_Encryption_Howto_2019\">https://help.ubuntu.com/community/Full_Disk_Encryption_Howto_2019</a>\n.",
        "rationale": "The risk of a system&#x27;s physical compromise, particularly mobile systems such as\nlaptops, places its data at risk of compromise.  Encrypting this data mitigates\nthe risk of its loss if the system is lost.",
        "platforms": [
          "#machine"
        ],
        "vuln_id": "SV-238335",
        "stig_id": "UBTU-20-010414"
      },
      "xccdf_org.ssgproject.content_rule_enable_dconf_user_profile": {
        "rule_id": "xccdf_org.ssgproject.content_rule_enable_dconf_user_profile",
        "title": "Configure GNOME3 DConf User Profile",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.10"
            ]
          }
        ],
        "description": "By default, DConf provides a standard user profile. This profile contains a list\nof DConf configuration databases. The user profile and database always take the\nhighest priority. As such the DConf User profile should always exist and be\nconfigured correctly.\n<br>\n        <br>\n\nTo make sure that the gdm profile is configured correctly, the <code>/etc/dconf/profile/gdm</code>\nshould be set as follows:\n<pre>user-db:user\nsystem-db:gdm\n</pre>\nTo make sure that the user profile is configured correctly, the <code>/etc/dconf/profile/user</code>\nshould be set as follows:\n<pre>user-db:user\nsystem-db:local\n</pre>\n       ",
        "rationale": "Failure to have a functional DConf profile prevents GNOME3 configuration settings\nfrom being enforced for all users and allows various security risks.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-enable_dconf_user_profile:def:1",
        "remediations": [
          {
            "remediation_id": "enable_dconf_user_profile",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'gdm3' 2>/dev/null | grep -q installed && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\n# configure two dconf profiles:\n# - gdm: required for banner/user_list settings\n# - user: required for screenlock,automount,ctrlaltdel,... settings\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": null,
        "stig_id": null
      },
      "xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_enabled",
        "title": "Enable GNOME3 Screensaver Lock After Idle Period",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000056",
              "CCI-000058",
              "CCI-000060"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000028-GPOS-00009",
              "SRG-OS-000030-GPOS-00011"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_MOF_EXT.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.1.8"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.2.8"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010004"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238199r653772_rule"
            ]
          }
        ],
        "description": "\nTo activate locking of the screensaver in the GNOME3 desktop when it is activated,\nadd or set <code>lock-enabled</code> to <code>true</code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/desktop/screensaver]\nlock-enabled=true\n</pre>\nOnce the settings have been added, add a lock to\n<code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/desktop/screensaver/lock-enabled</pre>\nAfter the settings have been set, run <code>dconf update</code>.",
        "rationale": "A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity\nof the information system but does not want to logout because of the temporary nature of the absense.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-dconf_gnome_screensaver_lock_enabled:def:1",
        "remediations": [
          {
            "remediation_id": "dconf_gnome_screensaver_lock_enabled",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'gdm3' 2>/dev/null | grep -q installed && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|local.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*lock-enabled\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)lock-enabled(\\s*=)/#\\1lock-enabled\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/desktop/screensaver]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"true\")\"\nif grep -q \"^\\\\s*lock-enabled\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*lock-enabled\\\\s*=\\\\s*.*/lock-enabled=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/screensaver\\\\]|a\\\\lock-enabled=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/screensaver/lock-enabled$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|local.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/desktop/screensaver/lock-enabled$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/desktop/screensaver/lock-enabled$\" /etc/dconf/db/local.d/\nthen\n    echo \"/org/gnome/desktop/screensaver/lock-enabled\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238199",
        "stig_id": "UBTU-20-010004"
      },
      "xccdf_org.ssgproject.content_rule_dconf_gnome_disable_ctrlaltdel_reboot": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_disable_ctrlaltdel_reboot",
        "title": "Disable Ctrl-Alt-Del Reboot Key Sequence in GNOME3",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.2"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-6(a)",
              "CM-7(b)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010459"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238379r654312_rule"
            ]
          }
        ],
        "description": "By default, <code>GNOME</code> will reboot the system if the\n<code>Ctrl-Alt-Del</code> key sequence is pressed.\n<br>\n         <br>\nTo configure the system to ignore the <code>Ctrl-Alt-Del</code> key sequence\nfrom the Graphical User Interface (GUI) instead of rebooting the system,\nadd or set <code>logout</code> to <code>[&#x27;&#x27;]</code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/settings-daemon/plugins/media-keys]\nlogout=[&#x27;&#x27;]</pre>\nOnce the settings have been added, add a lock to\n<code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent\nuser modification. For example:\n<pre>/org/gnome/settings-daemon/plugins/media-keys/logout</pre>\nAfter the settings have been set, run <code>dconf update</code>.",
        "rationale": "A locally logged-in user who presses Ctrl-Alt-Del, when at the console,\ncan reboot the system. If accidentally pressed, as could happen in\nthe case of mixed OS environment, this can create the risk of short-term\nloss of availability of systems due to unintentional reboot.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-dconf_gnome_disable_ctrlaltdel_reboot:def:1",
        "remediations": [
          {
            "remediation_id": "dconf_gnome_disable_ctrlaltdel_reboot",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'gdm3' 2>/dev/null | grep -q installed && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|local.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*logout\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)logout(\\s*=)/#\\1logout\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/settings-daemon/plugins/media-keys]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"['']\")\"\nif grep -q \"^\\\\s*logout\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*logout\\\\s*=\\\\s*.*/logout=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]|a\\\\logout=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/settings-daemon/plugins/media-keys/logout$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|local.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/settings-daemon/plugins/media-keys/logout$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/settings-daemon/plugins/media-keys/logout$\" /etc/dconf/db/local.d/\nthen\n    echo \"/org/gnome/settings-daemon/plugins/media-keys/logout\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238379",
        "stig_id": "UBTU-20-010459"
      },
      "xccdf_org.ssgproject.content_rule_sudo_require_authentication": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sudo_require_authentication",
        "title": "Ensure Users Re-Authenticate for Privilege Escalation - sudo",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002038"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.5.1",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-11"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000373-GPOS-00156"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010014"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238208r853405_rule"
            ]
          }
        ],
        "description": "The sudo <code>NOPASSWD</code> and <code>!authenticate</code> option, when\nspecified, allows a user to execute commands using sudo without having to\nauthenticate. This should be disabled by making sure that\n<code>NOPASSWD</code> and/or <code>!authenticate</code> do not exist in\n<code>/etc/sudoers</code> configuration file or any sudo configuration snippets\nin <code>/etc/sudoers.d/</code>.&quot;",
        "rationale": "Without re-authentication, users may access resources or perform tasks for which they\ndo not have authorization.\n<br>\n        <br>\nWhen operating systems provide the capability to escalate a functional capability, it\nis critical that the user re-authenticate.",
        "oval_definition_id": "oval:ssg-sudo_require_authentication:def:1",
        "remediations": [
          {
            "remediation_id": "sudo_require_authentication",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Find /etc/sudoers.d/ files\n  ansible.builtin.find:\n    paths:\n    - /etc/sudoers.d/\n  register: sudoers\n  tags:\n  - DISA-STIG-UBTU-20-010014\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n\n- name: Remove lines containing NOPASSWD from sudoers files\n  ansible.builtin.replace:\n    regexp: (^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$)\n    replace: '# \\g<1>'\n    path: '{{ item.path }}'\n    validate: /usr/sbin/visudo -cf %s\n  with_items:\n  - path: /etc/sudoers\n  - '{{ sudoers.files }}'\n  tags:\n  - DISA-STIG-UBTU-20-010014\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n\n- name: Find /etc/sudoers.d/ files\n  ansible.builtin.find:\n    paths:\n    - /etc/sudoers.d/\n  register: sudoers\n  tags:\n  - DISA-STIG-UBTU-20-010014\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n\n- name: Remove lines containing !authenticate from sudoers files\n  ansible.builtin.replace:\n    regexp: (^(?!#).*[\\s]+\\!authenticate.*$)\n    replace: '# \\g<1>'\n    path: '{{ item.path }}'\n    validate: /usr/sbin/visudo -cf %s\n  with_items:\n  - path: /etc/sudoers\n  - '{{ sudoers.files }}'\n  tags:\n  - DISA-STIG-UBTU-20-010014\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-11\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sudo_require_authentication\n"
          },
          {
            "remediation_id": "sudo_require_authentication",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "\nfor f in /etc/sudoers /etc/sudoers.d/* ; do\n  if [ ! -e \"$f\" ] ; then\n    continue\n  fi\n  matching_list=$(grep -P '^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      # comment out \"NOPASSWD\" matches to preserve user data\n      sed -i \"s/^${entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n\n    /usr/sbin/visudo -cf $f &> /dev/null || echo \"Fail to validate $f with visudo\"\n  fi\ndone\n\nfor f in /etc/sudoers /etc/sudoers.d/* ; do\n  if [ ! -e \"$f\" ] ; then\n    continue\n  fi\n  matching_list=$(grep -P '^(?!#).*[\\s]+\\!authenticate.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      # comment out \"!authenticate\" matches to preserve user data\n      sed -i \"s/^${entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n\n    /usr/sbin/visudo -cf $f &> /dev/null || echo \"Fail to validate $f with visudo\"\n  fi\ndone\n"
          }
        ],
        "vuln_id": "SV-238208",
        "stig_id": "UBTU-20-010014"
      },
      "xccdf_org.ssgproject.content_rule_clean_components_post_updating": {
        "rule_id": "xccdf_org.ssgproject.content_rule_clean_components_post_updating",
        "title": "Ensure apt_get Removes Previous Package Versions",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "low",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "18",
              "20",
              "4"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO12.01",
              "APO12.02",
              "APO12.03",
              "APO12.04",
              "BAI03.10",
              "DSS05.01",
              "DSS05.02"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.4.8"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002617"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3",
              "4.2.3.12",
              "4.2.3.7",
              "4.2.3.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.6.1",
              "A.14.2.3",
              "A.16.1.3",
              "A.18.2.2",
              "A.18.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-11(a)",
              "CM-11(b)",
              "CM-6(a)",
              "SI-2(6)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "ID.RA-1",
              "PR.IP-12"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000437-GPOS-00194"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010449"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238370r853447_rule"
            ]
          }
        ],
        "description": "<code>apt_get</code> should be configured to remove previous software components after\nnew versions have been installed. To configure <code>apt_get</code> to remove the\n\nprevious software components after updating, set the <code>::Remove-Unused-Dependencies</code> and\n<code>::Remove-Unused-Kernel-Packages</code>\n\n\nto <code>true</code> in <code>/etc/apt/apt.conf</code>.",
        "rationale": "Previous versions of software components that are not removed from the information\nsystem after updates have been installed may be exploited by some adversaries.",
        "oval_definition_id": "oval:ssg-clean_components_post_updating:def:1",
        "remediations": [
          {
            "remediation_id": "clean_components_post_updating",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "\nflag1=1\nflag2=1\n\nfor file in /etc/apt/apt.conf.d/*; do\n    if [ -e \"$file\" ]; then\n        if grep -qi \"Unattended-Upgrade::Remove-Unused-Dependencies\" $file; then\n            sed -i --follow-symlinks \"s/^.*Unattended-Upgrade::Remove-Unused-Dependencies.*/Unattended-Upgrade::Remove-Unused-Dependencies \\\"true\\\";/I\" $file\n            flag1=0\n        fi\n\n        if grep -qi \"Unattended-Upgrade::Remove-Unused-Kernel-Packages\" $file; then\n            sed -i --follow-symlinks \"s/^.*Unattended-Upgrade::Remove-Unused-Kernel-Packages.*/Unattended-Upgrade::Remove-Unused-Kernel-Packages \\\"true\\\";/I\" $file\n            flag2=0\n        fi\n    fi\ndone\n\nif [ $flag1 ] || [ $flag2 ]; then\n    echo \"Unattended-Upgrade::Remove-Unused-Dependencies \\\"true\\\";\" >> /etc/apt/apt.conf.d/50unattended-upgrades\n    echo \"Unattended-Upgrade::Remove-Unused-Kernel-Packages \\\"true\\\";\" >> /etc/apt/apt.conf.d/50unattended-upgrades\nfi\n"
          }
        ],
        "vuln_id": "SV-238370",
        "stig_id": "UBTU-20-010449"
      },
      "xccdf_org.ssgproject.content_rule_banner_etc_issue_net": {
        "rule_id": "xccdf_org.ssgproject.content_rule_banner_etc_issue_net",
        "title": "Modify the System Login Banner for Remote Connections",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.8.1.3"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000048",
              "CCI-001384",
              "CCI-001385",
              "CCI-001386",
              "CCI-001387",
              "CCI-001388"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000023-GPOS-00006",
              "SRG-OS-000228-GPOS-00088"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010038"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238214r858525_rule"
            ]
          }
        ],
        "description": "To configure the system login banner edit <code>/etc/issue.net</code>. Replace the\ndefault text with a message compliant with the local site policy or a legal\ndisclaimer.\n\nThe DoD required text is either:\n<br>\n        <br>\n        <code>You are accessing a U.S. Government (USG) Information System (IS) that\nis provided for USG-authorized use only. By using this IS (which includes\nany device attached to this IS), you consent to the following conditions:\n<br>-The USG routinely intercepts and monitors communications on this IS\nfor purposes including, but not limited to, penetration testing, COMSEC\nmonitoring, network operations and defense, personnel misconduct (PM), law\nenforcement (LE), and counterintelligence (CI) investigations.\n<br>-At any time, the USG may inspect and seize data stored on this IS.\n<br>-Communications using, or data stored on, this IS are not private,\nare subject to routine monitoring, interception, and search, and may be\ndisclosed or used for any USG-authorized purpose.\n<br>-This IS includes security measures (e.g., authentication and access\ncontrols) to protect USG interests -- not for your personal benefit or\nprivacy.\n<br>-Notwithstanding the above, using this IS does not constitute consent\nto PM, LE or CI investigative searching or monitoring of the content of\nprivileged communications, or work product, related to personal\nrepresentation or services by attorneys, psychotherapists, or clergy, and\ntheir assistants. Such communications and work product are private and\nconfidential. See User Agreement for details.</code>\n        <br>\n        <br>\nOR:\n<br>\n        <br>\n        <code>I&#x27;ve read &amp; consent to terms in IS user agreem&#x27;t.</code>\n       ",
        "rationale": "Display of a standardized and approved use notification before granting\naccess to the operating system ensures privacy and security notification\nverbiage used is consistent with applicable federal laws, Executive Orders,\ndirectives, policies, regulations, standards, and guidance.\n<br>\n        <br>\nSystem use notifications are required only for access via login interfaces\nwith human users and are not required when such human interfaces do not\nexist.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-banner_etc_issue_net:def:1",
        "remediations": [
          {
            "remediation_id": "banner_etc_issue_net",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "unknown",
            "fix": "- name: XCCDF Value remote_login_banner_text # promote to variable\n  set_fact:\n    remote_login_banner_text: !!str ^(You[\\s\\n]+are[\\s\\n]+accessing[\\s\\n]+a[\\s\\n]+U\\.S\\.[\\s\\n]+Government[\\s\\n]+\\(USG\\)[\\s\\n]+Information[\\s\\n]+System[\\s\\n]+\\(IS\\)[\\s\\n]+that[\\s\\n]+is[\\s\\n]+provided[\\s\\n]+for[\\s\\n]+USG\\-authorized[\\s\\n]+use[\\s\\n]+only\\.[\\s\\n]+By[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+\\(which[\\s\\n]+includes[\\s\\n]+any[\\s\\n]+device[\\s\\n]+attached[\\s\\n]+to[\\s\\n]+this[\\s\\n]+IS\\),[\\s\\n]+you[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+the[\\s\\n]+following[\\s\\n]+conditions\\:(?:[\\n]+|(?:\\\\n)+)\\-The[\\s\\n]+USG[\\s\\n]+routinely[\\s\\n]+intercepts[\\s\\n]+and[\\s\\n]+monitors[\\s\\n]+communications[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+for[\\s\\n]+purposes[\\s\\n]+including,[\\s\\n]+but[\\s\\n]+not[\\s\\n]+limited[\\s\\n]+to,[\\s\\n]+penetration[\\s\\n]+testing,[\\s\\n]+COMSEC[\\s\\n]+monitoring,[\\s\\n]+network[\\s\\n]+operations[\\s\\n]+and[\\s\\n]+defense,[\\s\\n]+personnel[\\s\\n]+misconduct[\\s\\n]+\\(PM\\),[\\s\\n]+law[\\s\\n]+enforcement[\\s\\n]+\\(LE\\),[\\s\\n]+and[\\s\\n]+counterintelligence[\\s\\n]+\\(CI\\)[\\s\\n]+investigations\\.(?:[\\n]+|(?:\\\\n)+)\\-At[\\s\\n]+any[\\s\\n]+time,[\\s\\n]+the[\\s\\n]+USG[\\s\\n]+may[\\s\\n]+inspect[\\s\\n]+and[\\s\\n]+seize[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS\\.(?:[\\n]+|(?:\\\\n)+)\\-Communications[\\s\\n]+using,[\\s\\n]+or[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on,[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+are[\\s\\n]+not[\\s\\n]+private,[\\s\\n]+are[\\s\\n]+subject[\\s\\n]+to[\\s\\n]+routine[\\s\\n]+monitoring,[\\s\\n]+interception,[\\s\\n]+and[\\s\\n]+search,[\\s\\n]+and[\\s\\n]+may[\\s\\n]+be[\\s\\n]+disclosed[\\s\\n]+or[\\s\\n]+used[\\s\\n]+for[\\s\\n]+any[\\s\\n]+USG\\-authorized[\\s\\n]+purpose\\.(?:[\\n]+|(?:\\\\n)+)\\-This[\\s\\n]+IS[\\s\\n]+includes[\\s\\n]+security[\\s\\n]+measures[\\s\\n]+\\(e\\.g\\.,[\\s\\n]+authentication[\\s\\n]+and[\\s\\n]+access[\\s\\n]+controls\\)[\\s\\n]+to[\\s\\n]+protect[\\s\\n]+USG[\\s\\n]+interests\\-\\-not[\\s\\n]+for[\\s\\n]+your[\\s\\n]+personal[\\s\\n]+benefit[\\s\\n]+or[\\s\\n]+privacy\\.(?:[\\n]+|(?:\\\\n)+)\\-Notwithstanding[\\s\\n]+the[\\s\\n]+above,[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+does[\\s\\n]+not[\\s\\n]+constitute[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+PM,[\\s\\n]+LE[\\s\\n]+or[\\s\\n]+CI[\\s\\n]+investigative[\\s\\n]+searching[\\s\\n]+or[\\s\\n]+monitoring[\\s\\n]+of[\\s\\n]+the[\\s\\n]+content[\\s\\n]+of[\\s\\n]+privileged[\\s\\n]+communications,[\\s\\n]+or[\\s\\n]+work[\\s\\n]+product,[\\s\\n]+related[\\s\\n]+to[\\s\\n]+personal[\\s\\n]+representation[\\s\\n]+or[\\s\\n]+services[\\s\\n]+by[\\s\\n]+attorneys,[\\s\\n]+psychotherapists,[\\s\\n]+or[\\s\\n]+clergy,[\\s\\n]+and[\\s\\n]+their[\\s\\n]+assistants\\.[\\s\\n]+Such[\\s\\n]+communications[\\s\\n]+and[\\s\\n]+work[\\s\\n]+product[\\s\\n]+are[\\s\\n]+private[\\s\\n]+and[\\s\\n]+confidential\\.[\\s\\n]+See[\\s\\n]+User[\\s\\n]+Agreement[\\s\\n]+for[\\s\\n]+details\\.|I've[\\s\\n]+read[\\s\\n]+\\&[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+terms[\\s\\n]+in[\\s\\n]+IS[\\s\\n]+user[\\s\\n]+agreem't\\.)$\n  tags:\n    - always\n\n- name: Modify the System Login Banner for Remote Connections - ensure correct banner\n  copy:\n    dest: /etc/issue.net\n    content: '{{ remote_login_banner_text | regex_replace(\"^\\^(.*)\\$$\", \"\\1\") | regex_replace(\"^\\((.*\\.)\\|.*\\)$\",\n      \"\\1\") | regex_replace(\"\\[\\\\s\\\\n\\]\\+\",\" \") | regex_replace(\"\\(\\?:\\[\\\\n\\]\\+\\|\\(\\?:\\\\\\\\n\\)\\+\\)\",\n      \"\\n\") | regex_replace(\"\\\\\", \"\") | wordwrap() }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010038\n  - banner_etc_issue_net\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"
          },
          {
            "remediation_id": "banner_etc_issue_net",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nremote_login_banner_text='^(You[\\s\\n]+are[\\s\\n]+accessing[\\s\\n]+a[\\s\\n]+U\\.S\\.[\\s\\n]+Government[\\s\\n]+\\(USG\\)[\\s\\n]+Information[\\s\\n]+System[\\s\\n]+\\(IS\\)[\\s\\n]+that[\\s\\n]+is[\\s\\n]+provided[\\s\\n]+for[\\s\\n]+USG\\-authorized[\\s\\n]+use[\\s\\n]+only\\.[\\s\\n]+By[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+\\(which[\\s\\n]+includes[\\s\\n]+any[\\s\\n]+device[\\s\\n]+attached[\\s\\n]+to[\\s\\n]+this[\\s\\n]+IS\\),[\\s\\n]+you[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+the[\\s\\n]+following[\\s\\n]+conditions\\:(?:[\\n]+|(?:\\\\n)+)\\-The[\\s\\n]+USG[\\s\\n]+routinely[\\s\\n]+intercepts[\\s\\n]+and[\\s\\n]+monitors[\\s\\n]+communications[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+for[\\s\\n]+purposes[\\s\\n]+including,[\\s\\n]+but[\\s\\n]+not[\\s\\n]+limited[\\s\\n]+to,[\\s\\n]+penetration[\\s\\n]+testing,[\\s\\n]+COMSEC[\\s\\n]+monitoring,[\\s\\n]+network[\\s\\n]+operations[\\s\\n]+and[\\s\\n]+defense,[\\s\\n]+personnel[\\s\\n]+misconduct[\\s\\n]+\\(PM\\),[\\s\\n]+law[\\s\\n]+enforcement[\\s\\n]+\\(LE\\),[\\s\\n]+and[\\s\\n]+counterintelligence[\\s\\n]+\\(CI\\)[\\s\\n]+investigations\\.(?:[\\n]+|(?:\\\\n)+)\\-At[\\s\\n]+any[\\s\\n]+time,[\\s\\n]+the[\\s\\n]+USG[\\s\\n]+may[\\s\\n]+inspect[\\s\\n]+and[\\s\\n]+seize[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS\\.(?:[\\n]+|(?:\\\\n)+)\\-Communications[\\s\\n]+using,[\\s\\n]+or[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on,[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+are[\\s\\n]+not[\\s\\n]+private,[\\s\\n]+are[\\s\\n]+subject[\\s\\n]+to[\\s\\n]+routine[\\s\\n]+monitoring,[\\s\\n]+interception,[\\s\\n]+and[\\s\\n]+search,[\\s\\n]+and[\\s\\n]+may[\\s\\n]+be[\\s\\n]+disclosed[\\s\\n]+or[\\s\\n]+used[\\s\\n]+for[\\s\\n]+any[\\s\\n]+USG\\-authorized[\\s\\n]+purpose\\.(?:[\\n]+|(?:\\\\n)+)\\-This[\\s\\n]+IS[\\s\\n]+includes[\\s\\n]+security[\\s\\n]+measures[\\s\\n]+\\(e\\.g\\.,[\\s\\n]+authentication[\\s\\n]+and[\\s\\n]+access[\\s\\n]+controls\\)[\\s\\n]+to[\\s\\n]+protect[\\s\\n]+USG[\\s\\n]+interests\\-\\-not[\\s\\n]+for[\\s\\n]+your[\\s\\n]+personal[\\s\\n]+benefit[\\s\\n]+or[\\s\\n]+privacy\\.(?:[\\n]+|(?:\\\\n)+)\\-Notwithstanding[\\s\\n]+the[\\s\\n]+above,[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+does[\\s\\n]+not[\\s\\n]+constitute[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+PM,[\\s\\n]+LE[\\s\\n]+or[\\s\\n]+CI[\\s\\n]+investigative[\\s\\n]+searching[\\s\\n]+or[\\s\\n]+monitoring[\\s\\n]+of[\\s\\n]+the[\\s\\n]+content[\\s\\n]+of[\\s\\n]+privileged[\\s\\n]+communications,[\\s\\n]+or[\\s\\n]+work[\\s\\n]+product,[\\s\\n]+related[\\s\\n]+to[\\s\\n]+personal[\\s\\n]+representation[\\s\\n]+or[\\s\\n]+services[\\s\\n]+by[\\s\\n]+attorneys,[\\s\\n]+psychotherapists,[\\s\\n]+or[\\s\\n]+clergy,[\\s\\n]+and[\\s\\n]+their[\\s\\n]+assistants\\.[\\s\\n]+Such[\\s\\n]+communications[\\s\\n]+and[\\s\\n]+work[\\s\\n]+product[\\s\\n]+are[\\s\\n]+private[\\s\\n]+and[\\s\\n]+confidential\\.[\\s\\n]+See[\\s\\n]+User[\\s\\n]+Agreement[\\s\\n]+for[\\s\\n]+details\\.|I've[\\s\\n]+read[\\s\\n]+\\&[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+terms[\\s\\n]+in[\\s\\n]+IS[\\s\\n]+user[\\s\\n]+agreem't\\.)$'\n\n\n# Multiple regexes transform the banner regex into a usable banner\n# 0 - Remove anchors around the banner text\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/^\\^\\(.*\\)\\$$/\\1/g')\n# 1 - Keep only the first banners if there are multiple\n#    (dod_banners contains the long and short banner)\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/^(\\(.*\\.\\)|.*)$/\\1/g')\n# 2 - Add spaces ' '. (Transforms regex for \"space or newline\" into a \" \")\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/\\[\\\\s\\\\n\\]+/ /g')\n# 3 - Adds newlines. (Transforms \"(?:\\[\\\\n\\]+|(?:\\\\n)+)\" into \"\\n\")\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/(?:\\[\\\\n\\]+|(?:\\\\\\\\n)+)/\\n/g')\n# 4 - Remove any leftover backslash. (From any parethesis in the banner, for example).\nremote_login_banner_text=$(echo \"$remote_login_banner_text\" | sed 's/\\\\//g')\nformatted=$(echo \"$remote_login_banner_text\" | fold -sw 80)\n\ncat <<EOF >/etc/issue.net\n$formatted\nEOF\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238214",
        "stig_id": "UBTU-20-010038"
      },
      "xccdf_org.ssgproject.content_rule_dconf_gnome_banner_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_banner_enabled",
        "title": "Enable GNOME3 Login Warning Banner",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.9"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000048",
              "CCI-000050",
              "CCI-001384",
              "CCI-001385",
              "CCI-001386",
              "CCI-001387",
              "CCI-001388"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-8(a)",
              "AC-8(b)",
              "AC-8(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000023-GPOS-00006",
              "SRG-OS-000228-GPOS-00088"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_MOF_EXT.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010002"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238197r653766_rule"
            ]
          }
        ],
        "description": "In the default graphical environment, displaying a login warning banner\nin the GNOME Display Manager&#x27;s login screen can be enabled on the login\nscreen by setting <code>banner-message-enable</code> to <code>true</code>.\n<br>\n         <br>\nTo enable, add or edit <code>banner-message-enable</code> to\n<code>/etc/dconf/db/gdm.d/00-security-settings</code>. For example:\n<pre>[org/gnome/login-screen]\nbanner-message-enable=true</pre>\nOnce the setting has been added, add a lock to\n<code>/etc/dconf/db/gdm.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/login-screen/banner-message-enable</pre>\nAfter the settings have been set, run <code>dconf update</code>.\nThe banner text must also be set.",
        "rationale": "Display of a standardized and approved use notification before granting access to the operating system\nensures privacy and security notification verbiage used is consistent with applicable federal laws,\nExecutive Orders, directives, policies, regulations, standards, and guidance.\n<br>\n         <br>\nFor U.S. Government systems, system use notifications are required only for access via login interfaces\nwith human users and are not required when such human interfaces do not exist.",
        "oval_definition_id": "oval:ssg-dconf_gnome_banner_enabled:def:1",
        "remediations": [
          {
            "remediation_id": "dconf_gnome_banner_enabled",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'gdm3' 2>/dev/null | grep -q installed; then\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n# Duplicate the setting also in 'greeter.dconf-defaults' for consistency with\n# 'dconf_gnome_login_banner_text' and better alignment with STIG V1R1.\nif [ -e \"/etc/gdm3/greeter.dconf-defaults\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*banner\\-message\\-enable/Id\" \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    touch \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/gdm3/greeter.dconf-defaults\"\n\ncp \"/etc/gdm3/greeter.dconf-defaults\" \"/etc/gdm3/greeter.dconf-defaults.bak\"\n# Insert after the line matching the regex '\\[org/gnome/login-screen\\]'\nline_number=\"$(LC_ALL=C grep -n \"\\[org/gnome/login-screen\\]\" \"/etc/gdm3/greeter.dconf-defaults.bak\" | LC_ALL=C sed 's/:.*//g')\"\nif [ -z \"$line_number\" ]; then\n    # There was no match of '\\[org/gnome/login-screen\\]', insert at\n    # the end of the file.\n    printf '%s\\n' \"banner-message-enable=true\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    head -n \"$(( line_number ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" > \"/etc/gdm3/greeter.dconf-defaults\"\n    printf '%s\\n' \"banner-message-enable=true\" >> \"/etc/gdm3/greeter.dconf-defaults\"\n    tail -n \"+$(( line_number + 1 ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# Clean up after ourselves.\nrm \"/etc/gdm3/greeter.dconf-defaults.bak\"\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|gdm.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/gdm.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*banner-message-enable\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)banner-message-enable(\\s*=)/#\\1banner-message-enable\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/login-screen\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/login-screen]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"true\")\"\nif grep -q \"^\\\\s*banner-message-enable\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*banner-message-enable\\\\s*=\\\\s*.*/banner-message-enable=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\banner-message-enable=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/login-screen/banner-message-enable$\" \"/etc/dconf/db/\" \\\n            | grep -v 'distro\\|ibus\\|gdm.d' | grep \":\" | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/gdm.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\n# Comment out the configurations in databases different from the target one\nif [[ ! -z \"${LOCKFILES}\" ]]\nthen\n    sed -i -E \"s|^/org/gnome/login-screen/banner-message-enable$|#&|\" \"${LOCKFILES[@]}\"\nfi\n\nif ! grep -qr \"^/org/gnome/login-screen/banner-message-enable$\" /etc/dconf/db/gdm.d/\nthen\n    echo \"/org/gnome/login-screen/banner-message-enable\" >> \"/etc/dconf/db/gdm.d/locks/00-security-settings-lock\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238197",
        "stig_id": "UBTU-20-010002"
      },
      "xccdf_org.ssgproject.content_rule_dconf_gnome_login_banner_text": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_login_banner_text",
        "title": "Set the GNOME3 Login Warning Banner Text",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.9"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000048",
              "CCI-001384",
              "CCI-001385",
              "CCI-001386",
              "CCI-001387",
              "CCI-001388"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-8(a)",
              "AC-8(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000023-GPOS-00006",
              "SRG-OS-000228-GPOS-00088"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_MOF_EXT.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010003"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238198r653769_rule"
            ]
          }
        ],
        "description": "In the default graphical environment, configuring the login warning banner text\nin the GNOME Display Manager&#x27;s login screen can be configured on the login\nscreen by setting <code>banner-message-text</code> to <code>&#x27;<i>APPROVED_BANNER</i>&#x27;</code>\nwhere <i>APPROVED_BANNER</i> is the approved banner for your environment.\n<br>\n         <br>\nTo enable, add or edit <code>banner-message-text</code> to\n\n<code>/etc/gdm3/greeter.dconf-defaults</code>. For example:\n<pre>[org/gnome/login-screen]\nbanner-message-text=&#x27;<i>APPROVED_BANNER</i>&#x27;</pre>\n\nAfter the settings have been set, run <code>dconf update</code>.\nWhen entering a warning banner that spans several lines, remember\nto begin and end the string with <code>&#x27;</code> and use <code>\\n</code> for new lines.",
        "rationale": "An appropriate warning message reinforces policy awareness during the logon\nprocess and facilitates possible legal action against attackers.",
        "oval_definition_id": "oval:ssg-dconf_gnome_login_banner_text:def:1",
        "remediations": [
          {
            "remediation_id": "dconf_gnome_login_banner_text",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'gdm3' 2>/dev/null | grep -q installed; then\n\nlogin_banner_text='^(You[\\s\\n]+are[\\s\\n]+accessing[\\s\\n]+a[\\s\\n]+U\\.S\\.[\\s\\n]+Government[\\s\\n]+\\(USG\\)[\\s\\n]+Information[\\s\\n]+System[\\s\\n]+\\(IS\\)[\\s\\n]+that[\\s\\n]+is[\\s\\n]+provided[\\s\\n]+for[\\s\\n]+USG\\-authorized[\\s\\n]+use[\\s\\n]+only\\.[\\s\\n]+By[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+\\(which[\\s\\n]+includes[\\s\\n]+any[\\s\\n]+device[\\s\\n]+attached[\\s\\n]+to[\\s\\n]+this[\\s\\n]+IS\\),[\\s\\n]+you[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+the[\\s\\n]+following[\\s\\n]+conditions\\:(?:[\\n]+|(?:\\\\n)+)\\-The[\\s\\n]+USG[\\s\\n]+routinely[\\s\\n]+intercepts[\\s\\n]+and[\\s\\n]+monitors[\\s\\n]+communications[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+for[\\s\\n]+purposes[\\s\\n]+including,[\\s\\n]+but[\\s\\n]+not[\\s\\n]+limited[\\s\\n]+to,[\\s\\n]+penetration[\\s\\n]+testing,[\\s\\n]+COMSEC[\\s\\n]+monitoring,[\\s\\n]+network[\\s\\n]+operations[\\s\\n]+and[\\s\\n]+defense,[\\s\\n]+personnel[\\s\\n]+misconduct[\\s\\n]+\\(PM\\),[\\s\\n]+law[\\s\\n]+enforcement[\\s\\n]+\\(LE\\),[\\s\\n]+and[\\s\\n]+counterintelligence[\\s\\n]+\\(CI\\)[\\s\\n]+investigations\\.(?:[\\n]+|(?:\\\\n)+)\\-At[\\s\\n]+any[\\s\\n]+time,[\\s\\n]+the[\\s\\n]+USG[\\s\\n]+may[\\s\\n]+inspect[\\s\\n]+and[\\s\\n]+seize[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on[\\s\\n]+this[\\s\\n]+IS\\.(?:[\\n]+|(?:\\\\n)+)\\-Communications[\\s\\n]+using,[\\s\\n]+or[\\s\\n]+data[\\s\\n]+stored[\\s\\n]+on,[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+are[\\s\\n]+not[\\s\\n]+private,[\\s\\n]+are[\\s\\n]+subject[\\s\\n]+to[\\s\\n]+routine[\\s\\n]+monitoring,[\\s\\n]+interception,[\\s\\n]+and[\\s\\n]+search,[\\s\\n]+and[\\s\\n]+may[\\s\\n]+be[\\s\\n]+disclosed[\\s\\n]+or[\\s\\n]+used[\\s\\n]+for[\\s\\n]+any[\\s\\n]+USG\\-authorized[\\s\\n]+purpose\\.(?:[\\n]+|(?:\\\\n)+)\\-This[\\s\\n]+IS[\\s\\n]+includes[\\s\\n]+security[\\s\\n]+measures[\\s\\n]+\\(e\\.g\\.,[\\s\\n]+authentication[\\s\\n]+and[\\s\\n]+access[\\s\\n]+controls\\)[\\s\\n]+to[\\s\\n]+protect[\\s\\n]+USG[\\s\\n]+interests\\-\\-not[\\s\\n]+for[\\s\\n]+your[\\s\\n]+personal[\\s\\n]+benefit[\\s\\n]+or[\\s\\n]+privacy\\.(?:[\\n]+|(?:\\\\n)+)\\-Notwithstanding[\\s\\n]+the[\\s\\n]+above,[\\s\\n]+using[\\s\\n]+this[\\s\\n]+IS[\\s\\n]+does[\\s\\n]+not[\\s\\n]+constitute[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+PM,[\\s\\n]+LE[\\s\\n]+or[\\s\\n]+CI[\\s\\n]+investigative[\\s\\n]+searching[\\s\\n]+or[\\s\\n]+monitoring[\\s\\n]+of[\\s\\n]+the[\\s\\n]+content[\\s\\n]+of[\\s\\n]+privileged[\\s\\n]+communications,[\\s\\n]+or[\\s\\n]+work[\\s\\n]+product,[\\s\\n]+related[\\s\\n]+to[\\s\\n]+personal[\\s\\n]+representation[\\s\\n]+or[\\s\\n]+services[\\s\\n]+by[\\s\\n]+attorneys,[\\s\\n]+psychotherapists,[\\s\\n]+or[\\s\\n]+clergy,[\\s\\n]+and[\\s\\n]+their[\\s\\n]+assistants\\.[\\s\\n]+Such[\\s\\n]+communications[\\s\\n]+and[\\s\\n]+work[\\s\\n]+product[\\s\\n]+are[\\s\\n]+private[\\s\\n]+and[\\s\\n]+confidential\\.[\\s\\n]+See[\\s\\n]+User[\\s\\n]+Agreement[\\s\\n]+for[\\s\\n]+details\\.|I've[\\s\\n]+read[\\s\\n]+\\&[\\s\\n]+consent[\\s\\n]+to[\\s\\n]+terms[\\s\\n]+in[\\s\\n]+IS[\\s\\n]+user[\\s\\n]+agreem't\\.)$'\n\n\n# Multiple regexes transform the banner regex into a usable banner\n# 0 - Remove anchors around the banner text\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/^\\^\\(.*\\)\\$$/\\1/g')\n# 1 - Keep only the first banners if there are multiple\n#    (dod_banners contains the long and short banner)\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/^(\\(.*\\.\\)|.*)$/\\1/g')\n# 2 - Add spaces ' '. (Transforms regex for \"space or newline\" into a \" \")\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/\\[\\\\s\\\\n\\]+/ /g')\n# 3 - Adds newline \"tokens\". (Transforms \"(?:\\[\\\\n\\]+|(?:\\\\n)+)\" into \"(n)*\")\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/(?:\\[\\\\n\\]+|(?:\\\\\\\\n)+)/(n)*/g')\n# 4 - Remove any leftover backslash. (From any parethesis in the banner, for example).\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/\\\\//g')\n# 5 - Removes the newline \"token.\" (Transforms them into newline escape sequences \"\\n\").\n#    ( Needs to be done after 4, otherwise the escapce sequence will become just \"n\".\nlogin_banner_text=$(echo \"$login_banner_text\" | sed 's/(n)\\*/\\\\n/g')\n\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/user\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:local\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:local\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/local.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\nmkdir -p /etc/dconf/profile\ndconf_profile_path=/etc/dconf/profile/gdm\n\n[[ -s \"${dconf_profile_path}\" ]] || echo > \"${dconf_profile_path}\"\n\nif ! grep -Pzq \"(?s)^\\s*user-db:user.*\\n\\s*system-db:gdm\" \"${dconf_profile_path}\"; then\n    sed -i --follow-symlinks \"1s/^/user-db:user\\nsystem-db:gdm\\n/\" \"${dconf_profile_path}\"\nfi\n\n# Make sure the corresponding directories exist\nmkdir -p /etc/dconf/db/gdm.d\n\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/profile\n(umask 0022 && dconf update)\n\n# Will do both approach, since we plan to migrate to checks over dconf db. That way, future updates of the tool\n# will pass the check even if we decide to check only for the dconf db path.\nif [ -e \"/etc/gdm3/greeter.dconf-defaults\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*banner\\-message\\-text/Id\" \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    touch \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/gdm3/greeter.dconf-defaults\"\n\ncp \"/etc/gdm3/greeter.dconf-defaults\" \"/etc/gdm3/greeter.dconf-defaults.bak\"\n# Insert after the line matching the regex '\\[org/gnome/login-screen\\]'\nline_number=\"$(LC_ALL=C grep -n \"\\[org/gnome/login-screen\\]\" \"/etc/gdm3/greeter.dconf-defaults.bak\" | LC_ALL=C sed 's/:.*//g')\"\nif [ -z \"$line_number\" ]; then\n    # There was no match of '\\[org/gnome/login-screen\\]', insert at\n    # the end of the file.\n    printf '%s\\n' \"banner-message-text='${login_banner_text}'\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nelse\n    head -n \"$(( line_number ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" > \"/etc/gdm3/greeter.dconf-defaults\"\n    printf '%s\\n' \"banner-message-text='${login_banner_text}'\" >> \"/etc/gdm3/greeter.dconf-defaults\"\n    tail -n \"+$(( line_number + 1 ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" >> \"/etc/gdm3/greeter.dconf-defaults\"\nfi\n# Clean up after ourselves.\nrm \"/etc/gdm3/greeter.dconf-defaults.bak\"\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" \\\n                                | grep -v 'distro\\|ibus\\|gdm.d' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/gdm.d\"\n\nmkdir -p \"${DBDIR}\"\n\n# Comment out the configurations in databases different from the target one\nif [ \"${#SETTINGSFILES[@]}\" -ne 0 ]\nthen\n    if grep -q \"^\\\\s*banner-message-text\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -Ei \"s/(^\\s*)banner-message-text(\\s*=)/#\\1banner-message-text\\2/g\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\n[ ! -z \"${DCONFFILE}\" ] && echo \"\" >> \"${DCONFFILE}\"\nif ! grep -q \"\\\\[org/gnome/login-screen\\\\]\" \"${DCONFFILE}\"\nthen\n    printf '%s\\n' \"[org/gnome/login-screen]\" >> ${DCONFFILE}\nfi\n\nescaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"'${login_banner_text}'\")\"\nif grep -q \"^\\\\s*banner-message-text\\\\s*=\" \"${DCONFFILE}\"\nthen\n        sed -i \"s/\\\\s*banner-message-text\\\\s*=\\\\s*.*/banner-message-text=${escaped_value}/g\" \"${DCONFFILE}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\banner-message-text=${escaped_value}\" \"${DCONFFILE}\"\nfi\n# Make sure permissions allow regular users to read dconf settings.\n# Also define the umask to avoid `dconf update` changing permissions.\nchmod -R u=rwX,go=rX /etc/dconf/db\n(umask 0022 && dconf update)\n# No need to use dconf update, since bash_dconf_settings does that already\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238198",
        "stig_id": "UBTU-20-010003"
      },
      "xccdf_org.ssgproject.content_rule_package_pam_pwquality_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_pam_pwquality_installed",
        "title": "Install pam_pwquality Package",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.3.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00225"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010057"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238228r653859_rule"
            ]
          }
        ],
        "description": "\nThe <code>libpam-pwquality</code> package can be installed with the following command:\n<pre>\n$ apt-get install libpam-pwquality</pre>\n       ",
        "rationale": "Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure\nof the effectiveness of a password in resisting attempts at guessing and\nbrute-force attacks. &quot;pwquality&quot; enforces complex password construction\nconfiguration and has the ability to limit brute-force attacks on the system.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-package_pam_pwquality_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_pam_pwquality_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010057\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_pam_pwquality_installed\n\n- name: Ensure libpam-pwquality is installed\n  package:\n    name: libpam-pwquality\n    state: present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010057\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_pam_pwquality_installed\n"
          },
          {
            "remediation_id": "package_pam_pwquality_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_libpam-pwquality\n\nclass install_libpam-pwquality {\n  package { 'libpam-pwquality':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_pam_pwquality_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"libpam-pwquality\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_pam_pwquality_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"libpam-pwquality\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238228",
        "stig_id": "UBTU-20-010057"
      },
      "xccdf_org.ssgproject.content_rule_display_login_attempts": {
        "rule_id": "xccdf_org.ssgproject.content_rule_display_login_attempts",
        "title": "Ensure PAM Displays Last Logon/Access Notification",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "low",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.2"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000052"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0582",
              "0584",
              "0586",
              "05885",
              "0846",
              "0957"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-9",
              "AC-9(1)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.4"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010453"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238373r858539_rule"
            ]
          }
        ],
        "description": "To configure the system to notify users of last logon/access using <code>pam_lastlog</code>,\nadd or correct the <code>pam_lastlog</code> settings in <code>/etc/pam.d/login</code>\nto include <code>showfailed</code> option, such as:\n<pre>session     required    pam_lastlog.so showfailed</pre>\nAnd make sure that the <code>silent</code> option is not set for this specific line.",
        "rationale": "Users need to be aware of activity that occurs regarding their account. Providing users with\ninformation regarding the number of unsuccessful attempts that were made to login to their\naccount allows the user to determine if any unauthorized activity has occurred and gives them\nan opportunity to notify administrators.",
        "warnings": [
          {
            "text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.",
            "category": "general"
          },
          {
            "text": "<code>authselect</code> contains an authselect feature to easily and properly enable Last Logon\nnotifications with <code>pam_lastlog.so</code> module. If a custom profile was created and used\nin the system before this authselect feature was available, the new feature can&#x27;t be used\nwith this custom profile and the remediation will fail. In this case, the custom profile\nshould be recreated or manually updated.",
            "category": "general"
          }
        ],
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-display_login_attempts:def:1",
        "remediations": [
          {
            "remediation_id": "display_login_attempts",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nif [ -f /usr/bin/authselect ]; then\n    if authselect list-features sssd | grep -q with-silent-lastlog; then\n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n        authselect disable-feature with-silent-lastlog\n\n        authselect apply-changes -b\n    else\n        \n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n\n        CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n        # If not already in use, a custom profile is created preserving the enabled features.\n        if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n            ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n            authselect create-profile hardening -b $CURRENT_PROFILE\n            CURRENT_PROFILE=\"custom/hardening\"\n            \n            authselect apply-changes -b --backup=before-hardening-custom-profile\n            authselect select $CURRENT_PROFILE\n            for feature in $ENABLED_FEATURES; do\n                authselect enable-feature $feature;\n            done\n            \n            authselect apply-changes -b --backup=after-hardening-custom-profile\n        fi\n        PAM_FILE_NAME=$(basename \"/etc/pam.d/login\")\n        PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n        authselect apply-changes -b\n        if [ -e \"$PAM_FILE_PATH\" ] ; then\n            PAM_FILE_PATH=\"$PAM_FILE_PATH\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$PAM_FILE_PATH\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            if ! grep -qP \"^\\s*session\\s+required\\s+pam_lastlog.so\\s*.*\" \"$PAM_FILE_PATH\"; then\n                    # Line matching group + control + module was not found. Check group + module.\n                    if [ \"$(grep -cP '^\\s*session\\s+.*\\s+pam_lastlog.so\\s*' \"$PAM_FILE_PATH\")\" -eq 1 ]; then\n                        # The control is updated only if one single line matches.\n                        sed -i -E --follow-symlinks \"s/^(\\s*session\\s+).*(\\bpam_lastlog.so.*)/\\1required \\2/\" \"$PAM_FILE_PATH\"\n                    else\n                        LAST_MATCH_LINE=$(grep -nP \"^\\s*session.*include\\s+common-session$\" \"$PAM_FILE_PATH\" | tail -n 1 | cut -d: -f 1)\n                        if [ ! -z $LAST_MATCH_LINE ]; then\n                            sed -i --follow-symlinks $LAST_MATCH_LINE\" a session     required    pam_lastlog.so\" \"$PAM_FILE_PATH\"\n                        else\n                            echo \"session    required    pam_lastlog.so\" >> \"$PAM_FILE_PATH\"\n                        fi\n                    fi\n                fi\n                # Check the option\n                if ! grep -qP \"^\\s*session\\s+required\\s+pam_lastlog.so\\s*.*\\sshowfailed\\b\" \"$PAM_FILE_PATH\"; then\n                    sed -i -E --follow-symlinks \"/\\s*session\\s+required\\s+pam_lastlog.so.*/ s/$/ showfailed/\" \"$PAM_FILE_PATH\"\n                fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$PAM_FILE_PATH was not found\" >&2\n        fi\n        if [ -e \"$PAM_FILE_PATH\" ] ; then\n            PAM_FILE_PATH=\"$PAM_FILE_PATH\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$PAM_FILE_PATH\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            \n        if grep -qP \"^\\s*session\\s+required\\s+pam_lastlog.so\\s.*\\bsilent\\b\" \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks \"s/(.*session.*required.*pam_lastlog.so.*)\\ssilent=?[[:alnum:]]*(.*)/\\1\\2/g\" \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$PAM_FILE_PATH was not found\" >&2\n        fi\n    fi\nelse\n    if [ -e \"/etc/pam.d/login\" ] ; then\n            PAM_FILE_PATH=\"/etc/pam.d/login\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"/etc/pam.d/login\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            if ! grep -qP \"^\\s*session\\s+required\\s+pam_lastlog.so\\s*.*\" \"$PAM_FILE_PATH\"; then\n                    # Line matching group + control + module was not found. Check group + module.\n                    if [ \"$(grep -cP '^\\s*session\\s+.*\\s+pam_lastlog.so\\s*' \"$PAM_FILE_PATH\")\" -eq 1 ]; then\n                        # The control is updated only if one single line matches.\n                        sed -i -E --follow-symlinks \"s/^(\\s*session\\s+).*(\\bpam_lastlog.so.*)/\\1required \\2/\" \"$PAM_FILE_PATH\"\n                    else\n                        LAST_MATCH_LINE=$(grep -nP \"^\\s*session.*include\\s+common-session$\" \"$PAM_FILE_PATH\" | tail -n 1 | cut -d: -f 1)\n                        if [ ! -z $LAST_MATCH_LINE ]; then\n                            sed -i --follow-symlinks $LAST_MATCH_LINE\" a session     required    pam_lastlog.so\" \"$PAM_FILE_PATH\"\n                        else\n                            echo \"session    required    pam_lastlog.so\" >> \"$PAM_FILE_PATH\"\n                        fi\n                    fi\n                fi\n                # Check the option\n                if ! grep -qP \"^\\s*session\\s+required\\s+pam_lastlog.so\\s*.*\\sshowfailed\\b\" \"$PAM_FILE_PATH\"; then\n                    sed -i -E --follow-symlinks \"/\\s*session\\s+required\\s+pam_lastlog.so.*/ s/$/ showfailed/\" \"$PAM_FILE_PATH\"\n                fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"/etc/pam.d/login was not found\" >&2\n        fi\n    if [ -e \"/etc/pam.d/login\" ] ; then\n            PAM_FILE_PATH=\"/etc/pam.d/login\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"/etc/pam.d/login\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            \n        if grep -qP \"^\\s*session\\s+required\\s+pam_lastlog.so\\s.*\\bsilent\\b\" \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks \"s/(.*session.*required.*pam_lastlog.so.*)\\ssilent=?[[:alnum:]]*(.*)/\\1\\2/g\" \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"/etc/pam.d/login was not found\" >&2\n        fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238373",
        "stig_id": "UBTU-20-010453"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_remember": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_remember",
        "title": "Limit Password Reuse",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.6.2.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.5.8"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000200"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "IA-5(1)(e)",
              "IA-5(f)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000077-GPOS-00045"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010070"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238234r832945_rule"
            ]
          }
        ],
        "description": "Do not allow users to reuse recent passwords. This can be accomplished by using the\n<code>remember</code> option for the <code>pam_unix</code> or <code>pam_pwhistory</code> PAM modules.",
        "rationale": "Preventing re-use of previous passwords helps ensure that a compromised password is not\nre-used by a user.",
        "warnings": [
          {
            "text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.",
            "category": "general"
          },
          {
            "text": "Newer versions of <code>authselect</code> contain an authselect feature to easily and properly\nenable <code>pam_pwhistory.so</code> module. If this feature is not yet available in your\nsystem, an authselect custom profile must be used to avoid integrity issues in PAM files.",
            "category": "general"
          }
        ],
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_unix_remember:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_unix_remember",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "configure",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010070\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - PCI-DSSv4-8.3.7\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n- name: XCCDF Value var_password_pam_unix_remember # promote to variable\n  set_fact:\n    var_password_pam_unix_remember: !!str 5\n  tags:\n    - always\n\n- name: Limit Password Reuse - Check if the required PAM module option is present\n    in /etc/pam.d/common-password\n  ansible.builtin.lineinfile:\n    path: /etc/pam.d/common-password\n    regexp: ^\\s*password\\s+\\[success=[A-Za-z0-9].*\\]\\s+pam_unix.so\\s*.*\\sremember\\b\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: result_pam_module_remember_option_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010070\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - PCI-DSSv4-8.3.7\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Limit Password Reuse - Ensure the \"remember\" PAM option for \"pam_unix.so\"\n    is included in /etc/pam.d/common-password\n  ansible.builtin.lineinfile:\n    path: /etc/pam.d/common-password\n    backrefs: true\n    regexp: ^(\\s*password\\s+\\[success=[A-Za-z0-9].*\\]\\s+pam_unix.so.*)\n    line: \\1 remember={{ var_password_pam_unix_remember }}\n    state: present\n  register: result_pam_remember_add\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_pam_module_remember_option_present.found == 0\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010070\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - PCI-DSSv4-8.3.7\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Limit Password Reuse - Ensure the required value for \"remember\" PAM option\n    from \"pam_unix.so\" in /etc/pam.d/common-password\n  ansible.builtin.lineinfile:\n    path: /etc/pam.d/common-password\n    backrefs: true\n    regexp: ^(\\s*password\\s+\\[success=[A-Za-z0-9].*\\]\\s+pam_unix.so\\s+.*)(remember)=[0-9a-zA-Z]+\\s*(.*)\n    line: \\1\\2={{ var_password_pam_unix_remember }} \\3\n  register: result_pam_remember_edit\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_pam_module_remember_option_present.found > 0\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010070\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - PCI-DSSv4-8.3.7\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "accounts_password_pam_unix_remember",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_unix_remember='5'\n\n\n\n\n\n\nif [ -e \"/etc/pam.d/common-password\" ] ; then\n    valueRegex=\"$var_password_pam_unix_remember\" defaultValue=\"$var_password_pam_unix_remember\"\n    # non-empty values need to be preceded by an equals sign\n    [ -n \"${valueRegex}\" ] && valueRegex=\"=${valueRegex}\"\n    # add an equals sign to non-empty values\n    [ -n \"${defaultValue}\" ] && defaultValue=\"=${defaultValue}\"\n\n    # fix 'type' if it's wrong\n    if grep -q -P \"^\\\\s*(?\"'!'\"password\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_unix.so\" < \"/etc/pam.d/common-password\" ; then\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_unix.so)/\\\\1password\\\\2/\" \"/etc/pam.d/common-password\"\n    fi\n\n    # fix 'control' if it's wrong\n    if grep -q -P \"^\\\\s*password\\\\s+(?\"'!'\"\\[success=[[:alnum:]].*\\])[[:alnum:]]+\\\\s+pam_unix.so\" < \"/etc/pam.d/common-password\" ; then\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+)[[:alnum:]]+(\\\\s+pam_unix.so)/\\\\1\\[success=[[:alnum:]].*\\]\\\\2/\" \"/etc/pam.d/common-password\"\n    fi\n\n    # fix the value for 'option' if one exists but does not match 'valueRegex'\n    if grep -q -P \"^\\\\s*password\\\\s+\\[success=[[:alnum:]].*\\]\\\\s+pam_unix.so(\\\\s.+)?\\\\s+remember(?\"'!'\"${valueRegex}(\\\\s|\\$))\" < \"/etc/pam.d/common-password\" ; then\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+\\[success=[[:alnum:]].*\\]\\\\s+pam_unix.so(\\\\s.+)?\\\\s)remember=[^[:space:]]*/\\\\1remember${defaultValue}/\" \"/etc/pam.d/common-password\"\n\n    # add 'option=default' if option is not set\n    elif grep -q -E \"^\\\\s*password\\\\s+\\[success=[[:alnum:]].*\\]\\\\s+pam_unix.so\" < \"/etc/pam.d/common-password\" &&\n            grep    -E \"^\\\\s*password\\\\s+\\[success=[[:alnum:]].*\\]\\\\s+pam_unix.so\" < \"/etc/pam.d/common-password\" | grep -q -E -v \"\\\\sremember(=|\\\\s|\\$)\" ; then\n\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+\\[success=[[:alnum:]].*\\]\\\\s+pam_unix.so[^\\\\n]*)/\\\\1 remember${defaultValue}/\" \"/etc/pam.d/common-password\"\n    # add a new entry if none exists\n    elif ! grep -q -P \"^\\\\s*password\\\\s+\\[success=[[:alnum:]].*\\]\\\\s+pam_unix.so(\\\\s.+)?\\\\s+remember${valueRegex}(\\\\s|\\$)\" < \"/etc/pam.d/common-password\" ; then\n        echo \"password \\[success=[[:alnum:]].*\\] pam_unix.so remember${defaultValue}\" >> \"/etc/pam.d/common-password\"\n    fi\nelse\n    echo \"/etc/pam.d/common-password doesn't exist\" >&2\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238234",
        "stig_id": "UBTU-20-010070"
      },
      "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faildelay_delay": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faildelay_delay",
        "title": "Enforce Delay After Failed Logon Attempts",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00226"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010075"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238237r653886_rule"
            ]
          }
        ],
        "description": "To configure the system to introduce a delay after failed logon attempts,\nadd or correct the <code>pam_faildelay</code> settings in\n<code>/etc/pam.d/common-auth</code> to make sure its <code>delay</code> parameter\nis at least 4000000 or greater. For example:\n<pre>auth required pam_faildelay.so delay=4000000\n         </pre>\n        ",
        "rationale": "Limiting the number of logon attempts over a certain time interval reduces\nthe chances that an unauthorized user may gain access to an account.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_passwords_pam_faildelay_delay:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_passwords_pam_faildelay_delay",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_delay='4000000'\n\n\nif ! grep -qP \"^\\s*auth\\s+required\\s+pam_faildelay.so\\s*.*\" \"/etc/pam.d/common-auth\"; then\n    # Line matching group + control + module was not found. Check group + module.\n    if [ \"$(grep -cP '^\\s*auth\\s+.*\\s+pam_faildelay.so\\s*' \"/etc/pam.d/common-auth\")\" -eq 1 ]; then\n        # The control is updated only if one single line matches.\n        sed -i -E --follow-symlinks \"s/^(\\s*auth\\s+).*(\\bpam_faildelay.so.*)/\\1required \\2/\" \"/etc/pam.d/common-auth\"\n    else\n        sed -i --follow-symlinks \"1i auth     required    pam_faildelay.so\" \"/etc/pam.d/common-auth\"\n    fi\nfi\n# Check the option\nif ! grep -qP \"^\\s*auth\\s+required\\s+pam_faildelay.so\\s*.*\\sdelay\\b\" \"/etc/pam.d/common-auth\"; then\n    sed -i -E --follow-symlinks \"/\\s*auth\\s+required\\s+pam_faildelay.so.*/ s/$/ delay=$var_password_pam_delay/\" \"/etc/pam.d/common-auth\"\nelse\n    sed -i -E --follow-symlinks \"s/(\\s*auth\\s+required\\s+pam_faildelay.so\\s+.*)(delay=)[[:alnum:]]+\\s*(.*)/\\1\\2$var_password_pam_delay \\3/\" \"/etc/pam.d/common-auth\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238237",
        "stig_id": "UBTU-20-010075"
      },
      "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_audit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_audit",
        "title": "Account Lockouts Must Be Logged",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000044"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-7 (a)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000021-GPOS-00005"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010072"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238235r853414_rule"
            ]
          }
        ],
        "description": "PAM faillock locks an account due to excessive password failures, this event must be logged.",
        "rationale": "Without auditing of these events it may be harder or impossible to identify what an attacker did after an attack.",
        "oval_definition_id": "oval:ssg-accounts_passwords_pam_faillock_audit:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_passwords_pam_faillock_audit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Account Lockouts Must Be Logged - Check if system relies on authselect tool\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Remediation where authselect tool is present\n  block:\n\n  - name: Account Lockouts Must Be Logged - Check integrity of authselect current\n      profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    failed_when: false\n\n  - name: Account Lockouts Must Be Logged - Informative message based on the authselect\n      integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd.rc == 0\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Account Lockouts Must Be Logged - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Account Lockouts Must Be Logged - Ensure \"with-faillock\" feature is enabled\n      using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-faillock\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-faillock\")\n\n  - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when: result_authselect_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Remediation where authselect tool is not\n    present\n  block:\n\n  - name: Account Lockouts Must Be Logged - Check if pam_faillock.so is already enabled\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail)\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_is_enabled\n\n  - name: Account Lockouts Must Be Logged - Enable pam_faillock.so preauth editing\n      PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so preauth\n      insertbefore: ^auth.*sufficient.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Account Lockouts Must Be Logged - Enable pam_faillock.so authfail editing\n      PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so authfail\n      insertbefore: ^auth.*required.*pam_deny\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Account Lockouts Must Be Logged - Enable pam_faillock.so account section\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: account     required      pam_faillock.so\n      insertbefore: ^account.*required.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n  when: not result_authselect_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Check the presence of /etc/security/faillock.conf\n    file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Ensure the pam_faillock.so audit parameter\n    in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*audit\n    line: audit\n    state: present\n  when: result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Ensure the pam_faillock.so audit parameter\n    not in PAM files\n  block:\n\n  - name: Account Lockouts Must Be Logged - Check if /etc/pam.d/system-auth file is\n      present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Account Lockouts Must Be Logged - Check the proper remediation for the system\n    block:\n\n    - name: Account Lockouts Must Be Logged - Define the PAM file to be edited as\n        a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Account Lockouts Must Be Logged - Check if system relies on authselect\n        tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect custom profile is\n        used if authselect is present\n      block:\n\n      - name: Account Lockouts Must Be Logged - Check integrity of authselect current\n          profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Account Lockouts Must Be Logged - Informative message based on the authselect\n          integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Account Lockouts Must Be Logged - Get authselect current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Account Lockouts Must Be Logged - Define the current authselect profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Define the new authselect custom profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Get authselect current features to\n          also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Check if any custom profile with the\n          same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Create an authselect custom profile\n          based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Ensure the authselect custom profile\n          is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Restore the authselect features in\n          the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Account Lockouts Must Be Logged - Change the PAM file to be edited according\n          to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Account Lockouts Must Be Logged - Define a fact for control already filtered\n        in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Account Lockouts Must Be Logged - Ensure the \"audit\" option from \"pam_faillock.so\"\n        is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\baudit\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Account Lockouts Must Be Logged - Check if /etc/pam.d/password-auth file\n      is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Account Lockouts Must Be Logged - Check the proper remediation for the system\n    block:\n\n    - name: Account Lockouts Must Be Logged - Define the PAM file to be edited as\n        a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Account Lockouts Must Be Logged - Check if system relies on authselect\n        tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect custom profile is\n        used if authselect is present\n      block:\n\n      - name: Account Lockouts Must Be Logged - Check integrity of authselect current\n          profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Account Lockouts Must Be Logged - Informative message based on the authselect\n          integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Account Lockouts Must Be Logged - Get authselect current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Account Lockouts Must Be Logged - Define the current authselect profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Define the new authselect custom profile\n          as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Get authselect current features to\n          also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Check if any custom profile with the\n          same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Account Lockouts Must Be Logged - Create an authselect custom profile\n          based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Ensure the authselect custom profile\n          is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Account Lockouts Must Be Logged - Restore the authselect features in\n          the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Account Lockouts Must Be Logged - Change the PAM file to be edited according\n          to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Account Lockouts Must Be Logged - Define a fact for control already filtered\n        in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Account Lockouts Must Be Logged - Ensure the \"audit\" option from \"pam_faillock.so\"\n        is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\baudit\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Account Lockouts Must Be Logged - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when: result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Account Lockouts Must Be Logged - Ensure the pam_faillock.so audit parameter\n    in PAM files\n  block:\n\n  - name: Account Lockouts Must Be Logged - Check if pam_faillock.so audit parameter\n      is already enabled in pam files\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail).*audit\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_audit_parameter_is_present\n\n  - name: Account Lockouts Must Be Logged - Ensure the inclusion of pam_faillock.so\n      preauth audit parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)\n      line: \\1required\\3 audit\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_audit_parameter_is_present.found == 0\n  when: not result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7 (a)\n  - accounts_passwords_pam_faillock_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_passwords_pam_faillock_audit",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \npam_file=\"/etc/pam.d/common-auth\"\nif ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+preauth.*$' \"$pam_file\" ; then\n    # insert at the top\n    sed -i --follow-symlinks '/^# here are the per-package modules/i auth        required      pam_faillock.so preauth' \"$pam_file\"\nfi\nif ! grep -qE '^\\s*auth\\s+\\[default=die\\]\\s+pam_faillock\\.so\\s+authfail.*$' \"$pam_file\" ; then\n\n    num_lines=$(sed -n 's/^\\s*auth.*success=\\([1-9]\\).*pam_unix\\.so.*/\\1/p' \"$pam_file\")\n    if [ ! -z \"$num_lines\" ]; then\n\n        # Add pam_faillock (authfail) module below pam_unix, skipping N-1 lines, where N is\n        # the number of jumps in the pam_unix success=N statement. Ignore commented and empty lines.\n\n        append_position=$(cat -n \"${pam_file}\" \\\n                          | grep -P \"^\\s+\\d+\\s+auth\\s+.*$\" \\\n                          | grep -w \"pam_unix.so\" -A $(( num_lines - 1 )) \\\n                          | tail -n 1 | cut -f 1 | tr -d ' '\n                         )\n        sed -i --follow-symlinks ''${append_position}'a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    else\n        sed -i --follow-symlinks '/^auth.*pam_unix\\.so.*/a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    fi\nfi\nif ! grep -qE '^\\s*auth\\s+sufficient\\s+pam_faillock\\.so\\s+authsucc.*$' \"$pam_file\" ; then\n    sed -i --follow-symlinks '/^auth.*pam_faillock\\.so.*authfail.*/a auth        sufficient      pam_faillock.so authsucc' \"$pam_file\"\nfi\n\npam_file=\"/etc/pam.d/common-account\"\nif ! grep -qE '^\\s*account\\s+required\\s+pam_faillock\\.so.*$' \"$pam_file\" ; then\n    echo 'account   required     pam_faillock.so' >> \"$pam_file\"\nfi\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ]; then\n    regex=\"^\\s*audit\"\n    line=\"audit\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    fi\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if [ -e \"$pam_file\" ] ; then\n            PAM_FILE_PATH=\"$pam_file\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$pam_file\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            \n        if grep -qP \"^\\s*auth\\s.*\\bpam_faillock.so\\s.*\\baudit\\b\" \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks \"s/(.*auth.*pam_faillock.so.*)\\baudit\\b=?[[:alnum:]]*(.*)/\\1\\2/g\" \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$pam_file was not found\" >&2\n        fi\n    done\nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so (preauth|authfail).*audit' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*silent.*/ s/$/ audit/' \"$pam_file\"\n        fi\n    done\nfi\n"
          }
        ],
        "vuln_id": "SV-238235",
        "stig_id": "UBTU-20-010072"
      },
      "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny",
        "title": "Lock Accounts After Failed Password Attempts",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.3"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.8"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000044",
              "CCI-002236",
              "CCI-002237",
              "CCI-002238"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-7(a)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000021-GPOS-00005",
              "SRG-OS-000329-GPOS-00128"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FIA_AFL.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.1.6"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010072"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238235r853414_rule"
            ]
          }
        ],
        "description": "This rule configures the system to lock out accounts after a number of incorrect login attempts\nusing <code>pam_faillock.so</code>.\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected.\nEnsure that the file <code>/etc/security/faillock.conf</code> contains the following entry:\n<code>deny = &lt;count&gt;</code>\nWhere count should be less than or equal to\n3 and greater than 0.",
        "rationale": "By limiting the number of failed logon attempts, the risk of unauthorized system access via\nuser password guessing, also known as brute-forcing, is reduced. Limits are imposed by locking\nthe account.",
        "warnings": [
          {
            "text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.",
            "category": "general"
          }
        ],
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_passwords_pam_faillock_deny:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_passwords_pam_faillock_deny",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Check if system relies on authselect\n    tool\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Remediation where authselect\n    tool is present\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect\n      current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    failed_when: false\n\n  - name: Lock Accounts After Failed Password Attempts - Informative message based\n      on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd.rc == 0\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Lock Accounts After Failed Password Attempts - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure \"with-faillock\" feature\n      is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-faillock\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-faillock\")\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Remediation where authselect\n    tool is not present\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check if pam_faillock.so\n      is already enabled\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail)\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_is_enabled\n\n  - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so preauth\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so preauth\n      insertbefore: ^auth.*sufficient.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so authfail\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so authfail\n      insertbefore: ^auth.*required.*pam_deny\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so account\n      section editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: account     required      pam_faillock.so\n      insertbefore: ^account.*required.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_passwords_pam_faillock_deny # promote to variable\n  set_fact:\n    var_accounts_passwords_pam_faillock_deny: !!str 3\n  tags:\n    - always\n\n- name: Lock Accounts After Failed Password Attempts - Check the presence of /etc/security/faillock.conf\n    file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so\n    deny parameter in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*deny\\s*=\n    line: deny = {{ var_accounts_passwords_pam_faillock_deny }}\n    state: present\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so\n    deny parameter not in PAM files\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check if /etc/pam.d/system-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Lock Accounts After Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Lock Accounts After Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Lock Accounts After Failed Password Attempts - Check if system relies\n        on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure authselect custom\n        profile is used if authselect is present\n      block:\n\n      - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Lock Accounts After Failed Password Attempts - Informative message based\n          on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Lock Accounts After Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Check if any custom profile\n          with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Change the PAM file to\n          be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Lock Accounts After Failed Password Attempts - Define a fact for control\n        already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure the \"deny\" option\n        from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bdeny\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Lock Accounts After Failed Password Attempts - Check if /etc/pam.d/password-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Lock Accounts After Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Lock Accounts After Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Lock Accounts After Failed Password Attempts - Check if system relies\n        on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure authselect custom\n        profile is used if authselect is present\n      block:\n\n      - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Lock Accounts After Failed Password Attempts - Informative message based\n          on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Lock Accounts After Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Check if any custom profile\n          with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Change the PAM file to\n          be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Lock Accounts After Failed Password Attempts - Define a fact for control\n        already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure the \"deny\" option\n        from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bdeny\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so\n    deny parameter in PAM files\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check if pam_faillock.so\n      deny parameter is already enabled in pam files\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail).*deny\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_deny_parameter_is_present\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the inclusion of pam_faillock.so\n      preauth deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)\n      line: \\1required\\3 deny={{ var_accounts_passwords_pam_faillock_deny }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the inclusion of pam_faillock.so\n      authfail deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)\n      line: \\1required\\3 deny={{ var_accounts_passwords_pam_faillock_deny }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so preauth deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)(deny)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_deny }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found > 0\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so authfail deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)(deny)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_deny }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found > 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_passwords_pam_faillock_deny",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_accounts_passwords_pam_faillock_deny='3'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \npam_file=\"/etc/pam.d/common-auth\"\nif ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+preauth.*$' \"$pam_file\" ; then\n    # insert at the top\n    sed -i --follow-symlinks '/^# here are the per-package modules/i auth        required      pam_faillock.so preauth' \"$pam_file\"\nfi\nif ! grep -qE '^\\s*auth\\s+\\[default=die\\]\\s+pam_faillock\\.so\\s+authfail.*$' \"$pam_file\" ; then\n\n    num_lines=$(sed -n 's/^\\s*auth.*success=\\([1-9]\\).*pam_unix\\.so.*/\\1/p' \"$pam_file\")\n    if [ ! -z \"$num_lines\" ]; then\n\n        # Add pam_faillock (authfail) module below pam_unix, skipping N-1 lines, where N is\n        # the number of jumps in the pam_unix success=N statement. Ignore commented and empty lines.\n\n        append_position=$(cat -n \"${pam_file}\" \\\n                          | grep -P \"^\\s+\\d+\\s+auth\\s+.*$\" \\\n                          | grep -w \"pam_unix.so\" -A $(( num_lines - 1 )) \\\n                          | tail -n 1 | cut -f 1 | tr -d ' '\n                         )\n        sed -i --follow-symlinks ''${append_position}'a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    else\n        sed -i --follow-symlinks '/^auth.*pam_unix\\.so.*/a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    fi\nfi\nif ! grep -qE '^\\s*auth\\s+sufficient\\s+pam_faillock\\.so\\s+authsucc.*$' \"$pam_file\" ; then\n    sed -i --follow-symlinks '/^auth.*pam_faillock\\.so.*authfail.*/a auth        sufficient      pam_faillock.so authsucc' \"$pam_file\"\nfi\n\npam_file=\"/etc/pam.d/common-account\"\nif ! grep -qE '^\\s*account\\s+required\\s+pam_faillock\\.so.*$' \"$pam_file\" ; then\n    echo 'account   required     pam_faillock.so' >> \"$pam_file\"\nfi\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ]; then\n    regex=\"^\\s*deny\\s*=\"\n    line=\"deny = $var_accounts_passwords_pam_faillock_deny\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(deny\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_deny\"'|g' $FAILLOCK_CONF\n    fi\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if [ -e \"$pam_file\" ] ; then\n            PAM_FILE_PATH=\"$pam_file\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$pam_file\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            \n        if grep -qP \"^\\s*auth\\s.*\\bpam_faillock.so\\s.*\\bdeny\\b\" \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks \"s/(.*auth.*pam_faillock.so.*)\\bdeny\\b=?[[:alnum:]]*(.*)/\\1\\2/g\" \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$pam_file was not found\" >&2\n        fi\n    done\nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so (preauth|authfail).*deny' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*silent.*/ s/$/ deny='\"$var_accounts_passwords_pam_faillock_deny\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*authfail.*/ s/$/ deny='\"$var_accounts_passwords_pam_faillock_deny\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*preauth.*silent.*\\)\\('\"deny\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_deny\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*authfail.*\\)\\('\"deny\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_deny\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238235",
        "stig_id": "UBTU-20-010072"
      },
      "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_interval": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_interval",
        "title": "Set Interval For Counting Failed Password Attempts",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000044",
              "CCI-002236",
              "CCI-002237",
              "CCI-002238"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-7(a)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000021-GPOS-00005",
              "SRG-OS-000329-GPOS-00128"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FIA_AFL.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010072"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238235r853414_rule"
            ]
          }
        ],
        "description": "Utilizing <code>pam_faillock.so</code>, the <code>fail_interval</code> directive configures the system\nto lock out an account after a number of incorrect login attempts within a specified time\nperiod.\n\nEnsure that the file <code>/etc/security/faillock.conf</code> contains the following entry:\n<code>fail_interval = &lt;interval-in-seconds&gt;</code> where <code>interval-in-seconds</code> is <code>900</code> or greater.",
        "rationale": "By limiting the number of failed logon attempts the risk of unauthorized system\naccess via user password guessing, otherwise known as brute-forcing, is reduced.\nLimits are imposed by locking the account.",
        "warnings": [
          {
            "text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.",
            "category": "general"
          }
        ],
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_passwords_pam_faillock_interval:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_passwords_pam_faillock_interval",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interval For Counting Failed Password Attempts - Check if system relies\n    on authselect tool\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interval For Counting Failed Password Attempts - Remediation where authselect\n    tool is present\n  block:\n\n  - name: Set Interval For Counting Failed Password Attempts - Check integrity of\n      authselect current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    failed_when: false\n\n  - name: Set Interval For Counting Failed Password Attempts - Informative message\n      based on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd.rc == 0\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Set Interval For Counting Failed Password Attempts - Get authselect current\n      features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Set Interval For Counting Failed Password Attempts - Ensure \"with-faillock\"\n      feature is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-faillock\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-faillock\")\n\n  - name: Set Interval For Counting Failed Password Attempts - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_authselect_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interval For Counting Failed Password Attempts - Remediation where authselect\n    tool is not present\n  block:\n\n  - name: Set Interval For Counting Failed Password Attempts - Check if pam_faillock.so\n      is already enabled\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail)\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_is_enabled\n\n  - name: Set Interval For Counting Failed Password Attempts - Enable pam_faillock.so\n      preauth editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so preauth\n      insertbefore: ^auth.*sufficient.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Set Interval For Counting Failed Password Attempts - Enable pam_faillock.so\n      authfail editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so authfail\n      insertbefore: ^auth.*required.*pam_deny\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Set Interval For Counting Failed Password Attempts - Enable pam_faillock.so\n      account section editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: account     required      pam_faillock.so\n      insertbefore: ^account.*required.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_authselect_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_passwords_pam_faillock_fail_interval # promote to variable\n  set_fact:\n    var_accounts_passwords_pam_faillock_fail_interval: !!str 900\n  tags:\n    - always\n\n- name: Set Interval For Counting Failed Password Attempts - Check the presence of\n    /etc/security/faillock.conf file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interval For Counting Failed Password Attempts - Ensure the pam_faillock.so\n    fail_interval parameter in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*fail_interval\\s*=\n    line: fail_interval = {{ var_accounts_passwords_pam_faillock_fail_interval }}\n    state: present\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interval For Counting Failed Password Attempts - Ensure the pam_faillock.so\n    fail_interval parameter not in PAM files\n  block:\n\n  - name: Set Interval For Counting Failed Password Attempts - Check if /etc/pam.d/system-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Set Interval For Counting Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Set Interval For Counting Failed Password Attempts - Define the PAM file\n        to be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Set Interval For Counting Failed Password Attempts - Check if system relies\n        on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n        custom profile is used if authselect is present\n      block:\n\n      - name: Set Interval For Counting Failed Password Attempts - Check integrity\n          of authselect current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Set Interval For Counting Failed Password Attempts - Informative message\n          based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Set Interval For Counting Failed Password Attempts - Get authselect\n          current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Set Interval For Counting Failed Password Attempts - Define the current\n          authselect profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Define the new\n          authselect custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Get authselect\n          current features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Check if any custom\n          profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n          changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Interval For Counting Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Interval For Counting Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n          changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Set Interval For Counting Failed Password Attempts - Change the PAM\n          file to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Set Interval For Counting Failed Password Attempts - Define a fact for\n        control already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Set Interval For Counting Failed Password Attempts - Ensure the \"fail_interval\"\n        option from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bfail_interval\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Set Interval For Counting Failed Password Attempts - Check if /etc/pam.d/password-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Set Interval For Counting Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Set Interval For Counting Failed Password Attempts - Define the PAM file\n        to be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Set Interval For Counting Failed Password Attempts - Check if system relies\n        on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n        custom profile is used if authselect is present\n      block:\n\n      - name: Set Interval For Counting Failed Password Attempts - Check integrity\n          of authselect current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Set Interval For Counting Failed Password Attempts - Informative message\n          based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Set Interval For Counting Failed Password Attempts - Get authselect\n          current profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Set Interval For Counting Failed Password Attempts - Define the current\n          authselect profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Define the new\n          authselect custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Get authselect\n          current features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Check if any custom\n          profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Interval For Counting Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n          changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Interval For Counting Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Interval For Counting Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n          changes are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Set Interval For Counting Failed Password Attempts - Change the PAM\n          file to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Set Interval For Counting Failed Password Attempts - Define a fact for\n        control already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Set Interval For Counting Failed Password Attempts - Ensure the \"fail_interval\"\n        option from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bfail_interval\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Set Interval For Counting Failed Password Attempts - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interval For Counting Failed Password Attempts - Ensure the pam_faillock.so\n    fail_interval parameter in PAM files\n  block:\n\n  - name: Set Interval For Counting Failed Password Attempts - Check if pam_faillock.so\n      fail_interval parameter is already enabled in pam files\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail).*fail_interval\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_fail_interval_parameter_is_present\n\n  - name: Set Interval For Counting Failed Password Attempts - Ensure the inclusion\n      of pam_faillock.so preauth fail_interval parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)\n      line: \\1required\\3 fail_interval={{ var_accounts_passwords_pam_faillock_fail_interval\n        }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_fail_interval_parameter_is_present.found == 0\n\n  - name: Set Interval For Counting Failed Password Attempts - Ensure the inclusion\n      of pam_faillock.so authfail fail_interval parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)\n      line: \\1required\\3 fail_interval={{ var_accounts_passwords_pam_faillock_fail_interval\n        }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_fail_interval_parameter_is_present.found == 0\n\n  - name: Set Interval For Counting Failed Password Attempts - Ensure the desired\n      value for pam_faillock.so preauth fail_interval parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)(fail_interval)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_fail_interval }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_fail_interval_parameter_is_present.found > 0\n\n  - name: Set Interval For Counting Failed Password Attempts - Ensure the desired\n      value for pam_faillock.so authfail fail_interval parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)(fail_interval)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_fail_interval }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_fail_interval_parameter_is_present.found > 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - accounts_passwords_pam_faillock_interval\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_passwords_pam_faillock_interval",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_accounts_passwords_pam_faillock_fail_interval='900'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \npam_file=\"/etc/pam.d/common-auth\"\nif ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+preauth.*$' \"$pam_file\" ; then\n    # insert at the top\n    sed -i --follow-symlinks '/^# here are the per-package modules/i auth        required      pam_faillock.so preauth' \"$pam_file\"\nfi\nif ! grep -qE '^\\s*auth\\s+\\[default=die\\]\\s+pam_faillock\\.so\\s+authfail.*$' \"$pam_file\" ; then\n\n    num_lines=$(sed -n 's/^\\s*auth.*success=\\([1-9]\\).*pam_unix\\.so.*/\\1/p' \"$pam_file\")\n    if [ ! -z \"$num_lines\" ]; then\n\n        # Add pam_faillock (authfail) module below pam_unix, skipping N-1 lines, where N is\n        # the number of jumps in the pam_unix success=N statement. Ignore commented and empty lines.\n\n        append_position=$(cat -n \"${pam_file}\" \\\n                          | grep -P \"^\\s+\\d+\\s+auth\\s+.*$\" \\\n                          | grep -w \"pam_unix.so\" -A $(( num_lines - 1 )) \\\n                          | tail -n 1 | cut -f 1 | tr -d ' '\n                         )\n        sed -i --follow-symlinks ''${append_position}'a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    else\n        sed -i --follow-symlinks '/^auth.*pam_unix\\.so.*/a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    fi\nfi\nif ! grep -qE '^\\s*auth\\s+sufficient\\s+pam_faillock\\.so\\s+authsucc.*$' \"$pam_file\" ; then\n    sed -i --follow-symlinks '/^auth.*pam_faillock\\.so.*authfail.*/a auth        sufficient      pam_faillock.so authsucc' \"$pam_file\"\nfi\n\npam_file=\"/etc/pam.d/common-account\"\nif ! grep -qE '^\\s*account\\s+required\\s+pam_faillock\\.so.*$' \"$pam_file\" ; then\n    echo 'account   required     pam_faillock.so' >> \"$pam_file\"\nfi\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ]; then\n    regex=\"^\\s*fail_interval\\s*=\"\n    line=\"fail_interval = $var_accounts_passwords_pam_faillock_fail_interval\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(fail_interval\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_fail_interval\"'|g' $FAILLOCK_CONF\n    fi\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if [ -e \"$pam_file\" ] ; then\n            PAM_FILE_PATH=\"$pam_file\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$pam_file\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            \n        if grep -qP \"^\\s*auth\\s.*\\bpam_faillock.so\\s.*\\bfail_interval\\b\" \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks \"s/(.*auth.*pam_faillock.so.*)\\bfail_interval\\b=?[[:alnum:]]*(.*)/\\1\\2/g\" \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$pam_file was not found\" >&2\n        fi\n    done\nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so (preauth|authfail).*fail_interval' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*silent.*/ s/$/ fail_interval='\"$var_accounts_passwords_pam_faillock_fail_interval\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*authfail.*/ s/$/ fail_interval='\"$var_accounts_passwords_pam_faillock_fail_interval\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*preauth.*silent.*\\)\\('\"fail_interval\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_fail_interval\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*authfail.*\\)\\('\"fail_interval\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_fail_interval\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238235",
        "stig_id": "UBTU-20-010072"
      },
      "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_silent": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_silent",
        "title": "Do Not Show System Messages When Unsuccessful Logon Attempts Occur",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000044",
              "CCI-002238"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000021-GPOS-00005",
              "SRG-OS-000329-GPOS-00128"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010072"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238235r853414_rule"
            ]
          }
        ],
        "description": "This rule ensures the system prevents informative messages from being presented to the user\npertaining to logon information after a number of incorrect login attempts using\n<code>pam_faillock.so</code>.\n\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected. In order to avoid errors when manually editing these files, it is\nrecommended to use the appropriate tools, such as <code>authselect</code> or <code>authconfig</code>,\ndepending on the OS version.",
        "rationale": "The pam_faillock module without the silent option will leak information about the existence or\nnon-existence of a user account in the system because the failures are not recorded for unknown\nusers. The message about the user account being locked is never displayed for non-existing user\naccounts allowing the adversary to infer that a particular account exists or not on the system.",
        "warnings": [
          {
            "text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.",
            "category": "general"
          }
        ],
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_passwords_pam_faillock_silent:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_passwords_pam_faillock_silent",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n    if system relies on authselect tool\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Remediation\n    where authselect tool is present\n  block:\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      integrity of authselect current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    failed_when: false\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Informative\n      message based on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd.rc == 0\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Get\n      authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n      \"with-faillock\" feature is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-faillock\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-faillock\")\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n      authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_authselect_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Remediation\n    where authselect tool is not present\n  block:\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n      if pam_faillock.so is already enabled\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail)\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_is_enabled\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Enable\n      pam_faillock.so preauth editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so preauth\n      insertbefore: ^auth.*sufficient.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Enable\n      pam_faillock.so authfail editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so authfail\n      insertbefore: ^auth.*required.*pam_deny\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Enable\n      pam_faillock.so account section editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: account     required      pam_faillock.so\n      insertbefore: ^account.*required.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_authselect_present.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Check\n    the presence of /etc/security/faillock.conf file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n    the pam_faillock.so silent parameter in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*silent\n    line: silent\n    state: present\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n    the pam_faillock.so silent parameter in PAM files\n  block:\n\n  - name: Do Not Show System Messages When Unsuccessful Logon Attempts Occur - Ensure\n      the inclusion of pam_faillock.so preauth silent parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth(:?(?!silent).)*)\n      line: \\1required\\3 silent\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010072\n  - accounts_passwords_pam_faillock_silent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_passwords_pam_faillock_silent",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \npam_file=\"/etc/pam.d/common-auth\"\nif ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+preauth.*$' \"$pam_file\" ; then\n    # insert at the top\n    sed -i --follow-symlinks '/^# here are the per-package modules/i auth        required      pam_faillock.so preauth' \"$pam_file\"\nfi\nif ! grep -qE '^\\s*auth\\s+\\[default=die\\]\\s+pam_faillock\\.so\\s+authfail.*$' \"$pam_file\" ; then\n\n    num_lines=$(sed -n 's/^\\s*auth.*success=\\([1-9]\\).*pam_unix\\.so.*/\\1/p' \"$pam_file\")\n    if [ ! -z \"$num_lines\" ]; then\n\n        # Add pam_faillock (authfail) module below pam_unix, skipping N-1 lines, where N is\n        # the number of jumps in the pam_unix success=N statement. Ignore commented and empty lines.\n\n        append_position=$(cat -n \"${pam_file}\" \\\n                          | grep -P \"^\\s+\\d+\\s+auth\\s+.*$\" \\\n                          | grep -w \"pam_unix.so\" -A $(( num_lines - 1 )) \\\n                          | tail -n 1 | cut -f 1 | tr -d ' '\n                         )\n        sed -i --follow-symlinks ''${append_position}'a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    else\n        sed -i --follow-symlinks '/^auth.*pam_unix\\.so.*/a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    fi\nfi\nif ! grep -qE '^\\s*auth\\s+sufficient\\s+pam_faillock\\.so\\s+authsucc.*$' \"$pam_file\" ; then\n    sed -i --follow-symlinks '/^auth.*pam_faillock\\.so.*authfail.*/a auth        sufficient      pam_faillock.so authsucc' \"$pam_file\"\nfi\n\npam_file=\"/etc/pam.d/common-account\"\nif ! grep -qE '^\\s*account\\s+required\\s+pam_faillock\\.so.*$' \"$pam_file\" ; then\n    echo 'account   required     pam_faillock.so' >> \"$pam_file\"\nfi\n\nfi\n\n\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ]; then\n    regex=\"^\\s*silent\"\n    line=\"silent\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    fi\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if [ -e \"$pam_file\" ] ; then\n            PAM_FILE_PATH=\"$pam_file\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$pam_file\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            \n        if grep -qP \"^\\s*auth\\s.*\\bpam_faillock.so\\s.*\\bsilent\\b\" \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks \"s/(.*auth.*pam_faillock.so.*)\\bsilent\\b=?[[:alnum:]]*(.*)/\\1\\2/g\" \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$pam_file was not found\" >&2\n        fi\n    done\nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so (preauth|authfail).*silent' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*silent.*/ s/$/ silent/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238235",
        "stig_id": "UBTU-20-010072"
      },
      "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time",
        "title": "Set Lockout Time for Failed Password Attempts",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.3"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.8"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000044",
              "CCI-002236",
              "CCI-002237",
              "CCI-002238"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-7(b)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000021-GPOS-00005",
              "SRG-OS-000329-GPOS-00128"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FIA_AFL.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.1.7"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010072"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238235r853414_rule"
            ]
          }
        ],
        "description": "This rule configures the system to lock out accounts during a specified time period after a\nnumber of incorrect login attempts using <code>pam_faillock.so</code>.\n\nEnsure that the file <code>/etc/security/faillock.conf</code> contains the following entry:\n<code>unlock_time=&lt;interval-in-seconds&gt;</code> where\n<code>interval-in-seconds</code> is <code>0</code> or greater.\n\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected. In order to avoid any errors when manually editing these files,\nit is recommended to use the appropriate tools, such as <code>authselect</code> or <code>authconfig</code>,\ndepending on the OS version.\n\nIf <code>unlock_time</code> is set to <code>0</code>, manual intervention by an administrator is required\nto unlock a user. This should be done using the <code>faillock</code> tool.",
        "rationale": "By limiting the number of failed logon attempts the risk of unauthorized system\naccess via user password guessing, otherwise known as brute-forcing, is reduced.\nLimits are imposed by locking the account.",
        "warnings": [
          {
            "text": "If the system supports the new <code>/etc/security/faillock.conf</code> file but the\npam_faillock.so parameters are defined directly in <code>/etc/pam.d/system-auth</code> and\n<code>/etc/pam.d/password-auth</code>, the remediation will migrate the <code>unlock_time</code> parameter\nto <code>/etc/security/faillock.conf</code> to ensure compatibility with <code>authselect</code> tool.\nThe parameters <code>deny</code> and <code>fail_interval</code>, if used, also have to be migrated\nby their respective remediation.",
            "category": "general"
          },
          {
            "text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.",
            "category": "general"
          }
        ],
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_passwords_pam_faillock_unlock_time:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_passwords_pam_faillock_unlock_time",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Check if system relies on\n    authselect tool\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Remediation where authselect\n    tool is present\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect\n      current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    failed_when: false\n\n  - name: Set Lockout Time for Failed Password Attempts - Informative message based\n      on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd.rc == 0\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Set Lockout Time for Failed Password Attempts - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure \"with-faillock\" feature\n      is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-faillock\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-faillock\")\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Remediation where authselect\n    tool is not present\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if pam_faillock.so\n      is already enabled\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail)\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_is_enabled\n\n  - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so preauth\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so preauth\n      insertbefore: ^auth.*sufficient.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so authfail\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so authfail\n      insertbefore: ^auth.*required.*pam_deny\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so account\n      section editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: account     required      pam_faillock.so\n      insertbefore: ^account.*required.*pam_unix\\.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_passwords_pam_faillock_unlock_time # promote to variable\n  set_fact:\n    var_accounts_passwords_pam_faillock_unlock_time: !!str 0\n  tags:\n    - always\n\n- name: Set Lockout Time for Failed Password Attempts - Check the presence of /etc/security/faillock.conf\n    file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so\n    unlock_time parameter in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*unlock_time\\s*=\n    line: unlock_time = {{ var_accounts_passwords_pam_faillock_unlock_time }}\n    state: present\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so\n    unlock_time parameter not in PAM files\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if /etc/pam.d/system-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Set Lockout Time for Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Set Lockout Time for Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Set Lockout Time for Failed Password Attempts - Check if system relies\n        on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure authselect custom\n        profile is used if authselect is present\n      block:\n\n      - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Set Lockout Time for Failed Password Attempts - Informative message\n          based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Check if any custom\n          profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Change the PAM file\n          to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Set Lockout Time for Failed Password Attempts - Define a fact for control\n        already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure the \"unlock_time\"\n        option from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bunlock_time\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if /etc/pam.d/password-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Set Lockout Time for Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Set Lockout Time for Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Set Lockout Time for Failed Password Attempts - Check if system relies\n        on authselect tool\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure authselect custom\n        profile is used if authselect is present\n      block:\n\n      - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        failed_when: false\n\n      - name: Set Lockout Time for Failed Password Attempts - Informative message\n          based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd.rc == 0\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Check if any custom\n          profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Change the PAM file\n          to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Set Lockout Time for Failed Password Attempts - Define a fact for control\n        already filtered in case filters are used\n      ansible.builtin.set_fact:\n        pam_module_control: ''\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure the \"unlock_time\"\n        option from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bunlock_time\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so\n    unlock_time parameter in PAM files\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if pam_faillock.so\n      unlock_time parameter is already enabled in pam files\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock\\.so (preauth|authfail).*unlock_time\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_unlock_time_parameter_is_present\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the inclusion of\n      pam_faillock.so preauth unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)\n      line: \\1required\\3 unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time\n        }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the inclusion of\n      pam_faillock.so authfail unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)\n      line: \\1required\\3 unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time\n        }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so preauth unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)(unlock_time)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_unlock_time }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found > 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so authfail unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)(unlock_time)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_unlock_time }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found > 0\n  when:\n  - '\"libpam-runtime\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - CJIS-5.5.3\n  - DISA-STIG-UBTU-20-010072\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - PCI-DSSv4-8.3.4\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_passwords_pam_faillock_unlock_time",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_accounts_passwords_pam_faillock_unlock_time='0'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    \npam_file=\"/etc/pam.d/common-auth\"\nif ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+preauth.*$' \"$pam_file\" ; then\n    # insert at the top\n    sed -i --follow-symlinks '/^# here are the per-package modules/i auth        required      pam_faillock.so preauth' \"$pam_file\"\nfi\nif ! grep -qE '^\\s*auth\\s+\\[default=die\\]\\s+pam_faillock\\.so\\s+authfail.*$' \"$pam_file\" ; then\n\n    num_lines=$(sed -n 's/^\\s*auth.*success=\\([1-9]\\).*pam_unix\\.so.*/\\1/p' \"$pam_file\")\n    if [ ! -z \"$num_lines\" ]; then\n\n        # Add pam_faillock (authfail) module below pam_unix, skipping N-1 lines, where N is\n        # the number of jumps in the pam_unix success=N statement. Ignore commented and empty lines.\n\n        append_position=$(cat -n \"${pam_file}\" \\\n                          | grep -P \"^\\s+\\d+\\s+auth\\s+.*$\" \\\n                          | grep -w \"pam_unix.so\" -A $(( num_lines - 1 )) \\\n                          | tail -n 1 | cut -f 1 | tr -d ' '\n                         )\n        sed -i --follow-symlinks ''${append_position}'a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    else\n        sed -i --follow-symlinks '/^auth.*pam_unix\\.so.*/a auth        [default=die]      pam_faillock.so authfail' \"$pam_file\"\n    fi\nfi\nif ! grep -qE '^\\s*auth\\s+sufficient\\s+pam_faillock\\.so\\s+authsucc.*$' \"$pam_file\" ; then\n    sed -i --follow-symlinks '/^auth.*pam_faillock\\.so.*authfail.*/a auth        sufficient      pam_faillock.so authsucc' \"$pam_file\"\nfi\n\npam_file=\"/etc/pam.d/common-account\"\nif ! grep -qE '^\\s*account\\s+required\\s+pam_faillock\\.so.*$' \"$pam_file\" ; then\n    echo 'account   required     pam_faillock.so' >> \"$pam_file\"\nfi\n\nfi\n\nAUTH_FILES=(\"/etc/pam.d/common-auth\")\n\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ]; then\n    regex=\"^\\s*unlock_time\\s*=\"\n    line=\"unlock_time = $var_accounts_passwords_pam_faillock_unlock_time\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(unlock_time\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_unlock_time\"'|g' $FAILLOCK_CONF\n    fi\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if [ -e \"$pam_file\" ] ; then\n            PAM_FILE_PATH=\"$pam_file\"\n            if [ -f /usr/bin/authselect ]; then\n                \n                if ! authselect check; then\n                echo \"\n                authselect integrity check failed. Remediation aborted!\n                This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                It is not recommended to manually edit the PAM files when authselect tool is available.\n                In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                exit 1\n                fi\n\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$pam_file\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n\n                authselect apply-changes -b\n            fi\n            \n        if grep -qP \"^\\s*auth\\s.*\\bpam_faillock.so\\s.*\\bunlock_time\\b\" \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks \"s/(.*auth.*pam_faillock.so.*)\\bunlock_time\\b=?[[:alnum:]]*(.*)/\\1\\2/g\" \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$pam_file was not found\" >&2\n        fi\n    done\nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock\\.so (preauth|authfail).*unlock_time' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*preauth.*silent.*/ s/$/ unlock_time='\"$var_accounts_passwords_pam_faillock_unlock_time\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock\\.so.*authfail.*/ s/$/ unlock_time='\"$var_accounts_passwords_pam_faillock_unlock_time\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*preauth.*silent.*\\)\\('\"unlock_time\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_unlock_time\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock\\.so.*authfail.*\\)\\('\"unlock_time\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_unlock_time\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238235",
        "stig_id": "UBTU-20-010072"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit",
        "title": "Ensure PAM Enforces Password Requirements - Minimum Digit Characters",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.3.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000194"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(a)",
              "IA-5(4)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000071-GPOS-00039"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_SMF_EXT.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010052"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238223r653844_rule"
            ]
          }
        ],
        "description": "The pam_pwquality module&#x27;s <code>dcredit</code> parameter controls requirements for\nusage of digits in a password. When set to a negative number, any password will be required to\ncontain that many digits. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each digit. Modify the <code>dcredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of a digit in passwords.",
        "rationale": "Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossible combinations that need to be tested before the password is compromised.\nRequiring digits makes password guessing attacks more difficult by ensuring a larger\nsearch space.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_dcredit:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_dcredit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010052\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_dcredit # promote to variable\n  set_fact:\n    var_password_pam_dcredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Digit Characters - Ensure\n    PAM variable dcredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*dcredit\n    line: dcredit = {{ var_password_pam_dcredit }}\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010052\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_dcredit",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_dcredit='-1'\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^dcredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dcredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^dcredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^dcredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238223",
        "stig_id": "UBTU-20-010052"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_dictcheck": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_dictcheck",
        "title": "Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(a)",
              "IA-5(4)",
              "IA-5(c)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00225"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010056"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238227r653856_rule"
            ]
          }
        ],
        "description": "The pam_pwquality module&#x27;s <code>dictcheck</code> check if passwords contains dictionary words. When\n<code>dictcheck</code> is set to <code>1</code> passwords will be checked for dictionary words.",
        "rationale": "Use of a complex password helps to increase the time and resources required to compromise the password.\nPassword complexity, or strength, is a measure of the effectiveness of a password in resisting attempts at\nguessing and brute-force attacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes to crack a password. The more\ncomplex the password, the greater the number of possible combinations that need to be tested before the\npassword is compromised.\n<br>\n          <br>\nPasswords with dictionary words may be more vulnerable to password-guessing attacks.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_dictcheck:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_dictcheck",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010056\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_dictcheck\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_dictcheck # promote to variable\n  set_fact:\n    var_password_pam_dictcheck: !!str 1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary\n    Words - Ensure PAM variable dictcheck is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*dictcheck\n    line: dictcheck = {{ var_password_pam_dictcheck }}\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010056\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_dictcheck\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_dictcheck",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_dictcheck='1'\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^dictcheck\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dictcheck\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^dictcheck\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^dictcheck\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238227",
        "stig_id": "UBTU-20-010056"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_difok": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_difok",
        "title": "Ensure PAM Enforces Password Requirements - Minimum Different Characters",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.6.2.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000195"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(b)",
              "IA-5(4)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000072-GPOS-00040"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010053"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238224r653847_rule"
            ]
          }
        ],
        "description": "The pam_pwquality module&#x27;s <code>difok</code> parameter sets the number of characters\nin a password that must not be present in and old password during a password change.\n<br>\n          <br>\nModify the <code>difok</code> setting in <code>/etc/security/pwquality.conf</code>\nto equal 8 to require differing characters\nwhen changing passwords.",
        "rationale": "Use of a complex password helps to increase the time and resources\nrequired to compromise the password. Password complexity, or strength,\nis a measure of the effectiveness of a password in resisting attempts\nat guessing and bruteforce attacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long\nit takes to crack a password. The more complex the password, the\ngreater the number of possible combinations that need to be tested\nbefore the password is compromised.\n<br>\n          <br>\nRequiring a minimum number of different characters during password changes ensures that\nnewly changed passwords should not resemble previously compromised ones.\nNote that passwords which are changed on compromised systems will still be compromised, however.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_difok:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_difok",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010053\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(b)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_difok\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_difok # promote to variable\n  set_fact:\n    var_password_pam_difok: !!str 8\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Different Characters -\n    Ensure PAM variable difok is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*difok\n    line: difok = {{ var_password_pam_difok }}\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010053\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(b)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_difok\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_difok",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_difok='8'\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^difok\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_difok\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^difok\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^difok\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238224",
        "stig_id": "UBTU-20-010053"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_enforcing": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_enforcing",
        "title": "Ensure PAM Enforces Password Requirements - Enforcing",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00225"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010057"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238228r653859_rule"
            ]
          }
        ],
        "description": "Verify that the operating system uses &quot;pwquality&quot; to enforce the\npassword complexity rules.\n\nVerify the pwquality module is being enforced by operating system by\nrunning the following command:\n<pre>\n$ grep -i enforcing /etc/security/pwquality.conf\nenforcing = 1\n</pre>\n\nIf the value of &quot;enforcing&quot; is not &quot;1&quot; or the line is commented out,\nthis is a finding.",
        "rationale": "Use of a complex password helps to increase the time and resources\nrequired to compromise the password. Password complexity, or strength,\nis a measure of the effectiveness of a password in resisting attempts at\nguessing and brute-force attacks. Using enforcing=1 ensures &quot;pwquality&quot;\nenforces complex password construction configuration and has the ability\nto limit brute-force attacks on the system.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_enforcing:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_enforcing",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010057\n  - accounts_password_pam_enforcing\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure PAM Enforces Password Requirements - Enforcing\n  lineinfile:\n    path: /etc/security/pwquality.conf\n    create: true\n    line: enforcing = 1\n    state: present\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010057\n  - accounts_password_pam_enforcing\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_enforcing",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nif [ -e \"/etc/security/pwquality.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*enforcing = 1/Id\" \"/etc/security/pwquality.conf\"\nelse\n    touch \"/etc/security/pwquality.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/security/pwquality.conf\"\n\ncp \"/etc/security/pwquality.conf\" \"/etc/security/pwquality.conf.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"enforcing = 1\" >> \"/etc/security/pwquality.conf\"\n# Clean up after ourselves.\nrm \"/etc/security/pwquality.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238228",
        "stig_id": "UBTU-20-010057"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit",
        "title": "Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.3.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000193"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(a)",
              "IA-5(4)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000070-GPOS-00038"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_SMF_EXT.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010051"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238222r653841_rule"
            ]
          }
        ],
        "description": "The pam_pwquality module&#x27;s <code>lcredit</code> parameter controls requirements for\nusage of lowercase letters in a password. When set to a negative number, any password will be required to\ncontain that many lowercase characters. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each lowercase character. Modify the <code>lcredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of a lowercase character in passwords.",
        "rationale": "Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossble combinations that need to be tested before the password is compromised.\nRequiring a minimum number of lowercase characters makes password guessing attacks\nmore difficult by ensuring a larger search space.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_lcredit:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_lcredit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010051\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_lcredit # promote to variable\n  set_fact:\n    var_password_pam_lcredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters -\n    Ensure PAM variable lcredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*lcredit\n    line: lcredit = {{ var_password_pam_lcredit }}\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010051\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_lcredit",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_lcredit='-1'\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^lcredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_lcredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^lcredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^lcredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238222",
        "stig_id": "UBTU-20-010051"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen",
        "title": "Ensure PAM Enforces Password Requirements - Minimum Length",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31",
              "R68"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.3.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.6.2.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000205"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(a)",
              "IA-5(4)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000078-GPOS-00046"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_SMF_EXT.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010054"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238225r832942_rule"
            ]
          }
        ],
        "description": "The pam_pwquality module&#x27;s <code>minlen</code> parameter controls requirements for\nminimum characters required in a password. Add <code>minlen=15\n          </code>\nafter pam_pwquality to set minimum password length requirements.",
        "rationale": "The shorter the password, the lower the number of possible combinations\nthat need to be tested before the password is compromised.\n<br>\nPassword complexity, or strength, is a measure of the effectiveness of a\npassword in resisting attempts at guessing and brute-force attacks.\nPassword length is one factor of several that helps to determine strength\nand how long it takes to crack a password. Use of more characters in a password\nhelps to exponentially increase the time and/or resources required to\ncompromise the password.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_minlen:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_minlen",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010054\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_minlen # promote to variable\n  set_fact:\n    var_password_pam_minlen: !!str 15\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Length - Ensure PAM variable\n    minlen is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*minlen\n    line: minlen = {{ var_password_pam_minlen }}\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.6.2.1.1\n  - DISA-STIG-UBTU-20-010054\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.6\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_minlen",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_minlen='15'\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^minlen\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minlen\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^minlen\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^minlen\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238225",
        "stig_id": "UBTU-20-010054"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_ocredit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_ocredit",
        "title": "Ensure PAM Enforces Password Requirements - Minimum Special Characters",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.3.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001619"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(a)",
              "IA-5(4)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000266-GPOS-00101"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_SMF_EXT.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010055"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238226r653853_rule"
            ]
          }
        ],
        "description": "The pam_pwquality module&#x27;s <code>ocredit=</code> parameter controls requirements for\nusage of special (or &quot;other&quot;) characters in a password. When set to a negative number,\nany password will be required to contain that many special characters.\nWhen set to a positive number, pam_pwquality will grant +1\nadditional length credit for each special character. Modify the <code>ocredit</code> setting\nin <code>/etc/security/pwquality.conf</code> to equal -1\nto require use of a special character in passwords.",
        "rationale": "Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossible combinations that need to be tested before the password is compromised.\nRequiring a minimum number of special characters makes password guessing attacks\nmore difficult by ensuring a larger search space.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_ocredit:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_ocredit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010055\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_ocredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_ocredit # promote to variable\n  set_fact:\n    var_password_pam_ocredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Special Characters - Ensure\n    PAM variable ocredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*ocredit\n    line: ocredit = {{ var_password_pam_ocredit }}\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010055\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - accounts_password_pam_ocredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_ocredit",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_ocredit='-1'\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ocredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ocredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^ocredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^ocredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238226",
        "stig_id": "UBTU-20-010055"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_retry": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_retry",
        "title": "Ensure PAM Enforces Password Requirements - Authentication Retry Prompts Permitted Per-Session",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R68"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.3.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "15",
              "16",
              "3",
              "5",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.3"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000192",
              "CCI-000366"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4",
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-7(a)",
              "CM-6(a)",
              "IA-5(4)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7",
              "PR.IP-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000069-GPOS-00037",
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_MOF_EXT.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010057"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238228r653859_rule"
            ]
          }
        ],
        "description": "To configure the number of retry prompts that are permitted per-session:\n\nEdit the <code>pam_pwquality.so</code> statement in\n\n<code>/etc/pam.d/common-password</code> to show\n\n\n<code>retry=3\n          </code>, or a lower value if site\npolicy is more restrictive. The DoD requirement is a maximum of 3 prompts\nper session.",
        "rationale": "Setting the password retry prompts that are permitted on a per-session basis to a low value\nrequires some software, such as SSH, to re-connect. This can slow down and\ndraw additional attention to some types of password-guessing attacks. Note that this\nis different from account lockout, which is provided by the pam_faillock module.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_retry:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_retry",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_retry='3'\n\n\nif [ -e \"/etc/pam.d/common-password\" ] ; then\n    valueRegex=\"$var_password_pam_retry\" defaultValue=\"$var_password_pam_retry\"\n    # non-empty values need to be preceded by an equals sign\n    [ -n \"${valueRegex}\" ] && valueRegex=\"=${valueRegex}\"\n    # add an equals sign to non-empty values\n    [ -n \"${defaultValue}\" ] && defaultValue=\"=${defaultValue}\"\n\n    # fix 'type' if it's wrong\n    if grep -q -P \"^\\\\s*(?\"'!'\"password\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_pwquality.so\" < \"/etc/pam.d/common-password\" ; then\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_pwquality.so)/\\\\1password\\\\2/\" \"/etc/pam.d/common-password\"\n    fi\n\n    # fix 'control' if it's wrong\n    if grep -q -P \"^\\\\s*password\\\\s+(?\"'!'\"requisite)[[:alnum:]]+\\\\s+pam_pwquality.so\" < \"/etc/pam.d/common-password\" ; then\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+)[[:alnum:]]+(\\\\s+pam_pwquality.so)/\\\\1requisite\\\\2/\" \"/etc/pam.d/common-password\"\n    fi\n\n    # fix the value for 'option' if one exists but does not match 'valueRegex'\n    if grep -q -P \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so(\\\\s.+)?\\\\s+retry(?\"'!'\"${valueRegex}(\\\\s|\\$))\" < \"/etc/pam.d/common-password\" ; then\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so(\\\\s.+)?\\\\s)retry=[^[:space:]]*/\\\\1retry${defaultValue}/\" \"/etc/pam.d/common-password\"\n\n    # add 'option=default' if option is not set\n    elif grep -q -E \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so\" < \"/etc/pam.d/common-password\" &&\n            grep    -E \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so\" < \"/etc/pam.d/common-password\" | grep -q -E -v \"\\\\sretry(=|\\\\s|\\$)\" ; then\n\n        sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so[^\\\\n]*)/\\\\1 retry${defaultValue}/\" \"/etc/pam.d/common-password\"\n    # add a new entry if none exists\n    elif ! grep -q -P \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so(\\\\s.+)?\\\\s+retry${valueRegex}(\\\\s|\\$)\" < \"/etc/pam.d/common-password\" ; then\n        echo \"password requisite pam_pwquality.so retry${defaultValue}\" >> \"/etc/pam.d/common-password\"\n    fi\nelse\n    echo \"/etc/pam.d/common-password doesn't exist\" >&2\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238228",
        "stig_id": "UBTU-20-010057"
      },
      "xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit",
        "title": "Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R31"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.3.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000192",
              "CCI-000193"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0421",
              "0422",
              "0431",
              "0974",
              "1173",
              "1401",
              "1504",
              "1505",
              "1546",
              "1557",
              "1558",
              "1559",
              "1560",
              "1561"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(a)",
              "IA-5(4)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000069-GPOS-00037",
              "SRG-OS-000070-GPOS-00038"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_SMF_EXT.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010050"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238221r653838_rule"
            ]
          }
        ],
        "description": "The pam_pwquality module&#x27;s <code>ucredit=</code> parameter controls requirements for\nusage of uppercase letters in a password. When set to a negative number, any password will be required to\ncontain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each uppercase character. Modify the <code>ucredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of an uppercase character in passwords.",
        "rationale": "Use of a complex password helps to increase the time and resources required to compromise the password.\nPassword complexity, or strength, is a measure of the effectiveness of a password in resisting attempts\nat guessing and brute-force attacks.\n<br>\n          <br>\nPassword complexity is one factor of several that determines how long it takes to crack a password. The more\ncomplex the password, the greater the number of possible combinations that need to be tested before\nthe password is compromised.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_password_pam_ucredit:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_password_pam_ucredit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010050\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_ucredit # promote to variable\n  set_fact:\n    var_password_pam_ucredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters -\n    Ensure PAM variable ucredit is set accordingly\n  ansible.builtin.lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*ucredit\n    line: ucredit = {{ var_password_pam_ucredit }}\n  when: '\"libpam-runtime\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010050\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_password_pam_ucredit",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_password_pam_ucredit='-1'\n\n\n\n\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ucredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ucredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^ucredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^ucredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    if [[ -s \"/etc/security/pwquality.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/security/pwquality.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/security/pwquality.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238221",
        "stig_id": "UBTU-20-010050"
      },
      "xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_logindefs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_logindefs",
        "title": "Set Password Hashing Algorithm in /etc/login.defs",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.6.2.2"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.13.11"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000196"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0418",
              "1055",
              "1402"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(c)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000073-GPOS-00041"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.1"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010404"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238325r654150_rule"
            ]
          }
        ],
        "description": "In <code>/etc/login.defs</code>, add or update the following line to ensure the system will use\nSHA512 as the hashing algorithm:\n<pre>ENCRYPT_METHOD SHA512\n         </pre>\n        ",
        "rationale": "Passwords need to be protected at all times, and encryption is the standard method for\nprotecting passwords. If passwords are not encrypted, they can be plainly read\n(i.e., clear text) and easily compromised. Passwords that are encrypted with a weak algorithm\nare no more protected than if they are kept in plain text.\n<br>\n         <br>\nUsing a stronger hashing algorithm makes password cracking attacks more difficult.",
        "platforms": [
          "#package_shadow-utils"
        ],
        "oval_definition_id": "oval:ssg-set_password_hashing_algorithm_logindefs:def:1",
        "remediations": [
          {
            "remediation_id": "set_password_hashing_algorithm_logindefs",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'login' 2>/dev/null | grep -q installed; then\n\nvar_password_hashing_algorithm='SHA512'\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ENCRYPT_METHOD\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_password_hashing_algorithm\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^ENCRYPT_METHOD\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^ENCRYPT_METHOD\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238325",
        "stig_id": "UBTU-20-010404"
      },
      "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_burstaction": {
        "rule_id": "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_burstaction",
        "title": "Disable Ctrl-Alt-Del Burst Action",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.4.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(B)",
              "164.308(a)(7)(i)",
              "164.308(a)(7)(ii)(A)",
              "164.310(a)(1)",
              "164.310(a)(2)(i)",
              "164.310(a)(2)(ii)",
              "164.310(a)(2)(iii)",
              "164.310(b)",
              "164.310(c)",
              "164.310(d)(1)",
              "164.310(d)(2)(iii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-6(a)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000324-GPOS-00125",
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010460"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238380r832974_rule"
            ]
          }
        ],
        "description": "By default, <code>SystemD</code> will reboot the system if the <code>Ctrl-Alt-Del</code>\nkey sequence is pressed Ctrl-Alt-Delete more than 7 times in 2 seconds.\n<br>\n        <br>\nTo configure the system to ignore the <code>CtrlAltDelBurstAction</code>\n\nsetting, add or modify the following to <code>/etc/systemd/system.conf</code>:\n<pre>CtrlAltDelBurstAction=none</pre>\n       ",
        "rationale": "A locally logged-in user who presses Ctrl-Alt-Del, when at the console,\ncan reboot the system. If accidentally pressed, as could happen in\nthe case of mixed OS environment, this can create the risk of short-term\nloss of availability of systems due to unintentional reboot.",
        "platforms": [
          "#package_systemd"
        ],
        "oval_definition_id": "oval:ssg-disable_ctrlaltdel_burstaction:def:1",
        "remediations": [
          {
            "remediation_id": "disable_ctrlaltdel_burstaction",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010460\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(a)\n  - disable_ctrlaltdel_burstaction\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n\n- name: Disable Ctrl-Alt-Del Burst Action\n  lineinfile:\n    dest: /etc/systemd/system.conf\n    state: present\n    regexp: ^CtrlAltDelBurstAction\n    line: CtrlAltDelBurstAction=none\n    create: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"systemd\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010460\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(a)\n  - disable_ctrlaltdel_burstaction\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "disable_ctrlaltdel_burstaction",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { dpkg-query --show --showformat='${db:Status-Status}\\n' 'systemd' 2>/dev/null | grep -q installed; }; then\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^CtrlAltDelBurstAction=\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s=%s\" \"$stripped_key\" \"none\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^CtrlAltDelBurstAction=\\\\>\" \"/etc/systemd/system.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^CtrlAltDelBurstAction=\\\\>.*/$escaped_formatted_output/gi\" \"/etc/systemd/system.conf\"\nelse\n    if [[ -s \"/etc/systemd/system.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/systemd/system.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/systemd/system.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/systemd/system.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238380",
        "stig_id": "UBTU-20-010460"
      },
      "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_reboot": {
        "rule_id": "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_reboot",
        "title": "Disable Ctrl-Alt-Del Reboot Activation",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.4.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(B)",
              "164.308(a)(7)(i)",
              "164.308(a)(7)(ii)(A)",
              "164.310(a)(1)",
              "164.310(a)(2)(i)",
              "164.310(a)(2)(ii)",
              "164.310(a)(2)(iii)",
              "164.310(b)",
              "164.310(c)",
              "164.310(d)(1)",
              "164.310(d)(2)(iii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000324-GPOS-00125",
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010460"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238380r832974_rule"
            ]
          }
        ],
        "description": "By default, <code>SystemD</code> will reboot the system if the <code>Ctrl-Alt-Del</code>\nkey sequence is pressed.\n<br>\n        <br>\nTo configure the system to ignore the <code>Ctrl-Alt-Del</code> key sequence from the\n\ncommand line instead of rebooting the system, do either of the following:\n<pre>ln -sf /dev/null /etc/systemd/system/ctrl-alt-del.target</pre>\nor\n<pre>systemctl mask ctrl-alt-del.target</pre>\n        <br>\n        <br>\nDo not simply delete the <code>/usr/lib/systemd/system/ctrl-alt-del.service</code> file,\nas this file may be restored during future system updates.",
        "rationale": "A locally logged-in user who presses Ctrl-Alt-Del, when at the console,\ncan reboot the system. If accidentally pressed, as could happen in\nthe case of mixed OS environment, this can create the risk of short-term\nloss of availability of systems due to unintentional reboot.",
        "oval_definition_id": "oval:ssg-disable_ctrlaltdel_reboot:def:1",
        "remediations": [
          {
            "remediation_id": "disable_ctrlaltdel_reboot",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "- name: Disable Ctrl-Alt-Del Reboot Activation\n  systemd:\n    name: ctrl-alt-del.target\n    force: true\n    masked: true\n    state: stopped\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010460\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - disable_ctrlaltdel_reboot\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "disable_ctrlaltdel_reboot",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nsystemctl disable --now ctrl-alt-del.target\nsystemctl mask --now ctrl-alt-del.target\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238380",
        "stig_id": "UBTU-20-010460"
      },
      "xccdf_org.ssgproject.content_rule_vlock_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_vlock_installed",
        "title": "Check that vlock is installed to allow session locking",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000056",
              "CCI-000058",
              "CCI-000060"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000028-GPOS-00009",
              "SRG-OS-000030-GPOS-00011"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010005"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238200r653775_rule"
            ]
          }
        ],
        "description": "The Ubuntu 20.04 operating system must have vlock installed to allow for session locking.\n\n\nThe <code>vlock</code> package can be installed with the following command:\n<pre>\n$ apt-get install vlock</pre>\n         ",
        "rationale": "A session lock is a temporary action taken when a user stops work and\nmoves away from the immediate physical vicinity of the information\nsystem but does not want to log out because of the temporary nature of\nthe absence.\n\nThe session lock is implemented at the point where session activity can\nbe determined.\n\nRegardless of where the session lock is determined and implemented,\nonce invoked, the session lock must remain in place until the user\nreauthenticates. No other activity aside from reauthentication must\nunlock the system.",
        "oval_definition_id": "oval:ssg-vlock_installed:def:1",
        "remediations": [
          {
            "remediation_id": "vlock_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure vlock is installed\n  package:\n    name: vlock\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010005\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - vlock_installed\n"
          },
          {
            "remediation_id": "vlock_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_vlock\n\nclass install_vlock {\n  package { 'vlock':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "vlock_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"vlock\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "vlock_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"vlock\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238200",
        "stig_id": "UBTU-20-010005"
      },
      "xccdf_org.ssgproject.content_rule_package_opensc_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_opensc_installed",
        "title": "Install the opensc Package For Multifactor Authentication",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001953",
              "CCI-001954"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "1382",
              "1384",
              "1386"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000375-GPOS-00160",
              "SRG-OS-000376-GPOS-00161"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010064"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238231r853411_rule"
            ]
          }
        ],
        "description": "\nThe <code>opensc-pkcs11</code> package can be installed with the following command:\n<pre>\n$ apt-get install opensc-pkcs11</pre>\n         ",
        "rationale": "Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards such\nas the U.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
        "oval_definition_id": "oval:ssg-package_opensc_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_opensc_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure opensc-pkcs11 is installed\n  package:\n    name: opensc-pkcs11\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010064\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_opensc_installed\n"
          },
          {
            "remediation_id": "package_opensc_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_opensc-pkcs11\n\nclass install_opensc-pkcs11 {\n  package { 'opensc-pkcs11':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_opensc_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"opensc-pkcs11\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_opensc_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"opensc-pkcs11\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238231",
        "stig_id": "UBTU-20-010064"
      },
      "xccdf_org.ssgproject.content_rule_install_smartcard_packages": {
        "rule_id": "xccdf_org.ssgproject.content_rule_install_smartcard_packages",
        "title": "Install Smart Card Packages For Multifactor Authentication",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000765",
              "CCI-001948",
              "CCI-001953",
              "CCI-001954"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000105-GPOS-00052",
              "SRG-OS-000375-GPOS-00160",
              "SRG-OS-000375-GPOS-00161",
              "SRG-OS-000377-GPOS-00162"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010063"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238230r853410_rule"
            ]
          }
        ],
        "description": "Configure the operating system to implement multifactor authentication by\ninstalling the required package with the following command:\n\nThe <code>libpam-pkcs11</code> package can be installed with the following command:\n<pre>\n$ apt-get install libpam-pkcs11</pre>\n         ",
        "rationale": "Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards such\nas the U.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
        "platforms": [
          "#not_s390x_arch"
        ],
        "oval_definition_id": "oval:ssg-install_smartcard_packages:def:1",
        "remediations": [
          {
            "remediation_id": "install_smartcard_packages",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure libpam-pkcs11 is installed\n  package:\n    name: libpam-pkcs11\n    state: present\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture != \"s390x\"\n  tags:\n  - DISA-STIG-UBTU-20-010063\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.3\n  - enable_strategy\n  - install_smartcard_packages\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "install_smartcard_packages",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_libpam-pkcs11\n\nclass install_libpam-pkcs11 {\n  package { 'libpam-pkcs11':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "install_smartcard_packages",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"libpam-pkcs11\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "install_smartcard_packages",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { ! grep -q s390x /proc/sys/kernel/osrelease; }; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"libpam-pkcs11\"\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nsed -i -e 's/debug = true/debug = false/g' -e 's|module = /usr/lib/opensc-pkcs11|module = /usr/lib/x86_64-linux-gnu/pkcs11/opensc-pkcs11|' /etc/pam_pkcs11/pam_pkcs11.conf\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238230",
        "stig_id": "UBTU-20-010063"
      },
      "xccdf_org.ssgproject.content_rule_smartcard_configure_ca": {
        "rule_id": "xccdf_org.ssgproject.content_rule_smartcard_configure_ca",
        "title": "Configure Smart Card Certificate Authority Validation",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000185",
              "CCI-001991"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000066-GPOS-00034",
              "SRG-OS-000384-GPOS-00167"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010060"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238229r653862_rule"
            ]
          }
        ],
        "description": "Configure the operating system to do certificate status checking for PKI\nauthentication. Modify all of the <code>cert_policy</code> lines in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> to include <code>ca</code> like so:\n<pre>cert_policy = ca, ocsp_on, signature;</pre>\n         ",
        "rationale": "Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards such\nas the U.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
        "oval_definition_id": "oval:ssg-smartcard_configure_ca:def:1",
        "remediations": [
          {
            "remediation_id": "smartcard_configure_ca",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nif grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"ca\"; then\n    sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238229",
        "stig_id": "UBTU-20-010060"
      },
      "xccdf_org.ssgproject.content_rule_smartcard_configure_cert_checking": {
        "rule_id": "xccdf_org.ssgproject.content_rule_smartcard_configure_cert_checking",
        "title": "Configure Smart Card Certificate Status Checking",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001948",
              "CCI-001953",
              "CCI-001954"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000375-GPOS-00160",
              "SRG-OS-000376-GPOS-00161",
              "SRG-OS-000377-GPOS-00162",
              "SRG-OS-000384-GPOS-00167"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010065"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238232r853412_rule"
            ]
          }
        ],
        "description": "Configure the operating system to do certificate status checking for PKI\nauthentication. Modify all of the <code>cert_policy</code> lines in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> to include <code>ocsp_on</code> like so:\n<pre>cert_policy = ca, ocsp_on, signature;</pre>\n         ",
        "rationale": "Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br>\n          <br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards such\nas the U.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
        "platforms": [
          "#not_s390x_arch"
        ],
        "oval_definition_id": "oval:ssg-smartcard_configure_cert_checking:def:1",
        "remediations": [
          {
            "remediation_id": "smartcard_configure_cert_checking",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { ! grep -q s390x /proc/sys/kernel/osrelease; }; then\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nif grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"oscp_on\"; then\n    sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238232",
        "stig_id": "UBTU-20-010065"
      },
      "xccdf_org.ssgproject.content_rule_smartcard_configure_crl": {
        "rule_id": "xccdf_org.ssgproject.content_rule_smartcard_configure_crl",
        "title": "Configure Smart Card Local Cache of Revocation Data",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001991"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000384-GPOS-00167"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010066"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238233r880870_rule"
            ]
          }
        ],
        "description": "Configure the operating system for PKI-based authentication to use\nlocal revocation data when unable to access the network to obtain it\nremotely. Modify all of the <code>cert_policy</code> lines in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> to include <code>crl_auto</code>\nor <code>crl_offline</code> like so:\n<pre>cert_policy = ca,signature,ocsp_on,crl_auto;</pre>\n         ",
        "rationale": "Without configuring a local cache of revocation data, there is the\npotential to allow access to users who are no longer authorized\n(users with revoked certificates).",
        "oval_definition_id": "oval:ssg-smartcard_configure_crl:def:1",
        "remediations": [
          {
            "remediation_id": "smartcard_configure_crl",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then\n    cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nif grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -Eqv 'crl_auto|crl_offline'; then\n    sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on,crl_auto;/\" /etc/pam_pkcs11/pam_pkcs11.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238233",
        "stig_id": "UBTU-20-010066"
      },
      "xccdf_org.ssgproject.content_rule_smartcard_pam_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_smartcard_pam_enabled",
        "title": "Enable Smart Card Logins in PAM",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000187",
              "CCI-000765",
              "CCI-000766",
              "CCI-000767",
              "CCI-000768",
              "CCI-001948",
              "CCI-001953",
              "CCI-001954"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000068-GPOS-00036",
              "SRG-OS-000105-GPOS-00052",
              "SRG-OS-000106-GPOS-00053",
              "SRG-OS-000107-GPOS-00054",
              "SRG-OS-000108-GPOS-00055",
              "SRG-OS-000375-GPOS-00160",
              "SRG-OS-000375-GPOS-00161",
              "SRG-OS-000375-GPOS-00162"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010033"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238210r917810_rule"
            ]
          }
        ],
        "description": "This requirement only applies to components where this is specific to the\nfunction of the device or has the concept of an organizational user (e.g.,\nVPN, proxy capability). This does not apply to authentication for the\npurpose of configuring the device itself (management).\n\nCheck that the <code>pam_pkcs11.so</code> option is configured in the\n<code>etc/pam.d/common-auth</code> file with the following command:\n\n<pre># grep pam_pkcs11.so /etc/pam.d/common-auth\n\n\nauth [success=2 default=ignore] pam_pkcs11.so</pre>\n\n\nFor general information about enabling smart card authentication, consult\nthe documentation at:\n\n<ul><li><b><a href=\"https://pages.ubuntu.com/rs/066-EOV-335/images/SmartCardLogin_WhitePapaer_04.03.20.pdf\">https://pages.ubuntu.com/rs/066-EOV-335/images/SmartCardLogin_WhitePapaer_04.03.20.pdf</a></b></li></ul>\n         ",
        "rationale": "Smart card login provides two-factor authentication stronger than\nthat provided by a username and password combination. Smart cards leverage PKI\n(public key infrastructure) in order to provide and verify credentials.\n\nUsing an authentication device, such as a CAC or token that is separate\nfrom the information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n\nMultifactor solutions that require devices separate from information\nsystems gaining access include, for example, hardware tokens providing\ntime-based or challenge-response authenticators and smart cards such as the\nU.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
        "oval_definition_id": "oval:ssg-smartcard_pam_enabled:def:1",
        "remediations": [
          {
            "remediation_id": "smartcard_pam_enabled",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010033\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - smartcard_pam_enabled\n\n- name: Enable Smart Card Logins in PAM - Gather List of Packages\n  ansible.builtin.package_facts:\n    manager: auto\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010033\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - smartcard_pam_enabled\n\n- name: Enable Smart Card Logins in PAM - Check to See if 'pam_pkcs11' Module Is Configured\n    in '/etc/pam.d/common-auth'\n  ansible.builtin.shell: grep -E '^\\s*auth\\s+\\S+\\s+pam_pkcs11\\.so' /etc/pam.d/common-auth\n    || true\n  register: check_pam_pkcs11_module_result\n  changed_when: false\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"libpam-pkcs11\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010033\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - smartcard_pam_enabled\n\n- name: Enable Smart Card Logins in PAM - Configure 'pam_pkcs11' Module in '/etc/pam.d/common-auth'\n  ansible.builtin.lineinfile:\n    path: /etc/pam.d/common-auth\n    line: auth [success=2 default=ignore] pam_pkcs11.so\n    insertafter: ^\\s*#\n    state: present\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"libpam-pkcs11\" in ansible_facts.packages'\n  - '\"pam_pkcs11.so\" not in check_pam_pkcs11_module_result.stdout'\n  tags:\n  - DISA-STIG-UBTU-20-010033\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - smartcard_pam_enabled\n\n- name: Enable Smart Card Logins in PAM - Ensure 'pam_pkcs11' Module Has [success=2\n    default=ignore] Control Flag\n  ansible.builtin.lineinfile:\n    path: /etc/pam.d/common-auth\n    regexp: ^(\\s*auth\\s+)\\S+(\\s+pam_pkcs11\\.so.*)\n    line: \\g<1>[success=2 default=ignore]\\g<2>\n    backrefs: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"libpam-pkcs11\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010033\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - smartcard_pam_enabled\n"
          },
          {
            "remediation_id": "smartcard_pam_enabled",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif ! grep -qP \"^\\s*auth\\s+[success=2 default=ignore]\\s+pam_pkcs11.so\\s*.*\" \"/etc/pam.d/common-auth\"; then\n    # Line matching group + control + module was not found. Check group + module.\n    if [ \"$(grep -cP '^\\s*auth\\s+.*\\s+pam_pkcs11.so\\s*' \"/etc/pam.d/common-auth\")\" -eq 1 ]; then\n        # The control is updated only if one single line matches.\n        sed -i -E --follow-symlinks \"s/^(\\s*auth\\s+).*(\\bpam_pkcs11.so.*)/\\1[success=2 default=ignore] \\2/\" \"/etc/pam.d/common-auth\"\n    else\n        LAST_MATCH_LINE=$(grep -nP \"# here are the per-package modules\" \"/etc/pam.d/common-auth\" | tail -n 1 | cut -d: -f 1)\n        if [ ! -z $LAST_MATCH_LINE ]; then\n            sed -i --follow-symlinks $LAST_MATCH_LINE\" a auth     [success=2 default=ignore]    pam_pkcs11.so\" \"/etc/pam.d/common-auth\"\n        else\n            echo \"auth    [success=2 default=ignore]    pam_pkcs11.so\" >> \"/etc/pam.d/common-auth\"\n        fi\n    fi\nfi\n# Check the option\nif ! grep -qP \"^\\s*auth\\s+[success=2 default=ignore]\\s+pam_pkcs11.so\\s*.*\\s\\b\" \"/etc/pam.d/common-auth\"; then\n    sed -i -E --follow-symlinks \"/\\s*auth\\s+[success=2 default=ignore]\\s+pam_pkcs11.so.*/ s/$/ /\" \"/etc/pam.d/common-auth\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238210",
        "stig_id": "UBTU-20-010033"
      },
      "xccdf_org.ssgproject.content_rule_verify_use_mappers": {
        "rule_id": "xccdf_org.ssgproject.content_rule_verify_use_mappers",
        "title": "Verify that 'use_mappers' is set to 'pwent' in PAM",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "low",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000187"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000068-GPOS-00036"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010006"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238201r832933_rule"
            ]
          }
        ],
        "description": "The operating system must map the authenticated identity to the user or\ngroup account for PKI-based authentication.\n\nVerify that <code>use_mappers</code> is set to <code>pwent</code> in\n<code>/etc/pam_pkcs11/pam_pkcs11.conf</code> file with the following command:\n\n<pre>$ grep ^use_mappers /etc/pam_pkcs11/pam_pkcs11.conf\n\nuse_mappers = pwent</pre>\n         ",
        "rationale": "Without mapping the certificate used to authenticate to the user account,\nthe ability to determine the identity of the individual user or group will\nnot be available for forensic analysis.",
        "oval_definition_id": "oval:ssg-verify_use_mappers:def:1",
        "remediations": [
          {
            "remediation_id": "verify_use_mappers",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Verify that 'use_mappers' is set to 'pwent' in PAM\n  lineinfile:\n    path: /etc/pam_pkcs11/pam_pkcs11.conf\n    create: true\n    line: use_mappers = pwent\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010006\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - verify_use_mappers\n"
          },
          {
            "remediation_id": "verify_use_mappers",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif [ -e \"/etc/pam_pkcs11/pam_pkcs11.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*use_mappers = pwent/Id\" \"/etc/pam_pkcs11/pam_pkcs11.conf\"\nelse\n    touch \"/etc/pam_pkcs11/pam_pkcs11.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/pam_pkcs11/pam_pkcs11.conf\"\n\ncp \"/etc/pam_pkcs11/pam_pkcs11.conf\" \"/etc/pam_pkcs11/pam_pkcs11.conf.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"use_mappers = pwent\" >> \"/etc/pam_pkcs11/pam_pkcs11.conf\"\n# Clean up after ourselves.\nrm \"/etc/pam_pkcs11/pam_pkcs11.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238201",
        "stig_id": "UBTU-20-010006"
      },
      "xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration": {
        "rule_id": "xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration",
        "title": "Set Account Expiration Following Inactivity",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.4.1.4"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.6.2.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS01.03",
              "DSS03.05",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.5.6"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000017",
              "CCI-000795"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.3",
              "A.18.1.4",
              "A.6.1.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(3)",
              "CM-6(a)",
              "IA-4(e)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "PR.AC-1",
              "PR.AC-4",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000118-GPOS-00060"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.1.4"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.2.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010409"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238330r654165_rule"
            ]
          }
        ],
        "description": "To specify the number of days after a password expires (which\nsignifies inactivity) until an account is permanently disabled, add or correct\nthe following line in <code>/etc/default/useradd</code>:\n<pre>INACTIVE=<i>35</i>\n         </pre>\nIf a password is currently on the verge of expiration, then\n<code>35</code>\nday(s) remain(s) until the account is automatically\ndisabled. However, if the password will not expire for another 60 days, then 60\ndays plus <code>35</code> day(s) could\nelapse until the account would be automatically disabled. See the\n<code>useradd</code> man page for more information.",
        "rationale": "Inactive identifiers pose a risk to systems and applications because attackers may exploit an inactive identifier and potentially obtain undetected access to the system.\nDisabling inactive accounts ensures that accounts which may not have been responsibly removed are not available to attackers who may have compromised their credentials.\nOwners of inactive accounts will not notice if unauthorized access to their user account has been obtained.",
        "platforms": [
          "#package_shadow-utils"
        ],
        "oval_definition_id": "oval:ssg-account_disable_post_pw_expiration:def:1",
        "remediations": [
          {
            "remediation_id": "account_disable_post_pw_expiration",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'login' 2>/dev/null | grep -q installed; then\n\nvar_account_disable_post_pw_expiration='35'\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^INACTIVE\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s=%s\" \"$stripped_key\" \"$var_account_disable_post_pw_expiration\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^INACTIVE\\\\>\" \"/etc/default/useradd\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^INACTIVE\\\\>.*/$escaped_formatted_output/gi\" \"/etc/default/useradd\"\nelse\n    if [[ -s \"/etc/default/useradd\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/default/useradd\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/default/useradd\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/default/useradd\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238330",
        "stig_id": "UBTU-20-010409"
      },
      "xccdf_org.ssgproject.content_rule_account_temp_expire_date": {
        "rule_id": "xccdf_org.ssgproject.content_rule_account_temp_expire_date",
        "title": "Assign Expiration Date to Temporary Accounts",
        "result": "notchecked",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5",
              "7",
              "8"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS01.03",
              "DSS03.05",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.03"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000016",
              "CCI-001682"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(2)",
              "AC-2(3)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "PR.AC-1",
              "PR.AC-4",
              "PR.AC-6"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000002-GPOS-00002",
              "SRG-OS-000123-GPOS-00064"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010000"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238196r653763_rule"
            ]
          }
        ],
        "description": "Temporary accounts are established as part of normal account activation\nprocedures when there is a need for short-term accounts. In the event\ntemporary accounts are required, configure the system to\nterminate them after a documented time period. For every temporary account, run the following command to set an expiration date on\nit, substituting <code><i>USER</i></code> and <code><i>YYYY-MM-DD</i></code>\nappropriately:\n<pre>$ sudo chage -E <i>YYYY-MM-DD USER</i>\n         </pre>\n         <code><i>YYYY-MM-DD</i></code> indicates the documented expiration date for the\naccount. For U.S. Government systems, the operating system must be\nconfigured to automatically terminate these types of accounts after a\nperiod of 72 hours.",
        "rationale": "If temporary user accounts remain active when no longer needed or for\nan excessive period, these accounts may be used to gain unauthorized access.\nTo mitigate this risk, automated termination of all temporary accounts\nmust be set upon account creation.\n<br>\n        ",
        "messages": [
          "No candidate or applicable check found."
        ],
        "vuln_id": "SV-238196",
        "stig_id": "UBTU-20-010000"
      },
      "xccdf_org.ssgproject.content_rule_policy_temp_passwords_immediate_change": {
        "rule_id": "xccdf_org.ssgproject.content_rule_policy_temp_passwords_immediate_change",
        "title": "Policy Requires Immediate Change of Temporary Passwords",
        "result": "notchecked",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002041"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000380-GPOS-00165"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010440"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238361r853436_rule"
            ]
          }
        ],
        "description": "Temporary passwords for Ubuntu 20.04 operating system logons must\nrequire an immediate change to a permanent password.\n\nVerify that a policy exists that ensures when a user is created, it is\ncreating using a method that forces a user to change their password upon\ntheir next login.",
        "rationale": "Without providing this capability, an account may be created without a\npassword. Nonrepudiation cannot be guaranteed once an account is created if\na user is not forced to change the temporary password upon initial logon.\n\nTemporary passwords are typically used to allow access when new accounts\nare created or passwords are changed. It is common practice for\nadministrators to create temporary passwords for user accounts that allow\nthe users to log on, yet force them to change the password once they have\nsuccessfully authenticated.",
        "messages": [
          "No candidate or applicable check found."
        ],
        "vuln_id": "SV-238361",
        "stig_id": "UBTU-20-010440"
      },
      "xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs",
        "title": "Set Password Maximum Age",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.6.2.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.5.6"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000199"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0418",
              "1055",
              "1402"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(d)",
              "IA-5(f)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000076-GPOS-00044"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.4"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.9"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010008"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238203r653784_rule"
            ]
          }
        ],
        "description": "To specify password maximum age for new accounts,\nedit the file <code>/etc/login.defs</code>\nand add or correct the following line:\n<pre>PASS_MAX_DAYS 60\n         </pre>\nA value of 180 days is sufficient for many environments.\nThe DoD requirement is 60.\nThe profile requirement is <code>60</code>.",
        "rationale": "Any password, no matter how complex, can eventually be cracked. Therefore, passwords\nneed to be changed periodically. If the operating system does not limit the lifetime\nof passwords and force users to change their passwords, there is the risk that the\noperating system passwords could be compromised.\n<br>\n         <br>\nSetting the password maximum age ensures users are required to\nperiodically change their passwords. Requiring shorter password lifetimes\nincreases the risk of users writing down the password in a convenient\nlocation subject to physical compromise.",
        "platforms": [
          "#package_shadow-utils"
        ],
        "oval_definition_id": "oval:ssg-accounts_maximum_age_login_defs:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_maximum_age_login_defs",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'login' 2>/dev/null | grep -q installed; then\n\nvar_accounts_maximum_age_login_defs='60'\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^PASS_MAX_DAYS\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_maximum_age_login_defs\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^PASS_MAX_DAYS\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^PASS_MAX_DAYS\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238203",
        "stig_id": "UBTU-20-010008"
      },
      "xccdf_org.ssgproject.content_rule_accounts_minimum_age_login_defs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_minimum_age_login_defs",
        "title": "Set Password Minimum Age",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.4.1.2"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.6.2.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.5.8"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000198"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0418",
              "1055",
              "1402"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(d)",
              "IA-5(f)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000075-GPOS-00043"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010007"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238202r653781_rule"
            ]
          }
        ],
        "description": "To specify password minimum age for new accounts,\nedit the file <code>/etc/login.defs</code>\nand add or correct the following line:\n<pre>PASS_MIN_DAYS 1\n         </pre>\nA value of 1 day is considered sufficient for many\nenvironments. The DoD requirement is 1.\nThe profile requirement is <code>1</code>.",
        "rationale": "Enforcing a minimum password lifetime helps to prevent repeated password\nchanges to defeat the password reuse or history enforcement requirement. If\nusers are allowed to immediately and continually change their password,\nthen the password could be repeatedly changed in a short period of time to\ndefeat the organization&#x27;s policy regarding password reuse.\n<br>\n         <br>\nSetting the minimum password age protects against users cycling back to a\nfavorite password after satisfying the password reuse requirement.",
        "platforms": [
          "#package_shadow-utils"
        ],
        "oval_definition_id": "oval:ssg-accounts_minimum_age_login_defs:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_minimum_age_login_defs",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'login' 2>/dev/null | grep -q installed; then\n\nvar_accounts_minimum_age_login_defs='1'\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^PASS_MIN_DAYS\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_minimum_age_login_defs\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^PASS_MIN_DAYS\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^PASS_MIN_DAYS\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238202",
        "stig_id": "UBTU-20-010007"
      },
      "xccdf_org.ssgproject.content_rule_ensure_sudo_group_restricted": {
        "rule_id": "xccdf_org.ssgproject.content_rule_ensure_sudo_group_restricted",
        "title": "Ensure sudo group has only necessary members",
        "result": "notchecked",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001084"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000134-GPOS-00068"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010012"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238206r653793_rule"
            ]
          }
        ],
        "description": "Developers and implementers can increase the assurance in security\nfunctions by employing well-defined security policy models; structured,\ndisciplined, and rigorous hardware and software development techniques;\nand sound system/security engineering principles. Implementation may\ninclude isolation of memory space and libraries.\n\nThe Ubuntu operating system restricts access to security functions\nthrough the use of access control mechanisms and by implementing least\nprivilege capabilities.",
        "rationale": "Any users assigned to the sudo group would be granted administrator\naccess to the system.",
        "warnings": [
          {
            "text": "Due to the risk of removing user rights, automated remediation is\nnot available for this configuration check.",
            "category": "general"
          }
        ],
        "messages": [
          "No candidate or applicable check found."
        ],
        "vuln_id": "SV-238206",
        "stig_id": "UBTU-20-010012"
      },
      "xccdf_org.ssgproject.content_rule_no_duplicate_uids": {
        "rule_id": "xccdf_org.ssgproject.content_rule_no_duplicate_uids",
        "title": "Ensure no duplicate UIDs exist",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "6.2.13"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000764",
              "CCI-000804"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000104-GPOS-00051",
              "SRG-OS-000121-GPOS-00062"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010010"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238205r653790_rule"
            ]
          }
        ],
        "description": "Although the useradd program will not let you create a duplicate User ID (UID),\nit is possible for an administrator to manually edit the /etc/passwd file\nand change the UID field. Users must be assigned unique UIDs for\naccountability and to ensure appropriate access protections.",
        "rationale": "Users must be assigned unique UIDs for accountability and to ensure\nappropriate access protections.",
        "warnings": [
          {
            "text": "Due to the risk of removing user accounts or changing user&#x27;s UIDS,\nautomated remediation is not available for this configuration check.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-no_duplicate_uids:def:1",
        "vuln_id": "SV-238205",
        "stig_id": "UBTU-20-010010"
      },
      "xccdf_org.ssgproject.content_rule_no_empty_passwords": {
        "rule_id": "xccdf_org.ssgproject.content_rule_no_empty_passwords",
        "title": "Prevent Login to Accounts With Empty Password",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "6.2.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.2"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.02",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.1",
              "3.1.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(B)",
              "164.308(a)(7)(i)",
              "164.308(a)(7)(ii)(A)",
              "164.310(a)(1)",
              "164.310(a)(2)(i)",
              "164.310(a)(2)(ii)",
              "164.310(a)(2)(iii)",
              "164.310(b)",
              "164.310(c)",
              "164.310(d)(1)",
              "164.310(d)(2)(iii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.18.1.4",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(1)(a)",
              "IA-5(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-4",
              "PR.AC-6",
              "PR.AC-7",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FIA_UAU.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.2.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.3.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010463"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-251504r832977_rule"
            ]
          }
        ],
        "description": "If an account is configured for password authentication\nbut does not have an assigned password, it may be possible to log\ninto the account without authentication. Remove any instances of the\n<code>nullok</code> in\n\n<code>/etc/pam.d/common-password</code>\n\nto prevent logins with empty passwords.",
        "rationale": "If an account has an empty password, anyone could log in and\nrun commands with the privileges of that account. Accounts with\nempty passwords should never be used in operational environments.",
        "warnings": [
          {
            "text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nNote that this rule is not applicable for systems running within a\ncontainer. Having user with empty password within a container is not\nconsidered a risk, because it should not be possible to directly login into\na container anyway.",
            "category": "general"
          }
        ],
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-no_empty_passwords:def:1",
        "remediations": [
          {
            "remediation_id": "no_empty_passwords",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "configure",
            "fix": "- name: Prevent Login to Accounts With Empty Password - Check if system relies on\n    authselect\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.5.2\n  - DISA-STIG-UBTU-20-010463\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.1\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n\n- name: Prevent Login to Accounts With Empty Password - Remediate using authselect\n  block:\n\n  - name: Prevent Login to Accounts With Empty Password - Check integrity of authselect\n      current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    failed_when: false\n\n  - name: Prevent Login to Accounts With Empty Password - Informative message based\n      on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd.rc == 0\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Prevent Login to Accounts With Empty Password - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Prevent Login to Accounts With Empty Password - Ensure \"without-nullok\"\n      feature is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature without-nullok\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"without-nullok\")\n\n  - name: Prevent Login to Accounts With Empty Password - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.2\n  - DISA-STIG-UBTU-20-010463\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.1\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n\n- name: Prevent Login to Accounts With Empty Password - Remediate directly editing\n    PAM files\n  ansible.builtin.replace:\n    dest: '{{ item }}'\n    regexp: nullok\n  loop:\n  - /etc/pam.d/common-password\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not result_authselect_present.stat.exists\n  tags:\n  - CJIS-5.5.2\n  - DISA-STIG-UBTU-20-010463\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - PCI-DSSv4-8.3.1\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "no_empty_passwords",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "configure",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nFILE=\"/etc/pam.d/common-password\"\nsed -i 's/\\(.*pam_unix\\.so.*\\)\\s\\<nullok\\>\\(.*\\)/\\1\\2/g' ${FILE}\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-251504",
        "stig_id": "UBTU-20-010463"
      },
      "xccdf_org.ssgproject.content_rule_no_empty_passwords_etc_shadow": {
        "rule_id": "xccdf_org.ssgproject.content_rule_no_empty_passwords_etc_shadow",
        "title": "Ensure There Are No Accounts With Blank or Null Passwords",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(b)",
              "CM-6.1(iv)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010462"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-251503r808506_rule"
            ]
          }
        ],
        "description": "Check the &quot;/etc/shadow&quot; file for blank passwords with the\nfollowing command:\n<pre>$ sudo awk -F: &#x27;!$2 {print $1}&#x27; /etc/shadow</pre>\nIf the command returns any results, this is a finding.\nConfigure all accounts on the system to have a password or lock\nthe account with the following commands:\nPerform a password reset:\n<pre>$ sudo passwd [username]</pre>\nLock an account:\n<pre>$ sudo passwd -l [username]</pre>\n        ",
        "rationale": "If an account has an empty password, anyone could log in and\nrun commands with the privileges of that account. Accounts with\nempty passwords should never be used in operational environments.",
        "warnings": [
          {
            "text": "Note that this rule is not applicable for systems running within a container. Having user with empty password within a container is not considered a risk, because it should not be possible to directly login into a container anyway.",
            "category": "general"
          }
        ],
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-no_empty_passwords_etc_shadow:def:1",
        "remediations": [
          {
            "remediation_id": "no_empty_passwords_etc_shadow",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Collect users with no password\n  command: |\n    awk -F: '!$2 {print $1}' /etc/shadow\n  register: users_nopasswd\n  changed_when: false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010462\n  - NIST-800-53-CM-6(b)\n  - NIST-800-53-CM-6.1(iv)\n  - PCI-DSSv4-2.2.2\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_empty_passwords_etc_shadow\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock users with no password\n  command: |\n    passwd -l {{ item }}\n  with_items: '{{ users_nopasswd.stdout_lines }}'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - users_nopasswd is not skipped and users_nopasswd.stdout_lines | length > 0\n  tags:\n  - DISA-STIG-UBTU-20-010462\n  - NIST-800-53-CM-6(b)\n  - NIST-800-53-CM-6.1(iv)\n  - PCI-DSSv4-2.2.2\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_empty_passwords_etc_shadow\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "no_empty_passwords_etc_shadow",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nreadarray -t users_with_empty_pass < <(sudo awk -F: '!$2 {print $1}' /etc/shadow)\n\nfor user_with_empty_pass in \"${users_with_empty_pass[@]}\"\ndo\n    passwd -l $user_with_empty_pass\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-251503",
        "stig_id": "UBTU-20-010462"
      },
      "xccdf_org.ssgproject.content_rule_prevent_direct_root_logins": {
        "rule_id": "xccdf_org.ssgproject.content_rule_prevent_direct_root_logins",
        "title": "Direct root Logins Are Not Allowed",
        "result": "notchecked",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000770"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000109-GPOS-00056"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010408"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238329r654162_rule"
            ]
          }
        ],
        "description": "Configure the operating system to prevent direct logins to the\n<code>root</code> account by performing the following operations:\n<pre>$ sudo passwd -l root</pre>\n        ",
        "rationale": "Disabling direct root logins ensures proper accountability and\nmultifactor authentication to privileged accounts.",
        "messages": [
          "No candidate or applicable check found."
        ],
        "vuln_id": "SV-238329",
        "stig_id": "UBTU-20-010408"
      },
      "xccdf_org.ssgproject.content_rule_accounts_max_concurrent_login_sessions": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_max_concurrent_login_sessions",
        "title": "Limit the Number of Concurrent Login Sessions Allowed Per User",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "low",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "14",
              "15",
              "18",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.2.2"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS01.05",
              "DSS05.02"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000054"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.1",
              "SR 3.8"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.14.1.2",
              "A.14.1.3"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-10",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000027-GPOS-00008"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010400"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238323r877399_rule"
            ]
          }
        ],
        "description": "Limiting the number of allowed users and sessions per user can limit risks related to Denial of\nService attacks. This addresses concurrent sessions for a single account and does not address\nconcurrent sessions by a single user via multiple accounts. To set the number of concurrent\nsessions per user add the following line in <code>/etc/security/limits.conf</code> or\na file under <code>/etc/security/limits.d/</code>:\n<pre>* hard maxlogins 10\n        </pre>\n       ",
        "rationale": "Limiting simultaneous user logins can insulate the system from denial of service\nproblems caused by excessive logins. Automated login processes operating improperly or\nmaliciously may result in an exceptional number of simultaneous login sessions.",
        "platforms": [
          "#package_pam"
        ],
        "oval_definition_id": "oval:ssg-accounts_max_concurrent_login_sessions:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_max_concurrent_login_sessions",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'libpam-runtime' 2>/dev/null | grep -q installed; then\n\nvar_accounts_max_concurrent_login_sessions='10'\n\n\nif grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.d/*.conf; then\n\tsed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.d/*.conf\nelif grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.conf; then\n\tsed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.conf\nelse\n\techo \"*\thard\tmaxlogins\t$var_accounts_max_concurrent_login_sessions\" >> /etc/security/limits.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238323",
        "stig_id": "UBTU-20-010400"
      },
      "xccdf_org.ssgproject.content_rule_accounts_tmout": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_tmout",
        "title": "Set Interactive Session Timeout",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R32"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.4.5"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.11"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000057",
              "CCI-001133",
              "CCI-002361"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.2",
              "CIP-007-3 R5.3.1",
              "CIP-007-3 R5.3.2",
              "CIP-007-3 R5.3.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-12",
              "AC-2(5)",
              "CM-6(a)",
              "SC-10"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000029-GPOS-00010",
              "SRG-OS-000163-GPOS-00072"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_MOF_EXT.1"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.6.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010013"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238207r853404_rule"
            ]
          }
        ],
        "description": "Setting the <code>TMOUT</code> option in <code>/etc/profile</code> ensures that\nall user sessions will terminate based on inactivity.\nThe value of TMOUT should be exported and read only.\nThe <code>TMOUT</code>\n\nsetting in a file loaded by <code>/etc/profile</code>, e.g.\n<code>/etc/profile.d/tmout.sh</code> should read as follows:\n<pre>TMOUT=600\n        </pre>\nreadonly TMOUT\nexport TMOUT",
        "rationale": "Terminating an idle session within a short time period reduces\nthe window of opportunity for unauthorized personnel to take control of a\nmanagement session enabled on the console or console port that has been\nleft unattended.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-accounts_tmout:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_tmout",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: XCCDF Value var_accounts_tmout # promote to variable\n  set_fact:\n    var_accounts_tmout: !!str 600\n  tags:\n    - always\n\n- name: Correct any occurrence of TMOUT in /etc/profile\n  replace:\n    path: /etc/profile\n    regexp: ^[^#].*TMOUT=.*\n    replace: typeset -xr TMOUT={{ var_accounts_tmout }}\n  register: profile_replaced\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010013\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSSv4-8.6.1\n  - accounts_tmout\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Interactive Session Timeout\n  lineinfile:\n    path: /etc/profile.d/tmout.sh\n    create: true\n    regexp: TMOUT=\n    line: typeset -xr TMOUT={{ var_accounts_tmout }}\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010013\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSSv4-8.6.1\n  - accounts_tmout\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_tmout",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nvar_accounts_tmout='600'\n\n\n# if 0, no occurence of tmout found, if 1, occurence found\ntmout_found=0\n\nfor f in /etc/bash.bashrc /etc/profile /etc/profile.d/*.sh; do\n    if grep --silent '^\\s*TMOUT' $f; then\n        sed -i -E \"s/^(\\s*)TMOUT\\s*=\\s*(\\w|\\$)*(.*)$/\\1TMOUT=$var_accounts_tmout\\3/g\" $f\n        tmout_found=1\n        if ! grep --silent '^\\s*readonly TMOUT' $f ; then\n            echo \"readonly TMOUT\" >> $f\n        fi\n        if ! grep --silent '^\\s*export TMOUT' $f ; then\n            echo \"export TMOUT\" >> $f\n        fi\n    fi\ndone\n\nif [ $tmout_found -eq 0 ]; then\n        echo -e \"\\n# Set TMOUT to $var_accounts_tmout per security requirements\" >> /etc/profile.d/tmout.sh\n        echo \"TMOUT=$var_accounts_tmout\" >> /etc/profile.d/tmout.sh\n        echo \"readonly TMOUT\" >> /etc/profile.d/tmout.sh\n        echo \"export TMOUT\" >> /etc/profile.d/tmout.sh\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238207",
        "stig_id": "UBTU-20-010013"
      },
      "xccdf_org.ssgproject.content_rule_accounts_umask_etc_login_defs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_login_defs",
        "title": "Ensure the Default Umask is Set Correctly in login.defs",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R36"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.4.4"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "18",
              "3",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "BAI03.01",
              "BAI03.02",
              "BAI03.03",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.14.1.1",
              "A.14.2.1",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.14.2.5",
              "A.6.1.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.IP-1",
              "PR.IP-2"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00228"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010016"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238209r653802_rule"
            ]
          }
        ],
        "description": "To ensure the default umask controlled by <code>/etc/login.defs</code> is set properly,\nadd or correct the <code>UMASK</code> setting in <code>/etc/login.defs</code> to read as follows:\n<pre>UMASK 077\n         </pre>\n        ",
        "rationale": "The umask value influences the permissions assigned to files when they are created.\nA misconfigured umask value could result in files with excessive permissions that can be read and\nwritten to by unauthorized users.",
        "platforms": [
          "#package_shadow-utils"
        ],
        "oval_definition_id": "oval:ssg-accounts_umask_etc_login_defs:def:1",
        "remediations": [
          {
            "remediation_id": "accounts_umask_etc_login_defs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010016\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_user_umask # promote to variable\n  set_fact:\n    var_accounts_user_umask: !!str 077\n  tags:\n    - always\n\n- name: Check if UMASK is already set\n  ansible.builtin.lineinfile:\n    path: /etc/login.defs\n    regexp: ^(\\s*)UMASK\\s+.*\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: result_umask_is_set\n  when: '\"login\" in ansible_facts.packages'\n  tags:\n  - DISA-STIG-UBTU-20-010016\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Replace user UMASK in /etc/login.defs\n  ansible.builtin.replace:\n    path: /etc/login.defs\n    regexp: ^(\\s*)UMASK(\\s+).*\n    replace: \\g<1>UMASK\\g<2>{{ var_accounts_user_umask }}\n  when:\n  - '\"login\" in ansible_facts.packages'\n  - result_umask_is_set.found > 0\n  tags:\n  - DISA-STIG-UBTU-20-010016\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Ensure the Default UMASK is Appended Correctly\n  ansible.builtin.lineinfile:\n    create: true\n    path: /etc/login.defs\n    line: UMASK {{ var_accounts_user_umask }}\n  when:\n  - '\"login\" in ansible_facts.packages'\n  - result_umask_is_set.found == 0\n  tags:\n  - DISA-STIG-UBTU-20-010016\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - accounts_umask_etc_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "accounts_umask_etc_login_defs",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'login' 2>/dev/null | grep -q installed; then\n\nvar_accounts_user_umask='077'\n\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^UMASK\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_user_umask\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^UMASK\\\\>\" \"/etc/login.defs\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^UMASK\\\\>.*/$escaped_formatted_output/gi\" \"/etc/login.defs\"\nelse\n    if [[ -s \"/etc/login.defs\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/login.defs\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/login.defs\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/login.defs\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238209",
        "stig_id": "UBTU-20-010016"
      },
      "xccdf_org.ssgproject.content_rule_package_apparmor_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_apparmor_installed",
        "title": "Ensure AppArmor is installed",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R45"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.7.1.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001764",
              "CCI-001774",
              "CCI-002165",
              "CCI-002235"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000312-GPOS-00122",
              "SRG-OS-000312-GPOS-00123",
              "SRG-OS-000312-GPOS-00124",
              "SRG-OS-000324-GPOS-00125",
              "SRG-OS-000368-GPOS-00154",
              "SRG-OS-000370-GPOS-00155"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010439"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238360r853435_rule"
            ]
          }
        ],
        "description": "AppArmor provide Mandatory Access Controls.",
        "rationale": "Without a Mandatory Access Control system installed only the default\nDiscretionary Access Control system will be available.",
        "oval_definition_id": "oval:ssg-package_apparmor_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_apparmor_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure apparmor is installed\n  package:\n    name: apparmor\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010439\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_apparmor_installed\n"
          },
          {
            "remediation_id": "package_apparmor_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_apparmor\n\nclass install_apparmor {\n  package { 'apparmor':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_apparmor_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"apparmor\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_apparmor_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"apparmor\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238360",
        "stig_id": "UBTU-20-010439"
      },
      "xccdf_org.ssgproject.content_rule_apparmor_configured": {
        "rule_id": "xccdf_org.ssgproject.content_rule_apparmor_configured",
        "title": "Ensure AppArmor is Active and Configured",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R45"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001764",
              "CCI-001774",
              "CCI-002165",
              "CCI-002233",
              "CCI-002235"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-3(4)",
              "AC-6(10)",
              "AC-6(8)",
              "CM-6(a)",
              "CM-7(2)",
              "CM-7(5)(b)",
              "SC-7(21)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000312-GPOS-00122",
              "SRG-OS-000312-GPOS-00123",
              "SRG-OS-000312-GPOS-00124",
              "SRG-OS-000324-GPOS-00125",
              "SRG-OS-000326-GPOS-00126",
              "SRG-OS-000370-GPOS-00155",
              "SRG-OS-000480-GPOS-00227",
              "SRG-OS-000480-GPOS-00230",
              "SRG-OS-000480-GPOS-00231",
              "SRG-OS-000480-GPOS-00232"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010439"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238360r853435_rule"
            ]
          }
        ],
        "description": "Verify that the Apparmor tool is configured to\ncontrol whitelisted applications and user home directory access\ncontrol.<br>\n       <br>\n\nThe <code>apparmor</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable apparmor.service</pre>\n      ",
        "rationale": "Using a whitelist provides a configuration management method for allowing\nthe execution of only authorized software. Using only authorized software\ndecreases risk by limiting the number of potential vulnerabilities.<br>\n       <br>\n\nThe organization must identify authorized software programs and permit\nexecution of authorized software by adding each authorized program to the\n&quot;pam_apparmor&quot; exception policy. The process used to identify software\nprograms that are authorized to execute on organizational information\nsystems is commonly referred to as whitelisting.<br>\n       <br>\n\nVerification of whitelisted software occurs prior to execution or at system\nstartup.<br>\n       <br>\n\nUsers&#x27; home directories/folders may contain information of a sensitive\nnature. Nonprivileged users should coordinate any sharing of information\nwith a System Administrator (SA) through shared resources.<br>\n       <br>\n\nApparmor can confine users to their home directory, not allowing them to\nmake any changes outside of their own home directories. Confining users to\ntheir home directory will minimize the risk of sharing information.",
        "oval_definition_id": "oval:ssg-apparmor_configured:def:1",
        "remediations": [
          {
            "remediation_id": "apparmor_configured",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include enable_apparmor\n\nclass enable_apparmor {\n  service {'apparmor':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
          },
          {
            "remediation_id": "apparmor_configured",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[customizations.services]\nenabled = [\"apparmor\"]\n"
          },
          {
            "remediation_id": "apparmor_configured",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\n# Enable apparmor\n/usr/bin/systemctl enable \"apparmor\"\n/usr/bin/systemctl start \"apparmor\"\n# The service may not be running because it has been started and failed,\n# so let's reset the state so OVAL checks pass.\n# Service should be 'inactive', not 'failed' after reboot though.\nif /usr/bin/systemctl --failed | grep -q \"apparmor\"; then\n    /usr/bin/systemctl reset-failed \"apparmor\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238360",
        "stig_id": "UBTU-20-010439"
      },
      "xccdf_org.ssgproject.content_rule_grub2_password": {
        "rule_id": "xccdf_org.ssgproject.content_rule_grub2_password",
        "title": "Set Boot Loader Password in grub2",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R5"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.5.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.06",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.4.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000213"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(B)",
              "164.308(a)(7)(i)",
              "164.308(a)(7)(ii)(A)",
              "164.310(a)(1)",
              "164.310(a)(2)(i)",
              "164.310(a)(2)(ii)",
              "164.310(a)(2)(iii)",
              "164.310(b)",
              "164.310(c)",
              "164.310(d)(1)",
              "164.310(d)(2)(iii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.3",
              "4.3.3.5.4",
              "4.3.3.5.5",
              "4.3.3.5.6",
              "4.3.3.5.7",
              "4.3.3.5.8",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.1",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.11",
              "SR 1.12",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.6",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.2",
              "SR 2.3",
              "SR 2.4",
              "SR 2.5",
              "SR 2.6",
              "SR 2.7"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.6.1.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-4",
              "PR.AC-6",
              "PR.AC-7",
              "PR.PT-3"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000080-GPOS-00048"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FIA_UAU.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010009"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238204r832936_rule"
            ]
          }
        ],
        "description": "The grub2 boot loader should have a superuser account and password\nprotection enabled to protect boot-time settings.\n<br>\n        <br>\nSince plaintext passwords are a security risk, generate a hash for the password\nby running the following command:\n\n<pre># grub2-mkpasswd-pbkdf2</pre>\n\nWhen prompted, enter the password that was selected.\n<br>\n        <br>\n\nUsing the hash from the output, modify the <code>/etc/grub.d/40_custom</code>\nfile with the following content:\n<pre>set superusers=&quot;boot&quot;\npassword_pbkdf2 boot grub.pbkdf2.sha512.VeryLongString\n</pre>\nNOTE: the bootloader superuser account and password MUST differ from the\nroot account and password.\nOnce the superuser password has been added,\nupdate the\n<code>grub.cfg</code> file by running:\n<pre>update-grub </pre>\n       ",
        "rationale": "Password protection on the boot loader configuration ensures\nusers with physical access cannot trivially alter\nimportant bootloader settings. These include which kernel to use,\nand whether to enter single-user mode.",
        "warnings": [
          {
            "text": "To prevent hard-coded passwords, automatic remediation of this control is not available. Remediation\nmust be automated as a component of machine provisioning, or followed manually as outlined above.\n\nAlso, do NOT manually add the superuser account and password to the\n<code>grub.cfg</code> file as the grub2-mkconfig command overwrites this file.",
            "category": "general"
          }
        ],
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-grub2_password:def:1",
        "vuln_id": "SV-238204",
        "stig_id": "UBTU-20-010009"
      },
      "xccdf_org.ssgproject.content_rule_grub2_uefi_password": {
        "rule_id": "xccdf_org.ssgproject.content_rule_grub2_uefi_password",
        "title": "Set the UEFI Boot Loader Password",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R5"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.5.1"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "12",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.03",
              "DSS06.06"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.4.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000213"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(B)",
              "164.308(a)(7)(i)",
              "164.308(a)(7)(ii)(A)",
              "164.310(a)(1)",
              "164.310(a)(2)(i)",
              "164.310(a)(2)(ii)",
              "164.310(a)(2)(iii)",
              "164.310(b)",
              "164.310(c)",
              "164.310(d)(1)",
              "164.310(d)(2)(iii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.3",
              "4.3.3.5.4",
              "4.3.3.5.5",
              "4.3.3.5.6",
              "4.3.3.5.7",
              "4.3.3.5.8",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.1",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.11",
              "SR 1.12",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.6",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.2",
              "SR 2.3",
              "SR 2.4",
              "SR 2.5",
              "SR 2.6",
              "SR 2.7"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.6.1.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.AC-6",
              "PR.PT-3"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000080-GPOS-00048"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FIA_UAU.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010009"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238204r832936_rule"
            ]
          }
        ],
        "description": "The grub2 boot loader should have a superuser account and password\nprotection enabled to protect boot-time settings.\n<br>\n        <br>\nSince plaintext passwords are a security risk, generate a hash for the password\nby running the following command:\n\n<pre># grub2-mkpasswd-pbkdf2</pre>\n\nWhen prompted, enter the password that was selected.\n<br>\n        <br>\n\nUsing the hash from the output, modify the <code>/etc/grub.d/40_custom</code>\nfile with the following content:\n<pre>set superusers=&quot;boot&quot;\npassword_pbkdf2 boot grub.pbkdf2.sha512.VeryLongString\n</pre>\nNOTE: the bootloader superuser account and password MUST differ from the\nroot account and password.\nOnce the superuser password has been added,\nupdate the\n<code>grub.cfg</code> file by running:\n<pre>update-grub </pre>\n       ",
        "rationale": "Password protection on the boot loader configuration ensures\nusers with physical access cannot trivially alter\nimportant bootloader settings. These include which kernel to use,\nand whether to enter single-user mode.",
        "warnings": [
          {
            "text": "To prevent hard-coded passwords, automatic remediation of this control is not available. Remediation\nmust be automated as a component of machine provisioning, or followed manually as outlined above.\n\nAlso, do NOT manually add the superuser account and password to the\n<code>grub.cfg</code> file as the grub2-mkconfig command overwrites this file.",
            "category": "general"
          }
        ],
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-grub2_uefi_password:def:1",
        "vuln_id": "SV-238204",
        "stig_id": "UBTU-20-010009"
      },
      "xccdf_org.ssgproject.content_rule_service_rsyslog_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_service_rsyslog_enabled",
        "title": "Enable rsyslog Service",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.2.1.2"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO13.01",
              "BAI03.05",
              "BAI04.04",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366",
              "CCI-001311",
              "CCI-001312",
              "CCI-001557",
              "CCI-001851"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.312(a)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.3",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.17.2.1"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-4(1)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.DS-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010432"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238353r654234_rule"
            ]
          }
        ],
        "description": "The <code>rsyslog</code> service provides syslog-style logging by default on Ubuntu 20.04.\n\nThe <code>rsyslog</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable rsyslog.service</pre>\n      ",
        "rationale": "The <code>rsyslog</code> service must be running in order to provide\nlogging services, which are essential to system administration.",
        "oval_definition_id": "oval:ssg-service_rsyslog_enabled:def:1",
        "remediations": [
          {
            "remediation_id": "service_rsyslog_enabled",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Enable rsyslog Service - Enable service rsyslog\n  block:\n\n  - name: Gather the package facts\n    package_facts:\n      manager: auto\n\n  - name: Enable rsyslog Service - Enable Service rsyslog\n    ansible.builtin.systemd:\n      name: rsyslog\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"rsyslog\" in ansible_facts.packages'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010432\n  - NIST-800-53-AU-4(1)\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_rsyslog_enabled\n"
          },
          {
            "remediation_id": "service_rsyslog_enabled",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include enable_rsyslog\n\nclass enable_rsyslog {\n  service {'rsyslog':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
          },
          {
            "remediation_id": "service_rsyslog_enabled",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[customizations.services]\nenabled = [\"rsyslog\"]\n"
          },
          {
            "remediation_id": "service_rsyslog_enabled",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'rsyslog.service'\n\"$SYSTEMCTL_EXEC\" start 'rsyslog.service'\n\"$SYSTEMCTL_EXEC\" enable 'rsyslog.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238353",
        "stig_id": "UBTU-20-010432"
      },
      "xccdf_org.ssgproject.content_rule_ensure_rtc_utc_configuration": {
        "rule_id": "xccdf_org.ssgproject.content_rule_ensure_rtc_utc_configuration",
        "title": "Ensure real-time clock is set to UTC",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001890"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000359-GPOS-00146"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010230"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238308r877383_rule"
            ]
          }
        ],
        "description": "Ensure that the system real-time clock (RTC) is set to Coordinated Universal Time (UTC).",
        "rationale": "If time stamps are not consistently applied and there is no common\ntime reference, it is difficult to perform forensic analysis.\n\nTime stamps generated by the operating system include date and time.\nTime is commonly expressed in UTC, a modern continuation of GMT, or\nlocal time with an offset from UTC.",
        "oval_definition_id": "oval:ssg-ensure_rtc_utc_configuration:def:1",
        "remediations": [
          {
            "remediation_id": "ensure_rtc_utc_configuration",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif timedatectl status | grep -i \"time zone\" | grep -iv 'UTC\\|GMT'; then\n    timedatectl set-timezone UTC\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238308",
        "stig_id": "UBTU-20-010230"
      },
      "xccdf_org.ssgproject.content_rule_rsyslog_remote_access_monitoring": {
        "rule_id": "xccdf_org.ssgproject.content_rule_rsyslog_remote_access_monitoring",
        "title": "Ensure remote access methods are monitored in Rsyslog",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000067"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-17(1)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000032-GPOS-00013"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010403"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238324r832959_rule"
            ]
          }
        ],
        "description": "Logging of remote access methods must be implemented to help identify cyber\nattacks and ensure ongoing compliance with remote access policies are being\naudited and upheld. An examples of a remote access method is the use of the\nRemote Desktop Protocol (RDP) from an external, non-organization controlled\nnetwork. The <code>/etc/rsyslog.conf</code> or\n<code>/etc/rsyslog.d/*.conf</code> file should contain a match for the following\nselectors: <code>auth.*</code>, <code>authpriv.*</code>, and <code>daemon.*</code>. If\nnot, use the following as an example configuration:\n<pre>auth.*;authpriv.*;daemon.*                              /var/log/secure</pre>\n       ",
        "rationale": "Logging remote access methods can be used to trace the decrease the risks\nassociated with remote user access management. It can also be used to spot\ncyber attacks and ensure ongoing compliance with organizational policies\nsurrounding the use of remote access methods.",
        "oval_definition_id": "oval:ssg-rsyslog_remote_access_monitoring:def:1",
        "remediations": [
          {
            "remediation_id": "rsyslog_remote_access_monitoring",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "configure",
            "fix": "- name: Ensure remote access methods are monitored in Rsyslog - Set Facts\n  ansible.builtin.set_fact:\n    conf_files:\n    - /etc/rsyslog.d/50-default.conf\n    remote_methods:\n    - selector: auth.*\n      regexp: ^.*auth\\.\\*.*$\n      log_path_name: secure\n    - selector: authpriv.*\n      regexp: ^.*authpriv\\.\\*.*$\n      log_path_name: secure\n    - selector: daemon.*\n      regexp: ^.*daemon\\.\\*.*$\n      log_path_name: messages\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010403\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n\n- name: Ensure remote access methods are monitored in Rsyslog - Ensure /etc/rsyslog.d/50-default.conf\n    Exists\n  ansible.builtin.file:\n    path: '{{ conf_files.0 }}'\n    state: touch\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010403\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n\n- name: Ensure remote access methods are monitored in Rsyslog - Check for Existing\n    Values in Conf Files\n  ansible.builtin.lineinfile:\n    path: '{{ item.1 }}'\n    regexp: '{{ item.0.regexp }}'\n    state: absent\n  check_mode: true\n  changed_when: false\n  register: remote_method_values\n  loop: '{{ remote_methods|product(conf_files)|list }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010403\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n\n- name: Ensure remote access methods are monitored in Rsyslog - Configure /etc/rsyslog.d/50-default.conf\n    With Proper Log Paths\n  ansible.builtin.lineinfile:\n    path: /etc/rsyslog.d/50-default.conf\n    line: '{{ item.item.0.selector }} /var/log/{{ item.item.0.log_path_name }}'\n    insertafter: ^.*\\/var\\/log\\/secure.*$\n    create: true\n  loop: '{{ remote_method_values.results }}'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - item.found == 0\n  tags:\n  - DISA-STIG-UBTU-20-010403\n  - NIST-800-53-AC-17(1)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_remote_access_monitoring\n"
          },
          {
            "remediation_id": "rsyslog_remote_access_monitoring",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif [ ! -f /etc/rsyslog.d/50-default.conf ]; then\n    # Something is not right, create the file\n    touch /etc/rsyslog.d/50-default.conf\nfi\n\n# Check to see if auth exists\nif ! grep -Erq \"^auth\\.\\*,authpriv\\.\\*\" /etc/rsyslog.*; then\n    echo \"auth.*,authpriv.* /var/log/secure\" >> /etc/rsyslog.d/50-default.conf\nfi\n\nif ! grep -Erq \"^daemon\\.\\*\" /etc/rsyslog.*; then\n    echo \"daemon.* /var/log/messages\" >> /etc/rsyslog.d/50-default.conf\nfi\n\nsystemctl restart rsyslog.service\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238324",
        "stig_id": "UBTU-20-010403"
      },
      "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_tcp_syncookies": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_tcp_syncookies",
        "title": "Enable Kernel Parameter to Use TCP Syncookies on Network Interfaces",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R12"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "3.3.8"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "2",
              "4",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.10.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "APO13.01",
              "BAI04.04",
              "DSS01.03",
              "DSS01.05",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.20"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366",
              "CCI-001095"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.4",
              "4.3.3.4",
              "4.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.2",
              "SR 7.1",
              "SR 7.2",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.12.1.1",
              "A.12.1.2",
              "A.12.1.3",
              "A.13.1.1",
              "A.13.1.2",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.2",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.17.2.1",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)",
              "SC-5(1)",
              "SC-5(2)",
              "SC-5(3)(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-1",
              "DE.CM-1",
              "ID.AM-3",
              "PR.AC-5",
              "PR.DS-4",
              "PR.DS-5",
              "PR.PT-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000142-GPOS-00071",
              "SRG-OS-000420-GPOS-00186",
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-1.4.1"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "1.4.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010412"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238333r654174_rule"
            ]
          }
        ],
        "description": "To set the runtime status of the <code>net.ipv4.tcp_syncookies</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w net.ipv4.tcp_syncookies=1</pre>\nTo make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>net.ipv4.tcp_syncookies = 1</pre>\n        ",
        "rationale": "A TCP SYN flood attack can cause a denial of service by filling a\nsystem&#x27;s TCP connection table with connections in the SYN_RCVD state.\nSyncookies can be used to track a connection when a subsequent ACK is received,\nverifying the initiator is attempting a valid connection and is not a flood\nsource. This feature is activated when a flood condition is detected, and\nenables the system to continue servicing valid connection requests.",
        "oval_definition_id": "oval:ssg-sysctl_net_ipv4_tcp_syncookies:def:1",
        "remediations": [
          {
            "remediation_id": "sysctl_net_ipv4_tcp_syncookies",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "- name: List /etc/sysctl.d/*.conf files\n  find:\n    paths:\n    - /etc/sysctl.d/\n    - /run/sysctl.d/\n    - /usr/local/lib/sysctl.d/\n    contains: ^[\\s]*net.ipv4.tcp_syncookies.*$\n    patterns: '*.conf'\n    file_type: any\n  register: find_sysctl_d\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-20-010412\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n\n- name: Comment out any occurrences of net.ipv4.tcp_syncookies from config files\n  replace:\n    path: '{{ item.path }}'\n    regexp: ^[\\s]*net.ipv4.tcp_syncookies\n    replace: '#net.ipv4.tcp_syncookies'\n  loop: '{{ find_sysctl_d.files }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-20-010412\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n- name: XCCDF Value sysctl_net_ipv4_tcp_syncookies_value # promote to variable\n  set_fact:\n    sysctl_net_ipv4_tcp_syncookies_value: !!str 1\n  tags:\n    - always\n\n- name: Ensure sysctl net.ipv4.tcp_syncookies is set\n  sysctl:\n    name: net.ipv4.tcp_syncookies\n    value: '{{ sysctl_net_ipv4_tcp_syncookies_value }}'\n    sysctl_file: /etc/sysctl.conf\n    state: present\n    reload: true\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.10.1.1\n  - DISA-STIG-UBTU-20-010412\n  - NIST-800-171-3.1.20\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-SC-5(1)\n  - NIST-800-53-SC-5(2)\n  - NIST-800-53-SC-5(3)(a)\n  - PCI-DSS-Req-1.4.1\n  - PCI-DSSv4-1.4.3\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_net_ipv4_tcp_syncookies\n"
          },
          {
            "remediation_id": "sysctl_net_ipv4_tcp_syncookies",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\n# Comment out any occurrences of net.ipv4.tcp_syncookies from /etc/sysctl.d/*.conf files\n\nfor f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do\n\n\n  # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf)\n  if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi\n\n  matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.tcp_syncookies.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\")\n      # comment out \"net.ipv4.tcp_syncookies\" matches to preserve user data\n      sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n  fi\ndone\n\n#\n# Set sysctl config file which to save the desired value\n#\n\nSYSCONFIG_FILE=\"/etc/sysctl.conf\"\n\nsysctl_net_ipv4_tcp_syncookies_value='1'\n\n\n#\n# Set runtime for net.ipv4.tcp_syncookies\n#\n/sbin/sysctl -q -n -w net.ipv4.tcp_syncookies=\"$sysctl_net_ipv4_tcp_syncookies_value\"\n\n#\n# If net.ipv4.tcp_syncookies present in /etc/sysctl.conf, change value to appropriate value\n#\telse, add \"net.ipv4.tcp_syncookies = value\" to /etc/sysctl.conf\n#\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^net.ipv4.tcp_syncookies\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_tcp_syncookies_value\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.tcp_syncookies\\\\>\" \"${SYSCONFIG_FILE}\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^net.ipv4.tcp_syncookies\\\\>.*/$escaped_formatted_output/gi\" \"${SYSCONFIG_FILE}\"\nelse\n    if [[ -s \"${SYSCONFIG_FILE}\" ]] && [[ -n \"$(tail -c 1 -- \"${SYSCONFIG_FILE}\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"${SYSCONFIG_FILE}\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"${SYSCONFIG_FILE}\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238333",
        "stig_id": "UBTU-20-010412"
      },
      "xccdf_org.ssgproject.content_rule_package_ufw_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_ufw_installed",
        "title": "Install ufw Package",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "3.5.1.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000297-GPOS-00115"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010433"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238354r853429_rule"
            ]
          }
        ],
        "description": "The <code>ufw</code> package can be installed with the following command:\n<pre>\n$ apt-get install ufw</pre>\n       ",
        "rationale": "<code>ufw</code> controls the Linux kernel network packet filtering\ncode. <code>ufw</code> allows system operators to set up firewalls and IP\nmasquerading, etc.",
        "oval_definition_id": "oval:ssg-package_ufw_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_ufw_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure ufw is installed\n  package:\n    name: ufw\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010433\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_ufw_installed\n"
          },
          {
            "remediation_id": "package_ufw_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_ufw\n\nclass install_ufw {\n  package { 'ufw':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_ufw_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"ufw\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_ufw_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"ufw\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238354",
        "stig_id": "UBTU-20-010433"
      },
      "xccdf_org.ssgproject.content_rule_service_ufw_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_service_ufw_enabled",
        "title": "Verify ufw Enabled",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "3.5.1.3"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000297-GPOS-00115"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010434"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238355r853430_rule"
            ]
          }
        ],
        "description": "\nThe <code>ufw</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable ufw.service</pre>\n       ",
        "rationale": "The ufw service must be enabled and running in order for ufw to protect the system",
        "platforms": [
          "#machine_and_package_ufw"
        ],
        "oval_definition_id": "oval:ssg-service_ufw_enabled:def:1",
        "remediations": [
          {
            "remediation_id": "service_ufw_enabled",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010434\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_ufw_enabled\n\n- name: Verify ufw Enabled - Enable service ufw\n  block:\n\n  - name: Gather the package facts\n    package_facts:\n      manager: auto\n\n  - name: Verify ufw Enabled - Enable Service ufw\n    ansible.builtin.systemd:\n      name: ufw\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"ufw\" in ansible_facts.packages'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n    and \"ufw\" in ansible_facts.packages )\n  tags:\n  - DISA-STIG-UBTU-20-010434\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_ufw_enabled\n"
          },
          {
            "remediation_id": "service_ufw_enabled",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include enable_ufw\n\nclass enable_ufw {\n  service {'ufw':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
          },
          {
            "remediation_id": "service_ufw_enabled",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[customizations.services]\nenabled = [\"ufw\"]\n"
          },
          {
            "remediation_id": "service_ufw_enabled",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { ( [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'ufw' 2>/dev/null | grep -q installed ); }; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'ufw.service'\n\"$SYSTEMCTL_EXEC\" start 'ufw.service'\n\"$SYSTEMCTL_EXEC\" enable 'ufw.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238355",
        "stig_id": "UBTU-20-010434"
      },
      "xccdf_org.ssgproject.content_rule_check_ufw_active": {
        "rule_id": "xccdf_org.ssgproject.content_rule_check_ufw_active",
        "title": "Verify ufw Active",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "3.5.1.3"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002314"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010434"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238355r853430_rule"
            ]
          }
        ],
        "description": "Verify the ufw is enabled on the system with the following command:\n<pre># sudo ufw status</pre>\nIf the above command returns the status as &quot;inactive&quot; or any type of error, this is a finding.",
        "rationale": "Remote access services, such as those providing remote access to network devices and information systems, \nwhich lack automated control capabilities, increase risk and make remote user access management difficult at best.  \nRemote access is access to DOD nonpublic information systems by an authorized user (or an information system) communicating \nthrough an external, nonorganization-controlled network. Remote access methods include, for example, dial-up, broadband, and wireless.  \nUbuntu 22.04 LTS functionality (e.g., RDP) must be capable of taking enforcement action if the audit reveals unauthorized activity. \nAutomated control of remote access sessions allows organizations to ensure ongoing compliance with remote access policies by \nenforcing connection rules of remote access applications on a variety of information system components.",
        "platforms": [
          "#machine_and_package_ufw"
        ],
        "vuln_id": "SV-238355",
        "stig_id": "UBTU-20-010434"
      },
      "xccdf_org.ssgproject.content_rule_ufw_only_required_services": {
        "rule_id": "xccdf_org.ssgproject.content_rule_ufw_only_required_services",
        "title": "Only Allow Authorized Network Services in ufw",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000382"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000096-GPOS-00050"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010407"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238328r654159_rule"
            ]
          }
        ],
        "description": "Check the firewall configuration for any unnecessary or prohibited\nfunctions, ports, protocols, and/or services by running the following\ncommand:\n<pre>$ sudo ufw show raw\nChain OUTPUT (policy ACCEPT)\ntarget prot opt sources destination\nChain INPUT (policy ACCEPT 1 packets, 40 bytes)\npkts bytes target prot opt in out source destination\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target prot opt in out source destination\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\npkts bytes target prot opt in out source destination</pre>\n\nAsk the System Administrator for the site or program PPSM CLSA. Verify\nthe services allowed by the firewall match the PPSM CLSA.",
        "rationale": "To prevent unauthorized connection of devices, unauthorized transfer of\ninformation, or unauthorized tunneling (i.e., embedding of data types\nwithin data types), organizations must disable or restrict unused or\nunnecessary physical and logical ports/protocols on information systems.\n\nOperating systems are capable of providing a wide variety of functions\nand services. Some of the functions and services provided by default\nmay not be necessary to support essential organizational operations.\nAdditionally, it is sometimes convenient to provide multiple services\nfrom a single component (e.g., VPN and IPS); however, doing so\nincreases risk over limiting the services provided by any one component.\n\nTo support the requirements and principles of least functionality, the\noperating system must support the organizational requirements, providing\nonly essential capabilities and limiting the use of ports, protocols,\nand/or services to only those required, authorized, and approved to\nconduct official business or to address authorized quality of life\nissues.",
        "vuln_id": "SV-238328",
        "stig_id": "UBTU-20-010407"
      },
      "xccdf_org.ssgproject.content_rule_ufw_rate_limit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_ufw_rate_limit",
        "title": "ufw Must rate-limit network interfaces",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002385"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000420-GPOS-00186"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010446"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238367r853444_rule"
            ]
          }
        ],
        "description": "The operating system must configure the uncomplicated firewall to\nrate-limit impacted network interfaces.\n\nCheck all the services listening to the ports with the following\ncommand:\n<pre>$ sudo ss -l46ut\nNetid State Recv-Q Send-Q Local Address:Port Peer Address:Port Process\ntcp LISTEN 0 128 [::]:ssh [::]:*</pre>\n\nFor each entry, verify that the ufw is configured to rate limit the\nservice ports with the following command:\n<pre>$ sudo ufw status</pre>\n\nIf any port with a state of &quot;LISTEN&quot; is not marked with the &quot;LIMIT&quot;\naction, run the following command, replacing &quot;service&quot; with the\nservice that needs to be rate limited:\n<pre>$ sudo ufw limit &quot;service&quot;</pre>\n\nRate-limiting can also be done on an interface. An example of adding\na rate-limit on the eth0 interface follows:\n<pre>$ sudo ufw limit in on eth0</pre>\n       ",
        "rationale": "This requirement addresses the configuration of the operating system to\nmitigate the impact of DoS attacks that have occurred or are ongoing on\nsystem availability. For each system, known and potential DoS attacks\nmust be identified and solutions for each type implemented. A variety\nof technologies exist to limit or, in some cases, eliminate the effects\nof DoS attacks (e.g., limiting processes or establishing memory\npartitions). Employing increased capacity and bandwidth, combined with\nservice redundancy, may reduce the susceptibility to some DoS attacks.",
        "vuln_id": "SV-238367",
        "stig_id": "UBTU-20-010446"
      },
      "xccdf_org.ssgproject.content_rule_wireless_disable_interfaces": {
        "rule_id": "xccdf_org.ssgproject.content_rule_wireless_disable_interfaces",
        "title": "Deactivate Wireless Network Interfaces",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "3.1.2"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "12",
              "14",
              "15",
              "3",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS01.04",
              "DSS05.02",
              "DSS05.03",
              "DSS05.05",
              "DSS06.06"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.16"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000085",
              "CCI-001443",
              "CCI-001444",
              "CCI-002418",
              "CCI-002421"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.3",
              "4.3.3.5.4",
              "4.3.3.5.5",
              "4.3.3.5.6",
              "4.3.3.5.7",
              "4.3.3.5.8",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.1",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.11",
              "SR 1.12",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.6",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.2",
              "SR 2.3",
              "SR 2.4",
              "SR 2.5",
              "SR 2.6",
              "SR 2.7",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "1315",
              "1319"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.6.2.1",
              "A.6.2.2",
              "A.9.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-18(3)",
              "AC-18(a)",
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)",
              "MP-7"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-3",
              "PR.IP-1",
              "PR.PT-3",
              "PR.PT-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000299-GPOS-00117",
              "SRG-OS-000300-GPOS-00118",
              "SRG-OS-000424-GPOS-00188",
              "SRG-OS-000481-GPOS-000481"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-1.3.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "1.3.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010455"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-252704r916433_rule"
            ]
          }
        ],
        "description": "Deactivating wireless network interfaces should prevent normal usage of the wireless\ncapability.\n<br>\n         <br>\n\nVerify that there are no wireless interfaces configured on the system\nwith the following command:\n<pre>$ ls -L -d /sys/class/net/*/wireless | xargs dirname | xargs basename -a</pre>\n        ",
        "rationale": "The use of wireless networking can introduce many different attack vectors into\nthe organization&#x27;s network. Common attack vectors such as malicious association\nand ad hoc networks will allow an attacker to spoof a wireless access point\n(AP), allowing validated systems to connect to the malicious AP and enabling the\nattacker to monitor and record network traffic. These malicious APs can also\nserve to create a man-in-the-middle attack or be used to create a denial of\nservice to valid network resources.",
        "platforms": [
          "#wifi-iface"
        ],
        "oval_definition_id": "oval:ssg-wireless_disable_interfaces:def:1",
        "remediations": [
          {
            "remediation_id": "wireless_disable_interfaces",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "unknown",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010455\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n\n- name: Service facts\n  ansible.builtin.service_facts: null\n  tags:\n  - DISA-STIG-UBTU-20-010455\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n\n- name: Ensure NetworkManager is installed\n  ansible.builtin.package:\n    name: '{{ item }}'\n    state: present\n  with_items:\n  - NetworkManager\n  tags:\n  - DISA-STIG-UBTU-20-010455\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n\n- name: NetworkManager Deactivate Wireless Network Interfaces\n  command: nmcli radio wifi off\n  when:\n  - '''NetworkManager'' in ansible_facts.packages'\n  - ansible_facts.services['NetworkManager.service'].state == 'running'\n  tags:\n  - DISA-STIG-UBTU-20-010455\n  - NIST-800-171-3.1.16\n  - NIST-800-53-AC-18(3)\n  - NIST-800-53-AC-18(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSS-Req-1.3.3\n  - PCI-DSSv4-1.3.3\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n  - wireless_disable_interfaces\n"
          },
          {
            "remediation_id": "wireless_disable_interfaces",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "\nif [ -n \"$(find /sys/class/net/*/ -type d -name wireless)\" ]; then\n    interfaces=$(find /sys/class/net/*/wireless -type d -name wireless | xargs -0 dirname | xargs basename)\n\n    for i in $interfaces; do\n        ip link set dev \"$i\" down\n        drivers=$(basename \"$(readlink -f /sys/class/net/\"$i\"/device/driver)\")\n        echo \"install $drivers /bin/false\" >> /etc/modprobe.d/disable_wireless.conf\n        modprobe -r \"$drivers\"\n     done\nfi\n"
          }
        ],
        "vuln_id": "SV-252704",
        "stig_id": "UBTU-20-010455"
      },
      "xccdf_org.ssgproject.content_rule_only_allow_dod_certs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_only_allow_dod_certs",
        "title": "Only Allow DoD PKI-established CAs",
        "result": "notchecked",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002470"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000403-GPOS-00182"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010443"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238364r880902_rule"
            ]
          }
        ],
        "description": "The operating system must only allow the use of DoD PKI-established\ncertificate authorities for verification of the establishment of\nprotected sessions.",
        "rationale": "Untrusted Certificate Authorities (CA) can issue certificates, but they\nmay be issued by organizations or individuals that seek to compromise\nDoD systems or by organizations with insufficient security controls. If\nthe CA used for verifying the certificate is not a DoD-approved CA,\ntrust of this CA has not been established.\nThe DoD will only accept PKI-certificates obtained from a DoD-approved\ninternal or external certificate authority. Reliance on CAs for the\nestablishment of secure sessions includes, for example, the use of\nSSL/TLS certificates.",
        "messages": [
          "No candidate or applicable check found."
        ],
        "vuln_id": "SV-238364",
        "stig_id": "UBTU-20-010443"
      },
      "xccdf_org.ssgproject.content_rule_dir_perms_world_writable_sticky_bits": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dir_perms_world_writable_sticky_bits",
        "title": "Verify that All World-Writable Directories Have Sticky Bits Set",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R54"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.1.22"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001090"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000138-GPOS-00069"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010411"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238332r654171_rule"
            ]
          }
        ],
        "description": "When the so-called &#x27;sticky bit&#x27; is set on a directory, only the owner of a given file may\nremove that file from the directory. Without the sticky bit, any user with write access to a\ndirectory may remove any file in the directory. Setting the sticky bit prevents users from\nremoving each other&#x27;s files. In cases where there is no reason for a directory to be\nworld-writable, a better solution is to remove that permission rather than to set the sticky\nbit. However, if a directory is used by a particular application, consult that application&#x27;s\ndocumentation instead of blindly changing modes.\n<br>\nTo set the sticky bit on a world-writable directory <i>DIR</i>, run the following command:\n<pre>$ sudo chmod +t <i>DIR</i>\n        </pre>\n       ",
        "rationale": "Failing to set the sticky bit on public directories allows unauthorized users to delete files\nin the directory structure.\n<br>\n        <br>\nThe only authorized public directories are those temporary directories supplied with the\nsystem, or those designed to be temporary file repositories. The setting is normally reserved\nfor directories used by the system, by users for temporary file storage (such as <code>/tmp</code>),\nand for directories requiring global read/write access.",
        "warnings": [
          {
            "text": "This rule can take a long time to perform the check and might consume a considerable\namount of resources depending on the number of directories present on the system. It is\nnot a problem in most cases, but especially systems with a large number of directories can\nbe affected. See <code>https://access.redhat.com/articles/6999111</code>.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-dir_perms_world_writable_sticky_bits:def:1",
        "remediations": [
          {
            "remediation_id": "dir_perms_world_writable_sticky_bits",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "df --local -P | awk '{if (NR!=1) print $6}' \\\n| xargs -I '$6' find '$6' -xdev -type d \\\n\\( -perm -0002 -a ! -perm -1000 \\) 2>/dev/null \\\n-exec chmod a+t {} +\n"
          }
        ],
        "vuln_id": "SV-238332",
        "stig_id": "UBTU-20-010411"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_auditd": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_auditd",
        "title": "Verify Permissions on /etc/audit/auditd.conf",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000171"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(b)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000063-GPOS-00032"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010133"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238249r653922_rule"
            ]
          }
        ],
        "description": "\nTo properly set the permissions of <code>/etc/audit/auditd.conf</code>, run the command:\n<pre>$ sudo chmod 0640 /etc/audit/auditd.conf</pre>\n       ",
        "rationale": "Without the capability to restrict the roles and individuals that can select which events\nare audited, unauthorized personnel may be able to prevent the auditing of critical\nevents. Misconfigured audits may degrade the system&#x27;s performance by overwhelming\nthe audit log. Misconfigured audits may also make it more difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.",
        "oval_definition_id": "oval:ssg-file_permissions_etc_audit_auditd:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_etc_audit_auditd",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Test for existence /etc/audit/auditd.conf\n  stat:\n    path: /etc/audit/auditd.conf\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010133\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_auditd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xs,g-xws,o-xwrt on /etc/audit/auditd.conf\n  file:\n    path: /etc/audit/auditd.conf\n    mode: u-xs,g-xws,o-xwrt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010133\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_auditd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_permissions_etc_audit_auditd",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nchmod u-xs,g-xws,o-xwrt /etc/audit/auditd.conf\n"
          }
        ],
        "vuln_id": "SV-238249",
        "stig_id": "UBTU-20-010133"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_rulesd": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_etc_audit_rulesd",
        "title": "Verify Permissions on /etc/audit/rules.d/*.rules",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000171"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(b)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000063-GPOS-00032"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010133"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238249r653922_rule"
            ]
          }
        ],
        "description": "\nTo properly set the permissions of <code>/etc/audit/rules.d/*.rules</code>, run the command:\n<pre>$ sudo chmod 0640 /etc/audit/rules.d/*.rules</pre>\n       ",
        "rationale": "Without the capability to restrict the roles and individuals that can select which events\nare audited, unauthorized personnel may be able to prevent the auditing of critical\nevents. Misconfigured audits may degrade the system&#x27;s performance by overwhelming\nthe audit log. Misconfigured audits may also make it more difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.",
        "oval_definition_id": "oval:ssg-file_permissions_etc_audit_rulesd:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_etc_audit_rulesd",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /etc/audit/rules.d/ file(s)\n  command: find -H /etc/audit/rules.d/ -maxdepth 1 -perm /u+xs,g+xws,o+xwrt  -type\n    f -regextype posix-extended -regex \"^.*rules$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010133\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_rulesd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /etc/audit/rules.d/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-xs,g-xws,o-xwrt\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010133\n  - NIST-800-53-AU-12(b)\n  - configure_strategy\n  - file_permissions_etc_audit_rulesd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_permissions_etc_audit_rulesd",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nfind -H /etc/audit/rules.d/ -maxdepth 1 -perm /u+xs,g+xws,o+xwrt  -type f -regextype posix-extended -regex '^.*rules$' -exec chmod u-xs,g-xws,o-xwrt {} \\;\n"
          }
        ],
        "vuln_id": "SV-238249",
        "stig_id": "UBTU-20-010133"
      },
      "xccdf_org.ssgproject.content_rule_permissions_local_var_log": {
        "rule_id": "xccdf_org.ssgproject.content_rule_permissions_local_var_log",
        "title": "Verify permissions of log files",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.2.3"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001312"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "SI-11(a)",
              "SI-11(b)",
              "SI-11.1(iii)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000205-GPOS-00083"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010416"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238337r880876_rule"
            ]
          }
        ],
        "description": "Any operating system providing too much information in error messages\nrisks compromising the data and security of the structure, and content\nof error messages needs to be carefully considered by the organization.\n\nOrganizations carefully consider the structure/content of error messages.\nThe extent to which information systems are able to identify and handle\nerror conditions is guided by organizational policy and operational\nrequirements. Information that could be exploited by adversaries includes,\nfor example, erroneous logon attempts with passwords entered by mistake\nas the username, mission/business information that can be derived from\n(if not stated explicitly by) information recorded, and personal\ninformation, such as account numbers, social security numbers, and credit\ncard numbers.",
        "rationale": "The Ubuntu 20.04 must generate error messages that provide information\nnecessary for corrective actions without revealing information that could\nbe exploited by adversaries.",
        "oval_definition_id": "oval:ssg-permissions_local_var_log:def:1",
        "remediations": [
          {
            "remediation_id": "permissions_local_var_log",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /var/log/ file(s) recursively\n  command: find -H /var/log/  -perm /u+xs,g+xws,o+xwrt ! -name \"history.log\" ! -name\n    \"eipp.log.xz\" ! -name \"*[bw]tmp\" ! -name \"*lastlog\" -type f -regextype posix-extended\n    -regex \".*\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010416\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - NIST-800-53-SI-11.1(iii)\n  - PCI-DSSv4-10.3.1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - permissions_local_var_log\n\n- name: Set permissions for /var/log/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-xs,g-xws,o-xwrt\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010416\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - NIST-800-53-SI-11.1(iii)\n  - PCI-DSSv4-10.3.1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - permissions_local_var_log\n"
          },
          {
            "remediation_id": "permissions_local_var_log",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nfind -H /var/log/  -perm /u+xs,g+xws,o+xwrt ! -name 'history.log' ! -name 'eipp.log.xz' ! -name '*[bw]tmp' ! -name '*lastlog' -type f -regextype posix-extended -regex '.*' -exec chmod u-xs,g-xws,o-xwrt {} \\;\n"
          }
        ],
        "vuln_id": "SV-238337",
        "stig_id": "UBTU-20-010416"
      },
      "xccdf_org.ssgproject.content_rule_file_groupowner_var_log": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_groupowner_var_log",
        "title": "Verify Group Who Owns /var/log Directory",
        "result": "fail",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000118-CTR-000240"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010417"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238338r654189_rule"
            ]
          }
        ],
        "description": " To properly set the group owner of <code>/var/log</code>, run the command: <pre>$ sudo chgrp syslog /var/log</pre>\n        ",
        "rationale": "The <code>/var/log</code> directory contains files with logs of error\nmessages in the system and should only be accessed by authorized\npersonnel.",
        "oval_definition_id": "oval:ssg-file_groupowner_var_log:def:1",
        "remediations": [
          {
            "remediation_id": "file_groupowner_var_log",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Ensure group owner on /var/log/\n  file:\n    path: /var/log/\n    state: directory\n    group: '110'\n  tags:\n  - DISA-STIG-UBTU-20-010417\n  - configure_strategy\n  - file_groupowner_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_groupowner_var_log",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "find -H /var/log/ -maxdepth 1 -L -type d -exec chgrp -L 110 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238338",
        "stig_id": "UBTU-20-010417"
      },
      "xccdf_org.ssgproject.content_rule_file_groupowner_var_log_syslog": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_groupowner_var_log_syslog",
        "title": "Verify Group Who Owns /var/log/syslog File",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010420"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238341r654198_rule"
            ]
          }
        ],
        "description": " To properly set the group owner of <code>/var/log/syslog</code>, run the command: <pre>$ sudo chgrp adm /var/log/syslog</pre>\n        ",
        "rationale": "The <code>/var/log/syslog</code> file contains logs of error messages in\nthe system and should only be accessed by authorized personnel.",
        "oval_definition_id": "oval:ssg-file_groupowner_var_log_syslog:def:1",
        "remediations": [
          {
            "remediation_id": "file_groupowner_var_log_syslog",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Test for existence /var/log/syslog\n  stat:\n    path: /var/log/syslog\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010420\n  - configure_strategy\n  - file_groupowner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 4 on /var/log/syslog\n  file:\n    path: /var/log/syslog\n    group: '4'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010420\n  - configure_strategy\n  - file_groupowner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_groupowner_var_log_syslog",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "chgrp -L 4 /var/log/syslog\n"
          }
        ],
        "vuln_id": "SV-238341",
        "stig_id": "UBTU-20-010420"
      },
      "xccdf_org.ssgproject.content_rule_file_owner_var_log": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_owner_var_log",
        "title": "Verify User Who Owns /var/log Directory",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000118-CTR-000240"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010418"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238339r654192_rule"
            ]
          }
        ],
        "description": " To properly set the owner of <code>/var/log</code>, run the command: <pre>$ sudo chown root /var/log </pre>\n        ",
        "rationale": "The <code>/var/log</code> directory contains files with logs of error\nmessages in the system and should only be accessed by authorized\npersonnel.",
        "oval_definition_id": "oval:ssg-file_owner_var_log:def:1",
        "remediations": [
          {
            "remediation_id": "file_owner_var_log",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Ensure owner on directory /var/log/\n  file:\n    path: /var/log/\n    state: directory\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010418\n  - configure_strategy\n  - file_owner_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_owner_var_log",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "find -H /var/log/ -maxdepth 1 -L -type d -exec chown -L 0 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238339",
        "stig_id": "UBTU-20-010418"
      },
      "xccdf_org.ssgproject.content_rule_file_owner_var_log_syslog": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_owner_var_log_syslog",
        "title": "Verify User Who Owns /var/log/syslog File",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010421"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238342r654201_rule"
            ]
          }
        ],
        "description": " To properly set the owner of <code>/var/log/syslog</code>, run the command: <pre>$ sudo chown syslog /var/log/syslog </pre>\n        ",
        "rationale": "The <code>/var/log/syslog</code> file contains logs of error messages in\nthe system and should only be accessed by authorized personnel.",
        "oval_definition_id": "oval:ssg-file_owner_var_log_syslog:def:1",
        "remediations": [
          {
            "remediation_id": "file_owner_var_log_syslog",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Test for existence /var/log/syslog\n  stat:\n    path: /var/log/syslog\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010421\n  - configure_strategy\n  - file_owner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 104 on /var/log/syslog\n  file:\n    path: /var/log/syslog\n    owner: '104'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010421\n  - configure_strategy\n  - file_owner_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_owner_var_log_syslog",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "chown -L 104 /var/log/syslog\n"
          }
        ],
        "vuln_id": "SV-238342",
        "stig_id": "UBTU-20-010421"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_var_log": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_var_log",
        "title": "Verify Permissions on /var/log Directory",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000118-CTR-000240"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010419"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238340r880879_rule"
            ]
          }
        ],
        "description": "\nTo properly set the permissions of <code>/var/log</code>, run the command:\n<pre>$ sudo chmod 0755 /var/log</pre>\n        ",
        "rationale": "The <code>/var/log</code> directory contains files with logs of error\nmessages in the system and should only be accessed by authorized\npersonnel.",
        "oval_definition_id": "oval:ssg-file_permissions_var_log:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_var_log",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /var/log/ file(s)\n  command: 'find -H /var/log/ -maxdepth 1 -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010419\n  - configure_strategy\n  - file_permissions_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /var/log/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010419\n  - configure_strategy\n  - file_permissions_var_log\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_permissions_var_log",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "\nchmod 0755 /var/log/\n\nif grep -q \"^z \\/var\\/log \" /usr/lib/tmpfiles.d/00rsyslog.conf; then\n    sed -i --follow-symlinks \"s/\\(^z[[:space:]]\\+\\/var\\/log[[:space:]]\\+\\)\\(\\([[:digit:]]\\+\\)[^ $]*\\)/\\10755/\" /usr/lib/tmpfiles.d/00rsyslog.conf\nfi\n"
          }
        ],
        "vuln_id": "SV-238340",
        "stig_id": "UBTU-20-010419"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_var_log_syslog": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_var_log_syslog",
        "title": "Verify Permissions on /var/log/syslog File",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001314"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010422"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238343r654204_rule"
            ]
          }
        ],
        "description": "\nTo properly set the permissions of <code>/var/log/syslog</code>, run the command:\n<pre>$ sudo chmod 0640 /var/log/syslog</pre>\n        ",
        "rationale": "The <code>/var/log/syslog</code> file contains logs of error messages in\nthe system and should only be accessed by authorized personnel.",
        "oval_definition_id": "oval:ssg-file_permissions_var_log_syslog:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_var_log_syslog",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Test for existence /var/log/syslog\n  stat:\n    path: /var/log/syslog\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010422\n  - configure_strategy\n  - file_permissions_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xs,g-xws,o-xwrt on /var/log/syslog\n  file:\n    path: /var/log/syslog\n    mode: u-xs,g-xws,o-xwrt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010422\n  - configure_strategy\n  - file_permissions_var_log_syslog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_permissions_var_log_syslog",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nchmod u-xs,g-xws,o-xwrt /var/log/syslog\n"
          }
        ],
        "vuln_id": "SV-238343",
        "stig_id": "UBTU-20-010422"
      },
      "xccdf_org.ssgproject.content_rule_dir_group_ownership_library_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dir_group_ownership_library_dirs",
        "title": "Verify that Shared Library Directories Have Root Group Ownership",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-5(6)",
              "CM-5(6).1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010431"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238352r654231_rule"
            ]
          }
        ],
        "description": "System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are also\nstored in <code>/lib/modules</code>. All files in these directories should be\ngroup-owned by the <code>root</code> user. If the  directories, is found to be owned\nby a user other than root correct its\nownership with the following command:\n<pre>$ sudo chgrp root <i>DIR</i>\n         </pre>\n        ",
        "rationale": "Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Proper ownership of library directories is necessary to protect\nthe integrity of the system.",
        "oval_definition_id": "oval:ssg-dir_group_ownership_library_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "dir_group_ownership_library_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Ensure group owner on /lib/ recursively\n  file:\n    path: /lib/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010431\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /lib64/ recursively\n  file:\n    path: /lib64/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010431\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/lib/ recursively\n  file:\n    path: /usr/lib/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010431\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/lib64/ recursively\n  file:\n    path: /usr/lib64/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010431\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_group_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "dir_group_ownership_library_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "find -H /lib/  -type d -exec chgrp -L 0 {} \\;\nfind -H /lib64/  -type d -exec chgrp -L 0 {} \\;\nfind -H /usr/lib/  -type d -exec chgrp -L 0 {} \\;\nfind -H /usr/lib64/  -type d -exec chgrp -L 0 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238352",
        "stig_id": "UBTU-20-010431"
      },
      "xccdf_org.ssgproject.content_rule_dir_groupownership_binary_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dir_groupownership_binary_dirs",
        "title": "Verify that system commands directories are group owned by root",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001495"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000258-GPOS-00099"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010425"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238346r654213_rule"
            ]
          }
        ],
        "description": "System commands files are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin\n</pre>\nAll these directories should be owned by the <code>root</code> group.\nIf the directory is found to be owned by a group other than root correct\nits ownership with the following command:\n<pre>$ sudo chgrp root <i>DIR</i>\n         </pre>\n        ",
        "rationale": "If the operating system allows any user to make changes to software\nlibraries, then those changes might be implemented without undergoing the\nappropriate testing and approvals that are part of a robust change management\nprocess.\nThis requirement applies to operating systems with software libraries\nthat are accessible and configurable, as in the case of interpreted languages.\nSoftware libraries also include privileged programs which execute with\nescalated privileges. Only qualified and authorized individuals must be\nallowed to obtain access to information system components for purposes\nof initiating changes, including upgrades and modifications.",
        "oval_definition_id": "oval:ssg-dir_groupownership_binary_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "dir_groupownership_binary_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Ensure group owner on /bin/ recursively\n  file:\n    path: /bin/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010425\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /sbin/ recursively\n  file:\n    path: /sbin/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010425\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/bin/ recursively\n  file:\n    path: /usr/bin/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010425\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/sbin/ recursively\n  file:\n    path: /usr/sbin/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010425\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/local/bin/ recursively\n  file:\n    path: /usr/local/bin/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010425\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /usr/local/sbin/ recursively\n  file:\n    path: /usr/local/sbin/\n    state: directory\n    recurse: true\n    group: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010425\n  - configure_strategy\n  - dir_groupownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "dir_groupownership_binary_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "find -H /bin/  -type d -exec chgrp -L 0 {} \\;\nfind -H /sbin/  -type d -exec chgrp -L 0 {} \\;\nfind -H /usr/bin/  -type d -exec chgrp -L 0 {} \\;\nfind -H /usr/sbin/  -type d -exec chgrp -L 0 {} \\;\nfind -H /usr/local/bin/  -type d -exec chgrp -L 0 {} \\;\nfind -H /usr/local/sbin/  -type d -exec chgrp -L 0 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238346",
        "stig_id": "UBTU-20-010425"
      },
      "xccdf_org.ssgproject.content_rule_dir_ownership_binary_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dir_ownership_binary_dirs",
        "title": "Verify that System Executable Have Root Ownership",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001495"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000258-GPOS-00099"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010424"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238345r654210_rule"
            ]
          }
        ],
        "description": "<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin</pre>\nAll these directories should be owned by the <code>root</code> user.\nIf any directory <i>DIR</i> in these directories is found\nto be owned by a user other than root, correct its ownership with the\nfollowing command:\n<pre>$ sudo chown root <i>DIR</i>\n         </pre>\n        ",
        "rationale": "System binaries are executed by privileged users as well as system services,\nand restrictive permissions are necessary to ensure that their\nexecution of these programs cannot be co-opted.",
        "oval_definition_id": "oval:ssg-dir_ownership_binary_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "dir_ownership_binary_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Ensure owner on directory /bin/ recursively\n  file:\n    path: /bin/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010424\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /sbin/ recursively\n  file:\n    path: /sbin/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010424\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/bin/ recursively\n  file:\n    path: /usr/bin/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010424\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/sbin/ recursively\n  file:\n    path: /usr/sbin/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010424\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/local/bin/ recursively\n  file:\n    path: /usr/local/bin/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010424\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/local/sbin/ recursively\n  file:\n    path: /usr/local/sbin/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010424\n  - configure_strategy\n  - dir_ownership_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "dir_ownership_binary_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "find -H /bin/  -type d -exec chown -L 0 {} \\;\nfind -H /sbin/  -type d -exec chown -L 0 {} \\;\nfind -H /usr/bin/  -type d -exec chown -L 0 {} \\;\nfind -H /usr/sbin/  -type d -exec chown -L 0 {} \\;\nfind -H /usr/local/bin/  -type d -exec chown -L 0 {} \\;\nfind -H /usr/local/sbin/  -type d -exec chown -L 0 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238345",
        "stig_id": "UBTU-20-010424"
      },
      "xccdf_org.ssgproject.content_rule_dir_ownership_library_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dir_ownership_library_dirs",
        "title": "Verify that Shared Library Directories Have Root Ownership",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-5(6)",
              "CM-5(6).1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010429"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238350r654225_rule"
            ]
          }
        ],
        "description": "System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are also\nstored in <code>/lib/modules</code>. All files in these directories should be\nowned by the <code>root</code> user. If the  directories, is found to be owned\nby a user other than root correct its\nownership with the following command:\n<pre>$ sudo chown root <i>DIR</i>\n         </pre>\n        ",
        "rationale": "Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Proper ownership of library directories is necessary to protect\nthe integrity of the system.",
        "oval_definition_id": "oval:ssg-dir_ownership_library_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "dir_ownership_library_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Ensure owner on directory /lib/ recursively\n  file:\n    path: /lib/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010429\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /lib64/ recursively\n  file:\n    path: /lib64/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010429\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/lib/ recursively\n  file:\n    path: /usr/lib/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010429\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on directory /usr/lib64/ recursively\n  file:\n    path: /usr/lib64/\n    state: directory\n    recurse: true\n    owner: '0'\n  tags:\n  - DISA-STIG-UBTU-20-010429\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "dir_ownership_library_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "find -H /lib/  -type d -exec chown -L 0 {} \\;\nfind -H /lib64/  -type d -exec chown -L 0 {} \\;\nfind -H /usr/lib/  -type d -exec chown -L 0 {} \\;\nfind -H /usr/lib64/  -type d -exec chown -L 0 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238350",
        "stig_id": "UBTU-20-010429"
      },
      "xccdf_org.ssgproject.content_rule_dir_permissions_binary_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dir_permissions_binary_dirs",
        "title": "Verify that System Executable Directories Have Restrictive Permissions",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001495"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000258-GPOS-00099"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010423"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238344r654207_rule"
            ]
          }
        ],
        "description": "System executables are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin</pre>\nThese directories should not be group-writable or world-writable.\nIf any directory <i>DIR</i> in these directories is found to be\ngroup-writable or world-writable, correct its permission with the\nfollowing command:\n<pre>$ sudo chmod go-w <i>DIR</i>\n         </pre>\n        ",
        "rationale": "System binaries are executed by privileged users, as well as system services,\nand restrictive permissions are necessary to ensure execution of these programs\ncannot be co-opted.",
        "oval_definition_id": "oval:ssg-dir_permissions_binary_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "dir_permissions_binary_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /bin/ file(s) recursively\n  command: 'find -H /bin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /bin/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /sbin/ file(s) recursively\n  command: 'find -H /sbin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /sbin/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/bin/ file(s) recursively\n  command: 'find -H /usr/bin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/bin/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/sbin/ file(s) recursively\n  command: 'find -H /usr/sbin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/sbin/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/local/bin/ file(s) recursively\n  command: 'find -H /usr/local/bin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/local/bin/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/local/sbin/ file(s) recursively\n  command: 'find -H /usr/local/sbin/  -perm /u+s,g+ws,o+wt  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/local/sbin/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: u-s,g-ws,o-wt\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010423\n  - configure_strategy\n  - dir_permissions_binary_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "dir_permissions_binary_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nfind -H /bin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /sbin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/bin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/sbin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/local/bin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n\nfind -H /usr/local/sbin/  -perm /u+s,g+ws,o+wt -type d -exec chmod u-s,g-ws,o-wt {} \\;\n"
          }
        ],
        "vuln_id": "SV-238344",
        "stig_id": "UBTU-20-010423"
      },
      "xccdf_org.ssgproject.content_rule_dir_permissions_library_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_dir_permissions_library_dirs",
        "title": "Verify that Shared Library Directories Have Restrictive Permissions",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R6"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-5",
              "CM-5(6)",
              "CM-5(6).1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010427"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238348r654219_rule"
            ]
          }
        ],
        "description": "System-wide shared library directories, which contain are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are\nstored in <code>/lib/modules</code>. All sub-directories in these directories\nshould not be group-writable or world-writable. If any file in these\ndirectories is found to be group-writable or world-writable, correct\nits permission with the following command:\n<pre>$ sudo chmod go-w <i>DIR</i>\n         </pre>\n        ",
        "rationale": "If the operating system were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate testing\nand approvals that are part of a robust change management process.\n\nThis requirement applies to operating systems with software libraries that are accessible\nand configurable, as in the case of interpreted languages. Software libraries also include\nprivileged programs which execute with escalated privileges. Only qualified and authorized\nindividuals must be allowed to obtain access to information system components for purposes\nof initiating changes, including upgrades and modifications.",
        "oval_definition_id": "oval:ssg-dir_permissions_library_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "dir_permissions_library_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /lib/ file(s) recursively\n  command: 'find -H /lib/  -perm /g+w,o+w  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /lib/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /lib64/ file(s) recursively\n  command: 'find -H /lib64/  -perm /g+w,o+w  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /lib64/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib/ file(s) recursively\n  command: 'find -H /usr/lib/  -perm /g+w,o+w  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/lib/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib64/ file(s) recursively\n  command: 'find -H /usr/lib64/  -perm /g+w,o+w  -type d '\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/lib64/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: directory\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010427\n  - NIST-800-53-CM-5\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - dir_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "dir_permissions_library_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nfind -H /lib/  -perm /g+w,o+w -type d -exec chmod g-w,o-w {} \\;\n\nfind -H /lib64/  -perm /g+w,o+w -type d -exec chmod g-w,o-w {} \\;\n\nfind -H /usr/lib/  -perm /g+w,o+w -type d -exec chmod g-w,o-w {} \\;\n\nfind -H /usr/lib64/  -perm /g+w,o+w -type d -exec chmod g-w,o-w {} \\;\n"
          }
        ],
        "vuln_id": "SV-238348",
        "stig_id": "UBTU-20-010427"
      },
      "xccdf_org.ssgproject.content_rule_file_groupownership_audit_binaries": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_groupownership_audit_binaries",
        "title": "Verify that audit tools are owned by group root",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001493",
              "CCI-001494"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000256-GPiOS-00097",
              "SRG-OS-000257-GPOS-00098"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010201"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238302r654081_rule"
            ]
          }
        ],
        "description": "The Ubuntu 20.04 operating system audit tools must have the proper\nownership configured to protected against unauthorized access.\n\nVerify it by running the following command:\n<pre>$ stat -c &quot;%n %G&quot; /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/audispd /sbin/augenrules\n\n/sbin/auditctl root\n/sbin/aureport root\n/sbin/ausearch root\n/sbin/autrace root\n/sbin/auditd root\n/sbin/audispd root\n/sbin/augenrules root\n</pre>\n\nAudit tools needed to successfully view and manipulate audit information\nsystem activity and records. Audit tools include custom queries and report\ngenerators",
        "rationale": "Protecting audit information also includes identifying and protecting the\ntools used to view and manipulate log data. Therefore, protecting audit\ntools is necessary to prevent unauthorized operation on audit information.\n\nOperating systems providing tools to interface with audit information\nwill leverage user permissions and roles identifying the user accessing the\ntools and the corresponding rights the user enjoys to make access decisions\nregarding the access to audit tools.",
        "oval_definition_id": "oval:ssg-file_groupownership_audit_binaries:def:1",
        "remediations": [
          {
            "remediation_id": "file_groupownership_audit_binaries",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Test for existence /sbin/auditctl\n  stat:\n    path: /sbin/auditctl\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /sbin/auditctl\n  file:\n    path: /sbin/auditctl\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/aureport\n  stat:\n    path: /sbin/aureport\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /sbin/aureport\n  file:\n    path: /sbin/aureport\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/ausearch\n  stat:\n    path: /sbin/ausearch\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /sbin/ausearch\n  file:\n    path: /sbin/ausearch\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/autrace\n  stat:\n    path: /sbin/autrace\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /sbin/autrace\n  file:\n    path: /sbin/autrace\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/auditd\n  stat:\n    path: /sbin/auditd\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /sbin/auditd\n  file:\n    path: /sbin/auditd\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/audispd\n  stat:\n    path: /sbin/audispd\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /sbin/audispd\n  file:\n    path: /sbin/audispd\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/augenrules\n  stat:\n    path: /sbin/augenrules\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /sbin/augenrules\n  file:\n    path: /sbin/augenrules\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010201\n  - configure_strategy\n  - file_groupownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_groupownership_audit_binaries",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "chgrp -L 0 /sbin/auditctl\nchgrp -L 0 /sbin/aureport\nchgrp -L 0 /sbin/ausearch\nchgrp -L 0 /sbin/autrace\nchgrp -L 0 /sbin/auditd\nchgrp -L 0 /sbin/audispd\nchgrp -L 0 /sbin/augenrules\n"
          }
        ],
        "vuln_id": "SV-238302",
        "stig_id": "UBTU-20-010201"
      },
      "xccdf_org.ssgproject.content_rule_file_groupownership_system_commands_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_groupownership_system_commands_dirs",
        "title": "Verify that system commands files are group owned by root or a system account",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R50"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-5(6)",
              "CM-5(6).1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010458"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238378r832971_rule"
            ]
          }
        ],
        "description": "System commands files are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/sbin\n/usr/local/bin\n/usr/local/sbin\n</pre>\nAll files in these directories should be owned by the <code>root</code> group,\nor a system account.\nIf the directory, or any file in these directories, is found to be owned\nby a group other than root or a a system account correct its ownership\nwith the following command:\n<pre>$ sudo chgrp root <i>FILE</i>\n         </pre>\n        ",
        "rationale": "If the operating system allows any user to make changes to software\nlibraries, then those changes might be implemented without undergoing the\nappropriate testing and approvals that are part of a robust change management\nprocess.\nThis requirement applies to operating systems with software libraries\nthat are accessible and configurable, as in the case of interpreted languages.\nSoftware libraries also include privileged programs which execute with\nescalated privileges. Only qualified and authorized individuals must be\nallowed to obtain access to information system components for purposes\nof initiating changes, including upgrades and modifications.",
        "oval_definition_id": "oval:ssg-file_groupownership_system_commands_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "file_groupownership_system_commands_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "\nfor SYSCMDFILES in /bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin\ndo\n   find -L $SYSCMDFILES \\! -group root -type f -exec chgrp root '{}' \\;\ndone\n"
          }
        ],
        "vuln_id": "SV-238378",
        "stig_id": "UBTU-20-010458"
      },
      "xccdf_org.ssgproject.content_rule_file_ownership_audit_binaries": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_ownership_audit_binaries",
        "title": "Verify that audit tools are owned by root",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001493",
              "CCI-001494"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000256-GPiOS-00097",
              "SRG-OS-000257-GPOS-00098"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010200"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238301r654078_rule"
            ]
          }
        ],
        "description": "The Ubuntu 20.04 operating system audit tools must have the proper\nownership configured to protected against unauthorized access.\n\nVerify it by running the following command:\n<pre>$ stat -c &quot;%n %U&quot; /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/audispd /sbin/augenrules\n\n/sbin/auditctl root\n/sbin/aureport root\n/sbin/ausearch root\n/sbin/autrace root\n/sbin/auditd root\n/sbin/audispd root\n/sbin/augenrules root\n</pre>\n\nAudit tools needed to successfully view and manipulate audit information\nsystem activity and records. Audit tools include custom queries and report\ngenerators",
        "rationale": "Protecting audit information also includes identifying and protecting the\ntools used to view and manipulate log data. Therefore, protecting audit\ntools is necessary to prevent unauthorized operation on audit information.\n\nOperating systems providing tools to interface with audit information\nwill leverage user permissions and roles identifying the user accessing the\ntools and the corresponding rights the user enjoys to make access decisions\nregarding the access to audit tools.",
        "oval_definition_id": "oval:ssg-file_ownership_audit_binaries:def:1",
        "remediations": [
          {
            "remediation_id": "file_ownership_audit_binaries",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Test for existence /sbin/auditctl\n  stat:\n    path: /sbin/auditctl\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /sbin/auditctl\n  file:\n    path: /sbin/auditctl\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/aureport\n  stat:\n    path: /sbin/aureport\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /sbin/aureport\n  file:\n    path: /sbin/aureport\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/ausearch\n  stat:\n    path: /sbin/ausearch\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /sbin/ausearch\n  file:\n    path: /sbin/ausearch\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/autrace\n  stat:\n    path: /sbin/autrace\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /sbin/autrace\n  file:\n    path: /sbin/autrace\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/auditd\n  stat:\n    path: /sbin/auditd\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /sbin/auditd\n  file:\n    path: /sbin/auditd\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/audispd\n  stat:\n    path: /sbin/audispd\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /sbin/audispd\n  file:\n    path: /sbin/audispd\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/augenrules\n  stat:\n    path: /sbin/augenrules\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /sbin/augenrules\n  file:\n    path: /sbin/augenrules\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010200\n  - configure_strategy\n  - file_ownership_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_ownership_audit_binaries",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "chown -L 0 /sbin/auditctl\nchown -L 0 /sbin/aureport\nchown -L 0 /sbin/ausearch\nchown -L 0 /sbin/autrace\nchown -L 0 /sbin/auditd\nchown -L 0 /sbin/audispd\nchown -L 0 /sbin/augenrules\n"
          }
        ],
        "vuln_id": "SV-238301",
        "stig_id": "UBTU-20-010200"
      },
      "xccdf_org.ssgproject.content_rule_file_ownership_binary_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_ownership_binary_dirs",
        "title": "Verify that System Executables Have Root Ownership",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R50"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-5(6)",
              "CM-5(6).1",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010457"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238377r832968_rule"
            ]
          }
        ],
        "description": "System executables are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/libexec\n/usr/local/bin\n/usr/local/sbin\n/usr/sbin</pre>\nAll files in these directories should be owned by the <code>root</code> user.\nIf any file <i>FILE</i> in these directories is found\nto be owned by a user other than root, correct its ownership with the\nfollowing command:\n<pre>$ sudo chown root <i>FILE</i>\n         </pre>\n        ",
        "rationale": "System binaries are executed by privileged users as well as system services,\nand restrictive permissions are necessary to ensure that their\nexecution of these programs cannot be co-opted.",
        "oval_definition_id": "oval:ssg-file_ownership_binary_dirs:def:1",
        "vuln_id": "SV-238377",
        "stig_id": "UBTU-20-010457"
      },
      "xccdf_org.ssgproject.content_rule_file_ownership_library_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_ownership_library_dirs",
        "title": "Verify that Shared Library Files Have Root Ownership",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-5(6)",
              "CM-5(6).1",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010428"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238349r654222_rule"
            ]
          }
        ],
        "description": "System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are also\nstored in <code>/lib/modules</code>. All files in these directories should be\nowned by the <code>root</code> user. If the directory, or any file in these\ndirectories, is found to be owned by a user other than root correct its\nownership with the following command:\n<pre>$ sudo chown root <i>FILE</i>\n         </pre>\n        ",
        "rationale": "Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Proper ownership is necessary to protect the integrity of the system.",
        "oval_definition_id": "oval:ssg-file_ownership_library_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "file_ownership_library_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /lib/ file(s) matching ^.*$ recursively\n  command: find -H /lib/  -type f ! -uid 0 -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /lib/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    owner: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /lib64/ file(s) matching ^.*$ recursively\n  command: find -H /lib64/  -type f ! -uid 0 -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /lib64/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    owner: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib/ file(s) matching ^.*$ recursively\n  command: find -H /usr/lib/  -type f ! -uid 0 -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /usr/lib/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    owner: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib64/ file(s) matching ^.*$ recursively\n  command: find -H /usr/lib64/  -type f ! -uid 0 -regextype posix-extended -regex\n    \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /usr/lib64/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    owner: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010428\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_ownership_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_ownership_library_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\nfind /lib/  -type f ! -uid 0 -regextype posix-extended -regex '^.*$' -exec chown -L 0 {} \\;\n\nfind /lib64/  -type f ! -uid 0 -regextype posix-extended -regex '^.*$' -exec chown -L 0 {} \\;\n\nfind /usr/lib/  -type f ! -uid 0 -regextype posix-extended -regex '^.*$' -exec chown -L 0 {} \\;\n\nfind /usr/lib64/  -type f ! -uid 0 -regextype posix-extended -regex '^.*$' -exec chown -L 0 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238349",
        "stig_id": "UBTU-20-010428"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_audit_binaries": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_audit_binaries",
        "title": "Verify that audit tools Have Mode 0755 or less",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001493",
              "CCI-001494"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000256-GPOS-00097",
              "SRG-OS-000257-GPOS-00098"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010199"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238300r654075_rule"
            ]
          }
        ],
        "description": "The Ubuntu 20.04 operating system audit tools must have the proper\npermissions configured to protected against unauthorized access.\n\nVerify it by running the following command:\n<pre>$ stat -c &quot;%n %a&quot; /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/audispd /sbin/augenrules\n\n/sbin/auditctl 755\n/sbin/aureport 755\n/sbin/ausearch 755\n/sbin/autrace 755\n/sbin/auditd 755\n/sbin/audispd 755\n/sbin/augenrules 755\n</pre>\n\nAudit tools needed to successfully view and manipulate audit information\nsystem activity and records. Audit tools include custom queries and report\ngenerators",
        "rationale": "Protecting audit information also includes identifying and protecting the\ntools used to view and manipulate log data. Therefore, protecting audit\ntools is necessary to prevent unauthorized operation on audit information.\n\nOperating systems providing tools to interface with audit information\nwill leverage user permissions and roles identifying the user accessing the\ntools and the corresponding rights the user enjoys to make access decisions\nregarding the access to audit tools.",
        "oval_definition_id": "oval:ssg-file_permissions_audit_binaries:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_audit_binaries",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Test for existence /sbin/auditctl\n  stat:\n    path: /sbin/auditctl\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/auditctl\n  file:\n    path: /sbin/auditctl\n    mode: u-s,g-ws,o-wt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/aureport\n  stat:\n    path: /sbin/aureport\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/aureport\n  file:\n    path: /sbin/aureport\n    mode: u-s,g-ws,o-wt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/ausearch\n  stat:\n    path: /sbin/ausearch\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/ausearch\n  file:\n    path: /sbin/ausearch\n    mode: u-s,g-ws,o-wt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/autrace\n  stat:\n    path: /sbin/autrace\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/autrace\n  file:\n    path: /sbin/autrace\n    mode: u-s,g-ws,o-wt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/auditd\n  stat:\n    path: /sbin/auditd\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/auditd\n  file:\n    path: /sbin/auditd\n    mode: u-s,g-ws,o-wt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/audispd\n  stat:\n    path: /sbin/audispd\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/audispd\n  file:\n    path: /sbin/audispd\n    mode: u-s,g-ws,o-wt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Test for existence /sbin/augenrules\n  stat:\n    path: /sbin/augenrules\n  register: file_exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-s,g-ws,o-wt on /sbin/augenrules\n  file:\n    path: /sbin/augenrules\n    mode: u-s,g-ws,o-wt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010199\n  - configure_strategy\n  - file_permissions_audit_binaries\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_permissions_audit_binaries",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nchmod u-s,g-ws,o-wt /sbin/auditctl\n\nchmod u-s,g-ws,o-wt /sbin/aureport\n\nchmod u-s,g-ws,o-wt /sbin/ausearch\n\nchmod u-s,g-ws,o-wt /sbin/autrace\n\nchmod u-s,g-ws,o-wt /sbin/auditd\n\nchmod u-s,g-ws,o-wt /sbin/audispd\n\nchmod u-s,g-ws,o-wt /sbin/augenrules\n"
          }
        ],
        "vuln_id": "SV-238300",
        "stig_id": "UBTU-20-010199"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_binary_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_binary_dirs",
        "title": "Verify that System Executables Have Restrictive Permissions",
        "result": "pass",
        "time": "2025-03-28T16:15:42+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R50"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-5(6)",
              "CM-5(6).1",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010456"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238376r654303_rule"
            ]
          }
        ],
        "description": "System executables are stored in the following directories by default:\n<pre>/bin\n/sbin\n/usr/bin\n/usr/libexec\n/usr/local/bin\n/usr/local/sbin\n/usr/sbin</pre>\nAll files in these directories should not be group-writable or world-writable.\nIf any file <i>FILE</i> in these directories is found\nto be group-writable or world-writable, correct its permission with the\nfollowing command:\n<pre>$ sudo chmod go-w <i>FILE</i>\n         </pre>\n        ",
        "rationale": "System binaries are executed by privileged users, as well as system services,\nand restrictive permissions are necessary to ensure execution of these programs\ncannot be co-opted.",
        "oval_definition_id": "oval:ssg-file_permissions_binary_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_binary_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "DIRS=\"/bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin /usr/libexec\"\nfor dirPath in $DIRS; do\n\tfind \"$dirPath\" -perm /022 -exec chmod go-w '{}' \\;\ndone\n"
          }
        ],
        "vuln_id": "SV-238376",
        "stig_id": "UBTU-20-010456"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_library_dirs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_library_dirs",
        "title": "Verify that Shared Library Files Have Restrictive Permissions",
        "result": "pass",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.7.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "CM-5(6)",
              "CM-5(6).1",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010426"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238347r654216_rule"
            ]
          }
        ],
        "description": "System-wide shared library files, which are linked to executables\nduring process load time or run time, are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nKernel modules, which can be added to the kernel during runtime, are\nstored in <code>/lib/modules</code>. All files in these directories\nshould not be group-writable or world-writable. If any file in these\ndirectories is found to be group-writable or world-writable, correct\nits permission with the following command:\n<pre>$ sudo chmod go-w <i>FILE</i>\n         </pre>\n        ",
        "rationale": "Files from shared library directories are loaded into the address\nspace of processes (including privileged ones) or of the kernel itself at\nruntime. Restrictive permissions are necessary to protect the integrity of the system.",
        "oval_definition_id": "oval:ssg-file_permissions_library_dirs:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_library_dirs",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /lib/ file(s) recursively\n  command: find -H /lib/  -perm /g+w,o+w  -type f -regextype posix-extended -regex\n    \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /lib/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /lib64/ file(s) recursively\n  command: find -H /lib64/  -perm /g+w,o+w  -type f -regextype posix-extended -regex\n    \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /lib64/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib/ file(s) recursively\n  command: find -H /usr/lib/  -perm /g+w,o+w  -type f -regextype posix-extended -regex\n    \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/lib/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /usr/lib64/ file(s) recursively\n  command: find -H /usr/lib64/  -perm /g+w,o+w  -type f -regextype posix-extended\n    -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set permissions for /usr/lib64/ file(s)\n  file:\n    path: '{{ item }}'\n    mode: g-w,o-w\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010426\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - NIST-800-53-CM-6(a)\n  - configure_strategy\n  - file_permissions_library_dirs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_permissions_library_dirs",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\n\n\n\n\nfind -H /lib/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n\nfind -H /lib64/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n\nfind -H /usr/lib/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n\nfind -H /usr/lib64/  -perm /g+w,o+w  -type f -regextype posix-extended -regex '^.*$' -exec chmod g-w,o-w {} \\;\n"
          }
        ],
        "vuln_id": "SV-238347",
        "stig_id": "UBTU-20-010426"
      },
      "xccdf_org.ssgproject.content_rule_root_permissions_syslibrary_files": {
        "rule_id": "xccdf_org.ssgproject.content_rule_root_permissions_syslibrary_files",
        "title": "Verify the system-wide library files in directories\n\"/lib\", \"/lib64\", \"/usr/lib/\" and \"/usr/lib64\" are group-owned by root.",
        "result": "pass",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001499"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-5(6)",
              "CM-5(6).1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000259-GPOS-00100"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010430"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238351r832962_rule"
            ]
          }
        ],
        "description": "System-wide library files are stored in the following directories\nby default:\n<pre>/lib\n/lib64\n/usr/lib\n/usr/lib64\n</pre>\nAll system-wide shared library files should be protected from unauthorised\naccess. If any of these files is not group-owned by root, correct its group-owner with\nthe following command:\n<pre>$ sudo chgrp root <i>FILE</i>\n         </pre>\n        ",
        "rationale": "If the operating system were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate testing and\napprovals that are part of a robust change management process.\n\nThis requirement applies to operating systems with software libraries that are\naccessible and configurable, as in the case of interpreted languages. Software libraries\nalso include privileged programs which execute with escalated privileges. Only qualified\nand authorized individuals must be allowed to obtain access to information system components\nfor purposes of initiating changes, including upgrades and modifications.",
        "oval_definition_id": "oval:ssg-root_permissions_syslibrary_files:def:1",
        "remediations": [
          {
            "remediation_id": "root_permissions_syslibrary_files",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Find /lib/ file(s) matching ^.*$ recursively\n  command: find -H /lib/  -type f ! -group 0 -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n\n- name: Ensure group owner on /lib/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    group: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n\n- name: Find /lib64/ file(s) matching ^.*$ recursively\n  command: find -H /lib64/  -type f ! -group 0 -regextype posix-extended -regex \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n\n- name: Ensure group owner on /lib64/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    group: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n\n- name: Find /usr/lib/ file(s) matching ^.*$ recursively\n  command: find -H /usr/lib/  -type f ! -group 0 -regextype posix-extended -regex\n    \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n\n- name: Ensure group owner on /usr/lib/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    group: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n\n- name: Find /usr/lib64/ file(s) matching ^.*$ recursively\n  command: find -H /usr/lib64/  -type f ! -group 0 -regextype posix-extended -regex\n    \"^.*$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n\n- name: Ensure group owner on /usr/lib64/ file(s) matching ^.*$\n  file:\n    path: '{{ item }}'\n    group: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  tags:\n  - DISA-STIG-UBTU-20-010430\n  - NIST-800-53-CM-5(6)\n  - NIST-800-53-CM-5(6).1\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - root_permissions_syslibrary_files\n"
          },
          {
            "remediation_id": "root_permissions_syslibrary_files",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "\nfind /lib/  -type f ! -group 0 -regextype posix-extended -regex '^.*$' -exec chgrp -L 0 {} \\;\n\nfind /lib64/  -type f ! -group 0 -regextype posix-extended -regex '^.*$' -exec chgrp -L 0 {} \\;\n\nfind /usr/lib/  -type f ! -group 0 -regextype posix-extended -regex '^.*$' -exec chgrp -L 0 {} \\;\n\nfind /usr/lib64/  -type f ! -group 0 -regextype posix-extended -regex '^.*$' -exec chgrp -L 0 {} \\;\n"
          }
        ],
        "vuln_id": "SV-238351",
        "stig_id": "UBTU-20-010430"
      },
      "xccdf_org.ssgproject.content_rule_kernel_module_usb-storage_disabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_kernel_module_usb-storage_disabled",
        "title": "Disable Modprobe Loading of USB Storage Driver",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000141-CTR-000315"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.1.24"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "DSS01.04",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.21"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366",
              "CCI-000778",
              "CCI-001958"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(3)(i)",
              "164.308(a)(3)(ii)(A)",
              "164.310(d)(1)",
              "164.310(d)(2)",
              "164.312(a)(1)",
              "164.312(a)(2)(iv)",
              "164.312(b)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.13.1.1",
              "A.13.2.1",
              "A.18.1.4",
              "A.6.2.1",
              "A.6.2.2",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)",
              "MP-7"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-3",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000114-GPOS-00059",
              "SRG-OS-000378-GPOS-00163",
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "3.4.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010461"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-251505r853450_rule"
            ]
          }
        ],
        "description": "To prevent USB storage devices from being used, configure the kernel module loading system\nto prevent automatic loading of the USB storage driver.\n\nTo configure the system to prevent the <code>usb-storage</code>\nkernel module from being loaded, add the following line to the file <code>/etc/modprobe.d/usb-storage.conf</code>:\n<pre>install usb-storage /bin/false</pre>\n\nThis will prevent the <code>modprobe</code> program from loading the <code>usb-storage</code>\nmodule, but will not prevent an administrator (or another program) from using the\n<code>insmod</code> program to load the module manually.",
        "rationale": "USB storage devices such as thumb drives can be used to introduce\nmalicious software.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-kernel_module_usb-storage_disabled:def:1",
        "remediations": [
          {
            "remediation_id": "kernel_module_usb-storage_disabled",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "- name: Ensure kernel module 'usb-storage' is disabled\n  lineinfile:\n    create: true\n    dest: /etc/modprobe.d/usb-storage.conf\n    regexp: install\\s+usb-storage\n    line: install usb-storage /bin/false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010461\n  - NIST-800-171-3.1.21\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSSv4-3.4.2\n  - disable_strategy\n  - kernel_module_usb-storage_disabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n\n- name: Ensure kernel module 'usb-storage' is blacklisted\n  lineinfile:\n    create: true\n    dest: /etc/modprobe.d/usb-storage.conf\n    regexp: ^blacklist usb-storage$\n    line: blacklist usb-storage\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010461\n  - NIST-800-171-3.1.21\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-MP-7\n  - PCI-DSSv4-3.4.2\n  - disable_strategy\n  - kernel_module_usb-storage_disabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n"
          },
          {
            "remediation_id": "kernel_module_usb-storage_disabled",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif LC_ALL=C grep -q -m 1 \"^install usb-storage\" /etc/modprobe.d/usb-storage.conf ; then\n\t\n\tsed -i 's#^install usb-storage.*#install usb-storage /bin/false#g' /etc/modprobe.d/usb-storage.conf\nelse\n\techo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/usb-storage.conf\n\techo \"install usb-storage /bin/false\" >> /etc/modprobe.d/usb-storage.conf\nfi\n\nif ! LC_ALL=C grep -q -m 1 \"^blacklist usb-storage$\" /etc/modprobe.d/usb-storage.conf ; then\n\techo \"blacklist usb-storage\" >> /etc/modprobe.d/usb-storage.conf\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-251505",
        "stig_id": "UBTU-20-010461"
      },
      "xccdf_org.ssgproject.content_rule_sysctl_kernel_dmesg_restrict": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_dmesg_restrict",
        "title": "Restrict Access to Kernel Message Buffer",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "low",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R9"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000243-CTR-000600"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001090",
              "CCI-001314"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)",
              "164.308(a)(4)",
              "164.310(b)",
              "164.310(c)",
              "164.312(a)",
              "164.312(e)"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "SI-11(a)",
              "SI-11(b)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000132-GPOS-00067",
              "SRG-OS-000138-GPOS-00069"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010401"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-255913r880908_rule"
            ]
          }
        ],
        "description": "To set the runtime status of the <code>kernel.dmesg_restrict</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.dmesg_restrict=1</pre>\nTo make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>kernel.dmesg_restrict = 1</pre>\n       ",
        "rationale": "Unprivileged access to the kernel syslog can expose sensitive kernel\naddress information.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-sysctl_kernel_dmesg_restrict:def:1",
        "remediations": [
          {
            "remediation_id": "sysctl_kernel_dmesg_restrict",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "- name: List /etc/sysctl.d/*.conf files\n  find:\n    paths:\n    - /etc/sysctl.d/\n    - /run/sysctl.d/\n    - /usr/local/lib/sysctl.d/\n    contains: ^[\\s]*kernel.dmesg_restrict.*$\n    patterns: '*.conf'\n    file_type: any\n  register: find_sysctl_d\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010401\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n\n- name: Comment out any occurrences of kernel.dmesg_restrict from config files\n  replace:\n    path: '{{ item.path }}'\n    regexp: ^[\\s]*kernel.dmesg_restrict\n    replace: '#kernel.dmesg_restrict'\n  loop: '{{ find_sysctl_d.files }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010401\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n\n- name: Ensure sysctl kernel.dmesg_restrict is set to 1\n  sysctl:\n    name: kernel.dmesg_restrict\n    value: '1'\n    sysctl_file: /etc/sysctl.conf\n    state: present\n    reload: true\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010401\n  - NIST-800-171-3.1.5\n  - NIST-800-53-SI-11(a)\n  - NIST-800-53-SI-11(b)\n  - disable_strategy\n  - low_complexity\n  - low_severity\n  - medium_disruption\n  - reboot_required\n  - sysctl_kernel_dmesg_restrict\n"
          },
          {
            "remediation_id": "sysctl_kernel_dmesg_restrict",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\n# Comment out any occurrences of kernel.dmesg_restrict from /etc/sysctl.d/*.conf files\n\nfor f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do\n\n\n  # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf)\n  if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi\n\n  matching_list=$(grep -P '^(?!#).*[\\s]*kernel.dmesg_restrict.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\")\n      # comment out \"kernel.dmesg_restrict\" matches to preserve user data\n      sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n  fi\ndone\n\n#\n# Set sysctl config file which to save the desired value\n#\n\nSYSCONFIG_FILE=\"/etc/sysctl.conf\"\n\n\n#\n# Set runtime for kernel.dmesg_restrict\n#\n/sbin/sysctl -q -n -w kernel.dmesg_restrict=\"1\"\n\n#\n# If kernel.dmesg_restrict present in /etc/sysctl.conf, change value to \"1\"\n#\telse, add \"kernel.dmesg_restrict = 1\" to /etc/sysctl.conf\n#\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^kernel.dmesg_restrict\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^kernel.dmesg_restrict\\\\>\" \"${SYSCONFIG_FILE}\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^kernel.dmesg_restrict\\\\>.*/$escaped_formatted_output/gi\" \"${SYSCONFIG_FILE}\"\nelse\n    if [[ -s \"${SYSCONFIG_FILE}\" ]] && [[ -n \"$(tail -c 1 -- \"${SYSCONFIG_FILE}\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"${SYSCONFIG_FILE}\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"${SYSCONFIG_FILE}\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-255913",
        "stig_id": "UBTU-20-010401"
      },
      "xccdf_org.ssgproject.content_rule_sysctl_kernel_randomize_va_space": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_randomize_va_space",
        "title": "Enable Randomized Layout of Virtual Address Space",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R9"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000450-CTR-001105"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "1.6.2"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366",
              "CCI-002824"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)",
              "164.308(a)(4)",
              "164.310(b)",
              "164.310(c)",
              "164.312(a)",
              "164.312(e)"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-002-5 R1.1",
              "CIP-002-5 R1.2",
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 4.1",
              "CIP-004-6 4.2",
              "CIP-004-6 R2.2.3",
              "CIP-004-6 R2.2.4",
              "CIP-004-6 R2.3",
              "CIP-004-6 R4",
              "CIP-005-6 R1",
              "CIP-005-6 R1.1",
              "CIP-005-6 R1.2",
              "CIP-007-3 R3",
              "CIP-007-3 R3.1",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.2",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3",
              "CIP-007-3 R8.4",
              "CIP-009-6 R.1.1",
              "CIP-009-6 R4"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "SC-30",
              "SC-30(2)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000433-GPOS-00193",
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-2.2.1"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "3.3.1.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010448"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238369r853446_rule"
            ]
          }
        ],
        "description": "To set the runtime status of the <code>kernel.randomize_va_space</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w kernel.randomize_va_space=2</pre>\nTo make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>kernel.randomize_va_space = 2</pre>\n        ",
        "rationale": "Address space layout randomization (ASLR) makes it more difficult for an\nattacker to predict the location of attack code they have introduced into a\nprocess&#x27;s address space during an attempt at exploitation. Additionally,\nASLR makes it more difficult for an attacker to know the location of\nexisting code in order to re-purpose it using return oriented programming\n(ROP) techniques.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-sysctl_kernel_randomize_va_space:def:1",
        "remediations": [
          {
            "remediation_id": "sysctl_kernel_randomize_va_space",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "- name: List /etc/sysctl.d/*.conf files\n  find:\n    paths:\n    - /etc/sysctl.d/\n    - /run/sysctl.d/\n    - /usr/local/lib/sysctl.d/\n    contains: ^[\\s]*kernel.randomize_va_space.*$\n    patterns: '*.conf'\n    file_type: any\n  register: find_sysctl_d\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010448\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n\n- name: Comment out any occurrences of kernel.randomize_va_space from config files\n  replace:\n    path: '{{ item.path }}'\n    regexp: ^[\\s]*kernel.randomize_va_space\n    replace: '#kernel.randomize_va_space'\n  loop: '{{ find_sysctl_d.files }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010448\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n\n- name: Ensure sysctl kernel.randomize_va_space is set to 2\n  sysctl:\n    name: kernel.randomize_va_space\n    value: '2'\n    sysctl_file: /etc/sysctl.conf\n    state: present\n    reload: true\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010448\n  - NIST-800-171-3.1.7\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-30\n  - NIST-800-53-SC-30(2)\n  - PCI-DSS-Req-2.2.1\n  - PCI-DSSv4-3.3.1.1\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n  - sysctl_kernel_randomize_va_space\n"
          },
          {
            "remediation_id": "sysctl_kernel_randomize_va_space",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\n# Comment out any occurrences of kernel.randomize_va_space from /etc/sysctl.d/*.conf files\n\nfor f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do\n\n\n  # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf)\n  if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi\n\n  matching_list=$(grep -P '^(?!#).*[\\s]*kernel.randomize_va_space.*$' $f | uniq )\n  if ! test -z \"$matching_list\"; then\n    while IFS= read -r entry; do\n      escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\")\n      # comment out \"kernel.randomize_va_space\" matches to preserve user data\n      sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f\n    done <<< \"$matching_list\"\n  fi\ndone\n\n#\n# Set sysctl config file which to save the desired value\n#\n\nSYSCONFIG_FILE=\"/etc/sysctl.conf\"\n\n\n#\n# Set runtime for kernel.randomize_va_space\n#\n/sbin/sysctl -q -n -w kernel.randomize_va_space=\"2\"\n\n#\n# If kernel.randomize_va_space present in /etc/sysctl.conf, change value to \"2\"\n#\telse, add \"kernel.randomize_va_space = 2\" to /etc/sysctl.conf\n#\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^kernel.randomize_va_space\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"2\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^kernel.randomize_va_space\\\\>\" \"${SYSCONFIG_FILE}\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^kernel.randomize_va_space\\\\>.*/$escaped_formatted_output/gi\" \"${SYSCONFIG_FILE}\"\nelse\n    if [[ -s \"${SYSCONFIG_FILE}\" ]] && [[ -n \"$(tail -c 1 -- \"${SYSCONFIG_FILE}\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"${SYSCONFIG_FILE}\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"${SYSCONFIG_FILE}\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238369",
        "stig_id": "UBTU-20-010448"
      },
      "xccdf_org.ssgproject.content_rule_bios_enable_execution_restrictions": {
        "rule_id": "xccdf_org.ssgproject.content_rule_bios_enable_execution_restrictions",
        "title": "Enable NX or XD Support in the BIOS",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000450-CTR-001105"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "3",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002824"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "SC-39"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.IP-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000433-GPOS-00192"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010447"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238368r880910_rule"
            ]
          }
        ],
        "description": "Reboot the system and enter the BIOS or Setup configuration menu.\nNavigate the BIOS configuration menu and make sure that the option is enabled. The setting may be located\nunder a Security section. Look for Execute Disable (XD) on Intel-based systems and No Execute (NX)\non AMD-based systems.",
        "rationale": "Computers with the ability to prevent this type of code execution frequently put an option in the BIOS that will\nallow users to turn the feature on or off at will.",
        "platforms": [
          "#not_aarch64_arch_and_machine_and_not_ppc64le_arch"
        ],
        "oval_definition_id": "oval:ssg-bios_enable_execution_restrictions:def:1",
        "vuln_id": "SV-238368",
        "stig_id": "UBTU-20-010447"
      },
      "xccdf_org.ssgproject.content_rule_apt_conf_disallow_unauthenticated": {
        "rule_id": "xccdf_org.ssgproject.content_rule_apt_conf_disallow_unauthenticated",
        "title": "Disable unauthenticated repositories in APT configuration",
        "result": "pass",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "unknown",
        "weight": 1,
        "references": [
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010438"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238359r877463_rule"
            ]
          }
        ],
        "description": "Unauthenticated repositories should not be used for updates.",
        "rationale": "Repositories hosts all packages that will be intsalled on the system during update.\n    If a repository is not authenticated, the associated packages can&#x27;t be trusted,\n    and then should not be installed localy.",
        "oval_definition_id": "oval:ssg-apt_conf_disallow_unauthenticated:def:1",
        "vuln_id": "SV-238359",
        "stig_id": "UBTU-20-010438"
      },
      "xccdf_org.ssgproject.content_rule_service_kdump_disabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_service_kdump_disabled",
        "title": "Disable KDump Kernel Crash Analyzer (kdump)",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "12",
              "14",
              "15",
              "3",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS01.04",
              "DSS05.02",
              "DSS05.03",
              "DSS05.05",
              "DSS06.06"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366",
              "CCI-001665"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)",
              "164.308(a)(4)",
              "164.310(b)",
              "164.310(c)",
              "164.312(a)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.3",
              "4.3.3.5.4",
              "4.3.3.5.5",
              "4.3.3.5.6",
              "4.3.3.5.7",
              "4.3.3.5.8",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.1",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.11",
              "SR 1.12",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.6",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.2",
              "SR 2.3",
              "SR 2.4",
              "SR 2.5",
              "SR 2.6",
              "SR 2.7",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.6.2.1",
              "A.6.2.2",
              "A.9.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-3",
              "PR.IP-1",
              "PR.PT-3",
              "PR.PT-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000269-GPOS-00103",
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_SMF_EXT.1.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010413"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238334r654177_rule"
            ]
          }
        ],
        "description": "The <code>kdump-tools</code> service provides a kernel crash dump analyzer. It uses the <code>kexec</code>\nsystem call to boot a secondary kernel (&quot;capture&quot; kernel) following a system\ncrash, which can load information from the crashed kernel for analysis.\n\nThe <code>kdump-tools</code> service can be disabled with the following command:\n<pre>$ sudo systemctl mask --now kdump-tools.service</pre>\n      ",
        "rationale": "Kernel core dumps may contain the full contents of system memory at the\ntime of the crash. Kernel core dumps consume a considerable amount of disk\nspace and may result in denial of service by exhausting the available space\non the target file system partition. Unless the system is used for kernel\ndevelopment or testing, there is little need to run the kdump service.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-service_kdump_disabled:def:1",
        "remediations": [
          {
            "remediation_id": "service_kdump_disabled",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "- name: Disable KDump Kernel Crash Analyzer (kdump) - Collect systemd Services Present\n    in the System\n  ansible.builtin.command: systemctl -q list-unit-files --type service\n  register: service_exists\n  changed_when: false\n  failed_when: service_exists.rc not in [0, 1]\n  check_mode: false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010413\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_kdump_disabled\n\n- name: Disable KDump Kernel Crash Analyzer (kdump) - Ensure kdump-tools.service is\n    Masked\n  ansible.builtin.systemd:\n    name: kdump-tools.service\n    state: stopped\n    enabled: false\n    masked: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - service_exists.stdout_lines is search(\"kdump-tools.service\", multiline=True)\n  tags:\n  - DISA-STIG-UBTU-20-010413\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_kdump_disabled\n\n- name: Unit Socket Exists - kdump-tools.socket\n  ansible.builtin.command: systemctl -q list-unit-files kdump-tools.socket\n  register: socket_file_exists\n  changed_when: false\n  failed_when: socket_file_exists.rc not in [0, 1]\n  check_mode: false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010413\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_kdump_disabled\n\n- name: Disable KDump Kernel Crash Analyzer (kdump) - Disable Socket kdump-tools\n  ansible.builtin.systemd:\n    name: kdump-tools.socket\n    enabled: false\n    state: stopped\n    masked: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - socket_file_exists.stdout_lines is search(\"kdump-tools.socket\", multiline=True)\n  tags:\n  - DISA-STIG-UBTU-20-010413\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_kdump_disabled\n"
          },
          {
            "remediation_id": "service_kdump_disabled",
            "system": "urn:xccdf:fix:script:kubernetes",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "disable",
            "fix": "apiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    systemd:\n      units:\n      - name: kdump-tools.service\n        enabled: false\n        mask: true\n      - name: kdump-tools.socket\n        enabled: false\n        mask: true\n"
          },
          {
            "remediation_id": "service_kdump_disabled",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include disable_kdump-tools\n\nclass disable_kdump-tools {\n  service {'kdump-tools':\n    enable => false,\n    ensure => 'stopped',\n  }\n}\n"
          },
          {
            "remediation_id": "service_kdump_disabled",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[customizations.services]\nmasked = [\"kdump-tools\"]\n"
          },
          {
            "remediation_id": "service_kdump_disabled",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" stop 'kdump-tools.service'\n\"$SYSTEMCTL_EXEC\" disable 'kdump-tools.service'\n\"$SYSTEMCTL_EXEC\" mask 'kdump-tools.service'\n# Disable socket activation if we have a unit file for it\nif \"$SYSTEMCTL_EXEC\" -q list-unit-files kdump-tools.socket; then\n    \"$SYSTEMCTL_EXEC\" stop 'kdump-tools.socket'\n    \"$SYSTEMCTL_EXEC\" mask 'kdump-tools.socket'\nfi\n# The service may not be running because it has been started and failed,\n# so let's reset the state so OVAL checks pass.\n# Service should be 'inactive', not 'failed' after reboot though.\n\"$SYSTEMCTL_EXEC\" reset-failed 'kdump-tools.service' || true\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238334",
        "stig_id": "UBTU-20-010413"
      },
      "xccdf_org.ssgproject.content_rule_package_telnetd_removed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_telnetd_removed",
        "title": "Uninstall the telnet server",
        "result": "pass",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "12",
              "14",
              "15",
              "3",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS01.04",
              "DSS05.02",
              "DSS05.03",
              "DSS05.05",
              "DSS06.06"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.3",
              "4.3.3.5.4",
              "4.3.3.5.5",
              "4.3.3.5.6",
              "4.3.3.5.7",
              "4.3.3.5.8",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.1",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.11",
              "SR 1.12",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.6",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.2",
              "SR 2.3",
              "SR 2.4",
              "SR 2.5",
              "SR 2.6",
              "SR 2.7",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.6.2.1",
              "A.6.2.2",
              "A.9.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-3",
              "PR.IP-1",
              "PR.PT-3",
              "PR.PT-4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010405"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238326r877396_rule"
            ]
          }
        ],
        "description": "The telnet daemon should be uninstalled.",
        "rationale": "<code>telnet</code> allows clear text communications, and does not protect\nany data transmission between client and server. Any confidential data\ncan be listened and no integrity checking is made.&#x27;",
        "oval_definition_id": "oval:ssg-package_telnetd_removed:def:1",
        "remediations": [
          {
            "remediation_id": "package_telnetd_removed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "- name: Ensure telnetd is removed\n  package:\n    name: telnetd\n    state: absent\n  tags:\n  - DISA-STIG-UBTU-20-010405\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - package_telnetd_removed\n"
          },
          {
            "remediation_id": "package_telnetd_removed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "include remove_telnetd\n\nclass remove_telnetd {\n  package { 'telnetd':\n    ensure => 'purged',\n  }\n}\n"
          },
          {
            "remediation_id": "package_telnetd_removed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "\n# CAUTION: This remediation script will remove telnetd\n#\t   from the system, and may remove any packages\n#\t   that depend on telnetd. Execute this\n#\t   remediation AFTER testing on a non-production\n#\t   system!\n\nDEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnetd\"\n"
          }
        ],
        "vuln_id": "SV-238326",
        "stig_id": "UBTU-20-010405"
      },
      "xccdf_org.ssgproject.content_rule_package_chrony_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_chrony_installed",
        "title": "The Chrony package is installed",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R71"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "2.2.1.1"
            ]
          },
          {
            "name": "ism",
            "href": "https://www.cyber.gov.au/acsc/view-all-content/ism",
            "ref_ids": [
              "0988",
              "1405"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000355-GPOS-00143"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FMT_SMF_EXT.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.4"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.6.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010435"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238356r877038_rule"
            ]
          }
        ],
        "description": "System time should be synchronized between all systems in an environment. This is\ntypically done by establishing an authoritative time server or set of servers and having all\nsystems synchronize their clocks to them.\nThe <code>chrony</code> package can be installed with the following command:\n<pre>\n$ apt-get install chrony</pre>\n      ",
        "rationale": "Time synchronization is important to support time sensitive security mechanisms like\nKerberos and also ensures log files have consistent time records across the enterprise,\nwhich aids in forensic investigations.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-package_chrony_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_chrony_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure chrony is installed\n  package:\n    name: chrony\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - PCI-DSS-Req-10.4\n  - PCI-DSSv4-10.6.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_chrony_installed\n"
          },
          {
            "remediation_id": "package_chrony_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_chrony\n\nclass install_chrony {\n  package { 'chrony':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_chrony_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"chrony\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_chrony_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"chrony\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238356",
        "stig_id": "UBTU-20-010435"
      },
      "xccdf_org.ssgproject.content_rule_chronyd_or_ntpd_set_maxpoll": {
        "rule_id": "xccdf_org.ssgproject.content_rule_chronyd_or_ntpd_set_maxpoll",
        "title": "Configure Time Service Maxpoll Interval",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "14",
              "15",
              "16",
              "3",
              "5",
              "6"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO11.04",
              "BAI03.05",
              "DSS05.04",
              "DSS05.07",
              "MEA02.01"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001891",
              "CCI-002046"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(1)",
              "AU-8(1)(b)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000355-GPOS-00143",
              "SRG-OS-000356-GPOS-00144",
              "SRG-OS-000359-GPOS-00146"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010435"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238356r877038_rule"
            ]
          }
        ],
        "description": "The <code>maxpoll</code> should be configured to\n17 in <code>/etc/ntp.conf</code> or\n<code>/etc/chrony/chrony.conf</code> (or <code>/etc/chrony/conf.d/</code>) to continuously poll time servers. To configure\n<code>maxpoll</code> in <code>/etc/ntp.conf</code> or <code>/etc/chrony/chrony.conf</code> (or <code>/etc/chrony/conf.d/</code>)\nadd the following after each <code>server</code>, <code>pool</code> or <code>peer</code> entry:\n<pre>maxpoll 17\n       </pre>\nto <code>server</code> directives. If using chrony, any <code>pool</code> directives\nshould be configured too.",
        "rationale": "Inaccurate time stamps make it more difficult to correlate events and can lead to an inaccurate analysis. Determining the correct time a particular event occurred on a system is critical when conducting forensic analysis and investigating system events. Sources outside the configured acceptable allowance (drift) may be inaccurate.\nSynchronizing internal information system clocks provides uniformity of time stamps for information systems with multiple system clocks and systems connected over a network.\nOrganizations should consider endpoints that may not have regular access to the authoritative time server (e.g., mobile, teleworking, and tactical endpoints).",
        "platforms": [
          "#package_chrony_or_package_ntp"
        ],
        "oval_definition_id": "oval:ssg-chronyd_or_ntpd_set_maxpoll:def:1",
        "remediations": [
          {
            "remediation_id": "chronyd_or_ntpd_set_maxpoll",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_time_service_set_maxpoll # promote to variable\n  set_fact:\n    var_time_service_set_maxpoll: !!str 17\n  tags:\n    - always\n\n- name: Configure Time Service Maxpoll Interval - Check That /etc/ntp.conf Exist\n  ansible.builtin.stat:\n    path: /etc/ntp.conf\n  register: ntp_conf_exist_result\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Update the maxpoll Values in /etc/ntp.conf\n  ansible.builtin.replace:\n    path: /etc/ntp.conf\n    regexp: ^(server.*maxpoll)[ ]+[0-9]+(.*)$\n    replace: \\1 {{ var_time_service_set_maxpoll }}\\2\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - ntp_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Set the maxpoll Values in /etc/ntp.conf\n  ansible.builtin.replace:\n    path: /etc/ntp.conf\n    regexp: (^server\\s+((?!maxpoll).)*)$\n    replace: \\1 maxpoll {{ var_time_service_set_maxpoll }}\\n\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - ntp_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Check That /etc/chrony/chrony.conf\n    Exist\n  ansible.builtin.stat:\n    path: /etc/chrony/chrony.conf\n  register: chrony_conf_exist_result\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Update the maxpoll Values in /etc/chrony/chrony.conf\n  ansible.builtin.replace:\n    path: /etc/chrony/chrony.conf\n    regexp: ^((?:server|pool|peer).*maxpoll)[ ]+[0-9]+(.*)$\n    replace: \\1 {{ var_time_service_set_maxpoll }}\\2\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Set the maxpoll Values in /etc/chrony/chrony.conf\n  ansible.builtin.replace:\n    path: /etc/chrony/chrony.conf\n    regexp: (^(?:server|pool|peer)\\s+((?!maxpoll).)*)$\n    replace: \\1 maxpoll {{ var_time_service_set_maxpoll }}\\n\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_conf_exist_result.stat.exists\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Get Conf Files from /etc/chrony/conf.d/\n  ansible.builtin.find:\n    path: /etc/chrony/conf.d/\n    patterns: '*.conf'\n    file_type: file\n  register: chrony_d_conf_files\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Update the maxpoll Values in /etc/chrony/conf.d/\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: ^((?:server|pool|peer).*maxpoll)[ ]+[0-9]+(.*)$\n    replace: \\1 {{ var_time_service_set_maxpoll }}\\2\n  loop: '{{ chrony_d_conf_files.files }}'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_d_conf_files.matched\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Time Service Maxpoll Interval - Set the maxpoll Values in /etc/chrony/conf.d/\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: (^(?:server|pool|peer)\\s+((?!maxpoll).)*)$\n    replace: \\1 maxpoll {{ var_time_service_set_maxpoll }}\\n\n  loop: '{{ chrony_d_conf_files.files }}'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ( \"chrony\" in ansible_facts.packages or \"ntp\" in ansible_facts.packages )\n  - chrony_d_conf_files.matched\n  tags:\n  - DISA-STIG-UBTU-20-010435\n  - NIST-800-53-AU-12(1)\n  - NIST-800-53-AU-8(1)(b)\n  - NIST-800-53-CM-6(a)\n  - chronyd_or_ntpd_set_maxpoll\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "chronyd_or_ntpd_set_maxpoll",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { ( dpkg-query --show --showformat='${db:Status-Status}\\n' 'chrony' 2>/dev/null | grep -q installed || dpkg-query --show --showformat='${db:Status-Status}\\n' 'ntp' 2>/dev/null | grep -q installed ); }; then\n\nvar_time_service_set_maxpoll='17'\n\n\n\n\npof=\"/bin/pidof\"\n\n\nCONFIG_FILES=\"/etc/ntp.conf\"\n$pof ntpd || {\n    CHRONY_D_PATH=/etc/chrony/conf.d/\n    mapfile -t CONFIG_FILES < <(find ${CHRONY_D_PATH}.* -type f -name '*.conf')\n    CONFIG_FILES+=(/etc/chrony/chrony.conf)\n}\n\n# get list of ntp files\n\nfor config_file in \"${CONFIG_FILES[@]}\" ; do\n    # Set maxpoll values to var_time_service_set_maxpoll\n    sed -i \"s/^\\(\\(server\\|pool\\|peer\\).*maxpoll\\) [0-9][0-9]*\\(.*\\)$/\\1 $var_time_service_set_maxpoll \\3/\" \"$config_file\"\ndone\n\nfor config_file in \"${CONFIG_FILES[@]}\" ; do\n    # Add maxpoll to server, pool or peer entries without maxpoll\n    grep \"^\\(server\\|pool\\|peer\\)\" \"$config_file\" | grep -v maxpoll | while read -r line ; do\n        sed -i \"s/$line/& maxpoll $var_time_service_set_maxpoll/\" \"$config_file\"\n    done\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238356",
        "stig_id": "UBTU-20-010435"
      },
      "xccdf_org.ssgproject.content_rule_chronyd_sync_clock": {
        "rule_id": "xccdf_org.ssgproject.content_rule_chronyd_sync_clock",
        "title": "Synchronize internal information system clocks",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002046"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000356-GPOS-00144"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010436"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238357r853432_rule"
            ]
          }
        ],
        "description": "Synchronizing internal information system clocks provides uniformity\nof time stamps for information systems with multiple system clocks and\nsystems connected over a network.",
        "rationale": "Inaccurate time stamps make it more difficult to correlate events and\ncan lead to an inaccurate analysis. Determining the correct time a\nparticular event occurred on a system is critical when conducting\nforensic analysis and investigating system events.",
        "oval_definition_id": "oval:ssg-chronyd_sync_clock:def:1",
        "remediations": [
          {
            "remediation_id": "chronyd_sync_clock",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Synchronize internal information system clocks\n  block:\n\n  - name: Check for duplicate values\n    lineinfile:\n      path: /etc/chrony/chrony.conf\n      create: true\n      regexp: '^\\s*makestep '\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: dupes\n\n  - name: Deduplicate values from /etc/chrony/chrony.conf\n    lineinfile:\n      path: /etc/chrony/chrony.conf\n      create: true\n      regexp: '^\\s*makestep '\n      state: absent\n    when: dupes.found is defined and dupes.found > 1\n\n  - name: Insert correct line to /etc/chrony/chrony.conf\n    lineinfile:\n      path: /etc/chrony/chrony.conf\n      create: true\n      regexp: '^\\s*makestep '\n      line: makestep 1 -1\n      state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010436\n  - chronyd_sync_clock\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "chronyd_sync_clock",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif [ -e \"/etc/chrony/chrony.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*makestep /Id\" \"/etc/chrony/chrony.conf\"\nelse\n    touch \"/etc/chrony/chrony.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/chrony/chrony.conf\"\n\ncp \"/etc/chrony/chrony.conf\" \"/etc/chrony/chrony.conf.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"makestep 1 -1\" >> \"/etc/chrony/chrony.conf\"\n# Clean up after ourselves.\nrm \"/etc/chrony/chrony.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238357",
        "stig_id": "UBTU-20-010436"
      },
      "xccdf_org.ssgproject.content_rule_package_rsh-server_removed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_rsh-server_removed",
        "title": "Uninstall rsh-server Package",
        "result": "pass",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R62"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "12",
              "14",
              "15",
              "3",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS01.04",
              "DSS05.02",
              "DSS05.03",
              "DSS05.05",
              "DSS06.06"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000381"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(4)(i)",
              "164.308(b)(1)",
              "164.308(b)(3)",
              "164.310(b)",
              "164.312(e)(1)",
              "164.312(e)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.3",
              "4.3.3.5.4",
              "4.3.3.5.5",
              "4.3.3.5.6",
              "4.3.3.5.7",
              "4.3.3.5.8",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.1",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.11",
              "SR 1.12",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.6",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.2",
              "SR 2.3",
              "SR 2.4",
              "SR 2.5",
              "SR 2.6",
              "SR 2.7",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.6.2.1",
              "A.6.2.2",
              "A.9.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)",
              "IA-5(1)(c)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-3",
              "PR.IP-1",
              "PR.PT-3",
              "PR.PT-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000095-GPOS-00049"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010406"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238327r654156_rule"
            ]
          }
        ],
        "description": "The <code>rsh-server</code> package can be removed with the following command:\n<pre>\n$ apt-get remove rsh-server</pre>\n       ",
        "rationale": "The <code>rsh-server</code> service provides unencrypted remote access service which does not\nprovide for the confidentiality and integrity of user passwords or the remote session and has very weak\nauthentication. If a privileged user were to login using this service, the privileged user password\ncould be compromised. The <code>rsh-server</code> package provides several obsolete and insecure\nnetwork services. Removing it decreases the risk of those services&#x27; accidental (or intentional)\nactivation.",
        "oval_definition_id": "oval:ssg-package_rsh-server_removed:def:1",
        "remediations": [
          {
            "remediation_id": "package_rsh-server_removed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "- name: Ensure rsh-server is removed\n  package:\n    name: rsh-server\n    state: absent\n  tags:\n  - DISA-STIG-UBTU-20-010406\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - NIST-800-53-IA-5(1)(c)\n  - PCI-DSSv4-2.2.4\n  - disable_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - package_rsh-server_removed\n"
          },
          {
            "remediation_id": "package_rsh-server_removed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "include remove_rsh-server\n\nclass remove_rsh-server {\n  package { 'rsh-server':\n    ensure => 'purged',\n  }\n}\n"
          },
          {
            "remediation_id": "package_rsh-server_removed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "disable",
            "fix": "\n# CAUTION: This remediation script will remove rsh-server\n#\t   from the system, and may remove any packages\n#\t   that depend on rsh-server. Execute this\n#\t   remediation AFTER testing on a non-production\n#\t   system!\n\nDEBIAN_FRONTEND=noninteractive apt-get remove -y \"rsh-server\"\n"
          }
        ],
        "vuln_id": "SV-238327",
        "stig_id": "UBTU-20-010406"
      },
      "xccdf_org.ssgproject.content_rule_package_openssh-server_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_openssh-server_installed",
        "title": "Install the OpenSSH Server Package",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "13",
              "14"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.02",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02",
              "DSS06.06"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002418",
              "CCI-002420",
              "CCI-002421",
              "CCI-002422"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.1",
              "SR 3.8",
              "SR 4.1",
              "SR 4.2",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.DS-2",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000423-GPOS-00187",
              "SRG-OS-000424-GPOS-00188",
              "SRG-OS-000425-GPOS-00189",
              "SRG-OS-000426-GPOS-00190"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FCS_SSHS_EXT.1",
              "FCS_SSH_EXT.1",
              "FIA_UAU.5",
              "FTP_ITC_EXT.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010042"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238215r916422_rule"
            ]
          }
        ],
        "description": "The <code>openssh-server</code> package should be installed.\nThe <code>openssh-server</code> package can be installed with the following command:\n<pre>\n$ apt-get install openssh-server</pre>\n      ",
        "rationale": "Without protection of the transmitted information, confidentiality, and\nintegrity may be compromised because unprotected communications can be\nintercepted and either read or altered.",
        "oval_definition_id": "oval:ssg-package_openssh-server_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_openssh-server_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure openssh-server is installed\n  package:\n    name: openssh-server\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010042\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_openssh-server_installed\n"
          },
          {
            "remediation_id": "package_openssh-server_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_openssh-server\n\nclass install_openssh-server {\n  package { 'openssh-server':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_openssh-server_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"openssh-server\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_openssh-server_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"openssh-server\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238215",
        "stig_id": "UBTU-20-010042"
      },
      "xccdf_org.ssgproject.content_rule_service_sshd_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_service_sshd_enabled",
        "title": "Enable the OpenSSH Service",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "13",
              "14"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "DSS05.02",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02",
              "DSS06.06"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.13",
              "3.13.8",
              "3.5.4"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002418",
              "CCI-002420",
              "CCI-002421",
              "CCI-002422"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 3.1",
              "SR 3.8",
              "SR 4.1",
              "SR 4.2",
              "SR 5.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "SC-8",
              "SC-8(1)",
              "SC-8(2)",
              "SC-8(3)",
              "SC-8(4)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.DS-2",
              "PR.DS-5"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000423-GPOS-00187",
              "SRG-OS-000424-GPOS-00188",
              "SRG-OS-000425-GPOS-00189",
              "SRG-OS-000426-GPOS-00190"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010042"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238215r916422_rule"
            ]
          }
        ],
        "description": "The SSH server service, sshd, is commonly needed.\n\nThe <code>sshd</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable sshd.service</pre>\n      ",
        "rationale": "Without protection of the transmitted information, confidentiality, and\nintegrity may be compromised because unprotected communications can be\nintercepted and either read or altered.\n<br>\n       <br>\nThis checklist item applies to both internal and external networks and all types\nof information system components from which information can be transmitted (e.g., servers,\nmobile devices, notebook computers, printers, copiers, scanners, etc). Communication paths\noutside the physical protection of a controlled boundary are exposed to the possibility\nof interception and modification.",
        "oval_definition_id": "oval:ssg-service_sshd_enabled:def:1",
        "remediations": [
          {
            "remediation_id": "service_sshd_enabled",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Enable the OpenSSH Service - Enable service ssh\n  block:\n\n  - name: Gather the package facts\n    package_facts:\n      manager: auto\n\n  - name: Enable the OpenSSH Service - Enable Service ssh\n    ansible.builtin.systemd:\n      name: ssh\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"openssh-server\" in ansible_facts.packages'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010042\n  - NIST-800-171-3.1.13\n  - NIST-800-171-3.13.8\n  - NIST-800-171-3.5.4\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-8\n  - NIST-800-53-SC-8(1)\n  - NIST-800-53-SC-8(2)\n  - NIST-800-53-SC-8(3)\n  - NIST-800-53-SC-8(4)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_sshd_enabled\n"
          },
          {
            "remediation_id": "service_sshd_enabled",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include enable_ssh\n\nclass enable_ssh {\n  service {'ssh':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
          },
          {
            "remediation_id": "service_sshd_enabled",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[customizations.services]\nenabled = [\"ssh\"]\n"
          },
          {
            "remediation_id": "service_sshd_enabled",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'ssh.service'\n\"$SYSTEMCTL_EXEC\" start 'ssh.service'\n\"$SYSTEMCTL_EXEC\" enable 'ssh.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238215",
        "stig_id": "UBTU-20-010042"
      },
      "xccdf_org.ssgproject.content_rule_sshd_set_keepalive": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_set_keepalive",
        "title": "Set SSH Client Alive Count Max",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.2.15"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.6"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "BAI03.01",
              "BAI03.02",
              "BAI03.03",
              "DSS01.03",
              "DSS03.05",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.11"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000879",
              "CCI-001133",
              "CCI-002361"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(4)(i)",
              "164.308(b)(1)",
              "164.308(b)(3)",
              "164.310(b)",
              "164.312(e)(1)",
              "164.312(e)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.3",
              "A.14.1.1",
              "A.14.2.1",
              "A.14.2.5",
              "A.18.1.4",
              "A.6.1.2",
              "A.6.1.5",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.2",
              "CIP-007-3 R5.3.1",
              "CIP-007-3 R5.3.2",
              "CIP-007-3 R5.3.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-12",
              "AC-17(a)",
              "AC-2(5)",
              "CM-6(a)",
              "SC-10"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "PR.AC-1",
              "PR.AC-4",
              "PR.AC-6",
              "PR.AC-7",
              "PR.IP-2"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000163-GPOS-00072",
              "SRG-OS-000279-GPOS-00109"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.1.8"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.2.8"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010036"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238212r858521_rule"
            ]
          }
        ],
        "description": "The SSH server sends at most <code>ClientAliveCountMax</code> messages\nduring a SSH session and waits for a response from the SSH client.\nThe option <code>ClientAliveInterval</code> configures timeout after\neach <code>ClientAliveCountMax</code> message. If the SSH server does not\nreceive a response from the client, then the connection is considered unresponsive\nand terminated.\nFor SSH earlier than v8.2, a <code>ClientAliveCountMax</code> value of <code>0</code>\ncauses a timeout precisely when the <code>ClientAliveInterval</code> is set.\nStarting with v8.2, a value of <code>0</code> disables the timeout functionality\ncompletely. If the option is set to a number greater than <code>0</code>, then\nthe session will be disconnected after\n<code>ClientAliveInterval * ClientAliveCountMax</code> seconds without receiving\na keep alive message.",
        "rationale": "This ensures a user login will be terminated as soon as the <code>ClientAliveInterval</code>\nis reached.",
        "oval_definition_id": "oval:ssg-sshd_set_keepalive:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_set_keepalive",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: XCCDF Value var_sshd_set_keepalive # promote to variable\n  set_fact:\n    var_sshd_set_keepalive: !!str 1\n  tags:\n    - always\n\n- name: Set SSH Client Alive Count Max\n  block:\n\n  - name: Check for duplicate values\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: true\n      regexp: (?i)^\\s*ClientAliveCountMax\\s+\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: dupes\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: true\n      regexp: (?i)^\\s*ClientAliveCountMax\\s+\n      state: absent\n    when: dupes.found is defined and dupes.found > 1\n\n  - name: Insert correct line to /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: true\n      regexp: (?i)^\\s*ClientAliveCountMax\\s+\n      line: ClientAliveCountMax {{ var_sshd_set_keepalive }}\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-20-010036\n  - NIST-800-171-3.1.11\n  - NIST-800-53-AC-12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-2(5)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-10\n  - PCI-DSS-Req-8.1.8\n  - PCI-DSSv4-8.2.8\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_set_keepalive\n"
          },
          {
            "remediation_id": "sshd_set_keepalive",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nvar_sshd_set_keepalive='1'\n\n\nif [ -e \"/etc/ssh/sshd_config\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nelse\n    touch \"/etc/ssh/sshd_config\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config\"\n\ncp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"ClientAliveCountMax $var_sshd_set_keepalive\" > \"/etc/ssh/sshd_config\"\ncat \"/etc/ssh/sshd_config.bak\" >> \"/etc/ssh/sshd_config\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238212",
        "stig_id": "UBTU-20-010036"
      },
      "xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout",
        "title": "Set SSH Client Alive Interval",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.2.15"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.6"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO13.01",
              "BAI03.01",
              "BAI03.02",
              "BAI03.03",
              "DSS01.03",
              "DSS03.05",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.11"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000879",
              "CCI-001133",
              "CCI-002361"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.3",
              "A.14.1.1",
              "A.14.2.1",
              "A.14.2.5",
              "A.18.1.4",
              "A.6.1.2",
              "A.6.1.5",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.2",
              "CIP-007-3 R5.3.1",
              "CIP-007-3 R5.3.2",
              "CIP-007-3 R5.3.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-12",
              "AC-17(a)",
              "AC-17(a)",
              "AC-2(5)",
              "CM-6(a)",
              "CM-6(a)",
              "SC-10"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "PR.AC-1",
              "PR.AC-4",
              "PR.AC-6",
              "PR.AC-7",
              "PR.IP-2"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000126-GPOS-00066",
              "SRG-OS-000163-GPOS-00072",
              "SRG-OS-000279-GPOS-00109",
              "SRG-OS-000395-GPOS-00175"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-8.1.8"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "8.2.8"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010037"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238213r858523_rule"
            ]
          }
        ],
        "description": "SSH allows administrators to set a network responsiveness timeout interval.\nAfter this interval has passed, the unresponsive client will be automatically logged out.\n<br>\n        <br>\nTo set this timeout interval, edit the following line in <code>/etc/ssh/sshd_config</code> as\nfollows:\n<pre>ClientAliveInterval <b>600</b>\n        </pre>\n        <br>\n        <br>\nThe timeout <b>interval</b> is given in seconds. For example, have a timeout\nof 10 minutes, set <b>interval</b> to 600.\n<br>\n        <br>\nIf a shorter timeout has already been set for the login shell, that value will\npreempt any SSH setting made in <code>/etc/ssh/sshd_config</code>. Keep in mind that\nsome processes may stop SSH from correctly detecting that the user is idle.",
        "rationale": "Terminating an idle ssh session within a short time period reduces the window of\nopportunity for unauthorized personnel to take control of a management session\nenabled on the console or console port that has been let unattended.",
        "warnings": [
          {
            "text": "SSH disconnecting unresponsive clients will not have desired effect without also\nconfiguring ClientAliveCountMax in the SSH service configuration.",
            "category": "dependency"
          },
          {
            "text": "Following conditions may prevent the SSH session to time out:\n<ul><li>Remote processes on the remote machine generates output. As the output has to be transferred over the network to the client, the timeout is reset every time such transfer happens.</li><li>Any <code>scp</code> or <code>sftp</code> activity by the same user to the host resets the timeout.</li></ul>\n       ",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-sshd_set_idle_timeout:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_set_idle_timeout",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nsshd_idle_timeout_value='600'\n\n\nif [ -e \"/etc/ssh/sshd_config\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nelse\n    touch \"/etc/ssh/sshd_config\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config\"\n\ncp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"ClientAliveInterval $sshd_idle_timeout_value\" > \"/etc/ssh/sshd_config\"\ncat \"/etc/ssh/sshd_config.bak\" >> \"/etc/ssh/sshd_config\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238213",
        "stig_id": "UBTU-20-010037"
      },
      "xccdf_org.ssgproject.content_rule_sshd_disable_empty_passwords": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_disable_empty_passwords",
        "title": "Disable SSH Access via Empty Passwords",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "high",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.2.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "3",
              "5",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.6"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.02",
              "DSS06.03",
              "DSS06.06"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.1",
              "3.1.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366",
              "CCI-000766"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(4)(i)",
              "164.308(b)(1)",
              "164.308(b)(3)",
              "164.310(b)",
              "164.312(e)(1)",
              "164.312(e)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.3",
              "4.3.3.5.4",
              "4.3.3.5.5",
              "4.3.3.5.6",
              "4.3.3.5.7",
              "4.3.3.5.8",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.1",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.11",
              "SR 1.12",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.6",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.2",
              "SR 2.3",
              "SR 2.4",
              "SR 2.5",
              "SR 2.6",
              "SR 2.7",
              "SR 5.2",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-17(a)",
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-4",
              "PR.AC-6",
              "PR.DS-5",
              "PR.IP-1",
              "PR.PT-3"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000106-GPOS-00053",
              "SRG-OS-000480-GPOS-00227",
              "SRG-OS-000480-GPOS-00229"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FIA_UAU.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-2.2.4"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010047"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238218r877377_rule"
            ]
          }
        ],
        "description": "Disallow SSH login with empty passwords.\nThe default SSH configuration disables logins with empty passwords. The appropriate\nconfiguration is used if no value is set for <code>PermitEmptyPasswords</code>.\n<br>\nTo explicitly disallow SSH login from accounts with empty passwords,\nadd or correct the following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<br>\n        <pre>PermitEmptyPasswords no</pre>\nAny accounts with empty passwords should be disabled immediately, and PAM configuration\nshould prevent users from being able to assign themselves empty passwords.",
        "rationale": "Configuring this setting for the SSH daemon provides additional assurance\nthat remote login via SSH will require a password, even in the event of\nmisconfiguration elsewhere.",
        "oval_definition_id": "oval:ssg-sshd_disable_empty_passwords:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_disable_empty_passwords",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Disable SSH Access via Empty Passwords\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter PermitEmptyPasswords is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"PermitEmptyPasswords\"| regex_escape }}\\s+\n      line: PermitEmptyPasswords no\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-20-010047\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2.6\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_empty_passwords\n"
          },
          {
            "remediation_id": "sshd_disable_empty_passwords",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"PermitEmptyPasswords no\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238218",
        "stig_id": "UBTU-20-010047"
      },
      "xccdf_org.ssgproject.content_rule_sshd_disable_x11_forwarding": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_disable_x11_forwarding",
        "title": "Disable X11 Forwarding",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.2.5"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(b)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010048"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238219r858533_rule"
            ]
          }
        ],
        "description": "The X11Forwarding parameter provides the ability to tunnel X11 traffic\nthrough the connection to enable remote graphic connections.\nSSH has the capability to encrypt remote X11 connections when SSH&#x27;s\n<code>X11Forwarding</code> option is enabled.\n<br>\nThe default SSH configuration disables X11Forwarding. The appropriate\nconfiguration is used if no value is set for <code>X11Forwarding</code>.\n<br>\nTo explicitly disable X11 Forwarding, add or correct the following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>X11Forwarding no</pre>\n       ",
        "rationale": "Disable X11 forwarding unless there is an operational requirement to use X11\napplications directly. There is a small risk that the remote X11 servers of\nusers who are logged in via SSH with X11 forwarding could be compromised by\nother users on the X11 server. Note that even if X11 forwarding is disabled,\nusers can always install their own forwarders.",
        "oval_definition_id": "oval:ssg-sshd_disable_x11_forwarding:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_disable_x11_forwarding",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Disable X11 Forwarding\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter X11Forwarding is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"X11Forwarding\"| regex_escape }}\\s+\n      line: X11Forwarding no\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010048\n  - NIST-800-53-CM-6(b)\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_disable_x11_forwarding\n"
          },
          {
            "remediation_id": "sshd_disable_x11_forwarding",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"X11Forwarding no\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238219",
        "stig_id": "UBTU-20-010048"
      },
      "xccdf_org.ssgproject.content_rule_sshd_do_not_permit_user_env": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_do_not_permit_user_env",
        "title": "Do Not Allow SSH Environment Options",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.2.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "11",
              "3",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.6"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "BAI10.01",
              "BAI10.02",
              "BAI10.03",
              "BAI10.05"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.12"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(4)(i)",
              "164.308(b)(1)",
              "164.308(b)(3)",
              "164.310(b)",
              "164.312(e)(1)",
              "164.312(e)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.4.3.2",
              "4.3.4.3.3"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.2",
              "A.12.5.1",
              "A.12.6.2",
              "A.14.2.2",
              "A.14.2.3",
              "A.14.2.4"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-17(a)",
              "CM-6(a)",
              "CM-7(a)",
              "CM-7(b)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.IP-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00229"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-2.2.4"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010047"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238218r877377_rule"
            ]
          }
        ],
        "description": "Ensure that users are not able to override environment variables of the SSH daemon.\n<br>\nThe default SSH configuration disables environment processing. The appropriate\nconfiguration is used if no value is set for <code>PermitUserEnvironment</code>.\n<br>\nTo explicitly disable Environment options, add or correct the following\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>PermitUserEnvironment no</pre>\n       ",
        "rationale": "SSH environment options potentially allow users to bypass\naccess restriction in some configurations.",
        "oval_definition_id": "oval:ssg-sshd_do_not_permit_user_env:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_do_not_permit_user_env",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Do Not Allow SSH Environment Options\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter PermitUserEnvironment is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"PermitUserEnvironment\"| regex_escape }}\\s+\n      line: PermitUserEnvironment no\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-20-010047\n  - NIST-800-171-3.1.12\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-7(a)\n  - NIST-800-53-CM-7(b)\n  - PCI-DSS-Req-2.2.4\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_do_not_permit_user_env\n"
          },
          {
            "remediation_id": "sshd_do_not_permit_user_env",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"PermitUserEnvironment no\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238218",
        "stig_id": "UBTU-20-010047"
      },
      "xccdf_org.ssgproject.content_rule_sshd_enable_pam": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_enable_pam",
        "title": "Enable PAM",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.2.19"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000877"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000125-GPOS-00065"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "2.2.6"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010035"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238211r877395_rule"
            ]
          }
        ],
        "description": "UsePAM Enables the Pluggable Authentication Module interface. If set to yes this will\nenable PAM authentication using ChallengeResponseAuthentication and\nPasswordAuthentication in addition to PAM account and session module processing for all\nauthentication types.\n\nTo enable PAM authentication, add or correct the following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>UsePAM yes</pre>\n       ",
        "rationale": "When UsePAM is set to yes, PAM runs through account and session types properly. This is\nimportant if you want to restrict access to services based off of IP, time or other factors of\nthe account. Additionally, you can make sure users inherit certain environment variables\non login or disallow access to the server.",
        "oval_definition_id": "oval:ssg-sshd_enable_pam:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_enable_pam",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Enable PAM\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter UsePAM is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"UsePAM\"| regex_escape }}\\s+\n      line: UsePAM yes\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010035\n  - PCI-DSSv4-2.2.6\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pam\n"
          },
          {
            "remediation_id": "sshd_enable_pam",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*UsePAM\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*UsePAM\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*UsePAM\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"UsePAM yes\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238211",
        "stig_id": "UBTU-20-010035"
      },
      "xccdf_org.ssgproject.content_rule_sshd_enable_pubkey_auth": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_enable_pubkey_auth",
        "title": "Enable Public Key Authentication",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000765",
              "CCI-000766",
              "CCI-000767",
              "CCI-000768"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000105-GPOS-00052",
              "SRG-OS-000106-GPOS-00053",
              "SRG-OS-000107-GPOS-00054",
              "SRG-OS-000108-GPOS-00055"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010033"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238210r917810_rule"
            ]
          }
        ],
        "description": "Enable SSH login with public keys.\n<br>\nThe default SSH configuration enables authentication based on public keys. The appropriate\nconfiguration is used if no value is set for <code>PubkeyAuthentication</code>.\n<br>\nTo explicitly enable Public Key Authentication, add or correct the following\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<pre>PubkeyAuthentication yes</pre>\n       ",
        "rationale": "Without the use of multifactor authentication, the ease of access to\nprivileged functions is greatly increased. Multifactor authentication\nrequires using two or more factors to achieve authentication.\nA privileged account is defined as an information system account with\nauthorizations of a privileged user. \nThe DoD CAC with DoD-approved PKI is an example of multifactor\nauthentication.",
        "oval_definition_id": "oval:ssg-sshd_enable_pubkey_auth:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_enable_pubkey_auth",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Enable Public Key Authentication\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter PubkeyAuthentication is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"PubkeyAuthentication\"| regex_escape }}\\s+\n      line: PubkeyAuthentication yes\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010033\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_pubkey_auth\n"
          },
          {
            "remediation_id": "sshd_enable_pubkey_auth",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"PubkeyAuthentication yes\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238210",
        "stig_id": "UBTU-20-010033"
      },
      "xccdf_org.ssgproject.content_rule_sshd_enable_warning_banner_net": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_enable_warning_banner_net",
        "title": "Enable SSH Warning Banner",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "5.2.18"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.5.6"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.10",
              "DSS06.10"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.9"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000048",
              "CCI-000050",
              "CCI-001384",
              "CCI-001385",
              "CCI-001386",
              "CCI-001387",
              "CCI-001388"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(4)(i)",
              "164.308(b)(1)",
              "164.308(b)(3)",
              "164.310(b)",
              "164.312(e)(1)",
              "164.312(e)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.9.2.1",
              "A.9.2.4",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-17(a)",
              "AC-8(a)",
              "AC-8(c)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000023-GPOS-00006",
              "SRG-OS-000228-GPOS-00088"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FTA_TAB.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010038"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238214r858525_rule"
            ]
          }
        ],
        "description": "To enable the warning banner and ensure it is consistent\nacross the system, add or correct the following line in\n\n<code>/etc/ssh/sshd_config</code>:\n\n<pre>Banner /etc/issue.net</pre>\nAnother section contains information on how to create an\nappropriate system-wide warning banner.",
        "rationale": "The warning message reinforces policy awareness during the logon process and\nfacilitates possible legal action against attackers. Alternatively, systems\nwhose ownership should not be obvious should ensure usage of a banner that does\nnot provide easy attribution.",
        "oval_definition_id": "oval:ssg-sshd_enable_warning_banner_net:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_enable_warning_banner_net",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Enable SSH Warning Banner\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter Banner is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"Banner\"| regex_escape }}\\s+\n      line: Banner /etc/issue.net\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.5.6\n  - DISA-STIG-UBTU-20-010038\n  - NIST-800-171-3.1.9\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-AC-8(a)\n  - NIST-800-53-AC-8(c)\n  - NIST-800-53-CM-6(a)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_enable_warning_banner_net\n"
          },
          {
            "remediation_id": "sshd_enable_warning_banner_net",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"Banner /etc/issue.net\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238214",
        "stig_id": "UBTU-20-010038"
      },
      "xccdf_org.ssgproject.content_rule_sshd_use_approved_ciphers_ordered_stig": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_use_approved_ciphers_ordered_stig",
        "title": "Use Only FIPS 140-2 Validated Ciphers",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000068",
              "CCI-000366",
              "CCI-000803",
              "CCI-000877",
              "CCI-002890",
              "CCI-003123"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000033-GPOS-00014",
              "SRG-OS-000120-GPOS-00061",
              "SRG-OS-000125-GPOS-00065",
              "SRG-OS-000250-GPOS-00093",
              "SRG-OS-000393-GPOS-00173",
              "SRG-OS-000394-GPOS-00174"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010044"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238217r877465_rule"
            ]
          }
        ],
        "description": "Limit the ciphers to those algorithms which are FIPS-approved.\nThe following line in <code>/etc/ssh/sshd_config</code>\ndemonstrates use of FIPS-approved ciphers:\n<pre>Ciphers aes256-ctr,aes192-ctr,aes128-ctr\n        </pre>\nIf this line does not contain these ciphers in exact order,\nis commented out, or is missing, this is a finding.",
        "rationale": "Unapproved mechanisms that are used for authentication to the cryptographic module are not verified and therefore\ncannot be relied upon to provide confidentiality or integrity, and system data may be compromised.\n<br>\nOperating systems utilizing encryption are required to use FIPS-compliant mechanisms for authenticating to\ncryptographic modules.\n<br>\nFIPS 140-2 is the current standard for validating that mechanisms used to access cryptographic modules\nutilize authentication that meets industry and government requirements. For government systems, this allows\nSecurity Levels 1, 2, 3, or 4 for use on Ubuntu 20.04.",
        "warnings": [
          {
            "text": "The system needs to be rebooted for these changes to take effect.",
            "category": "general"
          },
          {
            "text": "System Crypto Modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this, the system has to have cryptographic software provided by\na vendor that has undergone this certification. This means providing\ndocumentation, test results, design information, and independent third\nparty review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.",
            "category": "regulatory"
          }
        ],
        "oval_definition_id": "oval:ssg-sshd_use_approved_ciphers_ordered_stig:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_use_approved_ciphers_ordered_stig",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: XCCDF Value sshd_approved_ciphers # promote to variable\n  set_fact:\n    sshd_approved_ciphers: !!str aes256-ctr,aes192-ctr,aes128-ctr\n  tags:\n    - always\n\n- name: Use Only FIPS 140-2 Validated Ciphers\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter Ciphers is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"Ciphers\"| regex_escape }}\\s+\n      line: Ciphers {{ sshd_approved_ciphers }}\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010044\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_ciphers_ordered_stig\n"
          },
          {
            "remediation_id": "sshd_use_approved_ciphers_ordered_stig",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nsshd_approved_ciphers='aes256-ctr,aes192-ctr,aes128-ctr'\n\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*Ciphers\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*Ciphers\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*Ciphers\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"Ciphers $sshd_approved_ciphers\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238217",
        "stig_id": "UBTU-20-010044"
      },
      "xccdf_org.ssgproject.content_rule_sshd_use_approved_kex_ordered_stig": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_use_approved_kex_ordered_stig",
        "title": "Use Only FIPS 140-2 Validated Key Exchange Algorithms",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001453"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-17(2)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000250-GPOS-00093"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010045"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-255912r880905_rule"
            ]
          }
        ],
        "description": "Limit the key exchange algorithms to those  which are FIPS-approved.\nAdd or modify the following line in <code>/etc/ssh/sshd_config</code>\n        <pre>KexAlgorithms ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256</pre>\nThis rule ensures that only the key exchange algorithms mentioned\nabove (or their subset) are configured for use, keeping the given\norder of algorithms.",
        "rationale": "DoD information systems are required to use FIPS-approved key exchange algorithms.\nThe system will attempt to use the first algorithm presented by the client that matches\nthe server list. Listing the values &quot;strongest to weakest&quot; is a method to ensure the use\nof the strongest algorithm available to secure the SSH connection.",
        "warnings": [
          {
            "text": "The system needs to be rebooted for these changes to take effect.",
            "category": "general"
          },
          {
            "text": "System crypto modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this requirements, the system has to have cryptographic software\nprovided by a vendor that has undergone this certification. This means\nproviding documentation, test results, design information, and independent\nthird party review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.",
            "category": "regulatory"
          }
        ],
        "oval_definition_id": "oval:ssg-sshd_use_approved_kex_ordered_stig:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_use_approved_kex_ordered_stig",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Configure sshd to use FIPS 140-2 approved key exchange algorithms\n  lineinfile:\n    path: /etc/ssh/sshd_config\n    line: KexAlgorithms ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256\n    state: present\n    regexp: ^\\s*KexAlgorithms\\s*\n    create: true\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010045\n  - NIST-800-53-AC-17(2)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_kex_ordered_stig\n"
          },
          {
            "remediation_id": "sshd_use_approved_kex_ordered_stig",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nKEX_ALGOS=\"ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,\\\ndiffie-hellman-group-exchange-sha256\"\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*KexAlgorithms\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*KexAlgorithms\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*KexAlgorithms\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"KexAlgorithms $KEX_ALGOS\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-255912",
        "stig_id": "UBTU-20-010045"
      },
      "xccdf_org.ssgproject.content_rule_sshd_use_approved_macs_ordered_stig": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_use_approved_macs_ordered_stig",
        "title": "Use Only FIPS 140-2 Validated MACs",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000068",
              "CCI-000803",
              "CCI-000877",
              "CCI-001453",
              "CCI-003123"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000125-GPOS-00065",
              "SRG-OS-000250-GPOS-00093",
              "SRG-OS-000394-GPOS-00174"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010043"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238216r877465_rule"
            ]
          }
        ],
        "description": "Limit the MACs to those hash algorithms which are FIPS-approved.\nThe following line in <code>/etc/ssh/sshd_config</code>\ndemonstrates use of FIPS-approved MACs:\n<pre>MACs hmac-sha2-512,hmac-sha2-256\n        </pre>\nIf this line does not contain these MACs in exact order,\nis commented out, or is missing, this is a finding.",
        "rationale": "DoD Information Systems are required to use FIPS-approved cryptographic hash\nfunctions. The only SSHv2 hash algorithms meeting this requirement is SHA2.",
        "warnings": [
          {
            "text": "The system needs to be rebooted for these changes to take effect.",
            "category": "general"
          },
          {
            "text": "System Crypto Modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this, the system has to have cryptographic software provided by\na vendor that has undergone this certification. This means providing\ndocumentation, test results, design information, and independent third\nparty review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.",
            "category": "regulatory"
          }
        ],
        "oval_definition_id": "oval:ssg-sshd_use_approved_macs_ordered_stig:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_use_approved_macs_ordered_stig",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: XCCDF Value sshd_approved_macs # promote to variable\n  set_fact:\n    sshd_approved_macs: !!str hmac-sha2-512,hmac-sha2-256\n  tags:\n    - always\n\n- name: Use Only FIPS 140-2 Validated MACs\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter Macs is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"Macs\"| regex_escape }}\\s+\n      line: Macs {{ sshd_approved_macs }}\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010043\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_use_approved_macs_ordered_stig\n"
          },
          {
            "remediation_id": "sshd_use_approved_macs_ordered_stig",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nsshd_approved_macs='hmac-sha2-512,hmac-sha2-256'\n\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\n\nLC_ALL=C sed -i \"/^\\s*MACs\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*MACs\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*MACs\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n\ncp \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"MACs $sshd_approved_macs\" > \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\ncat \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\" >> \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238216",
        "stig_id": "UBTU-20-010043"
      },
      "xccdf_org.ssgproject.content_rule_sshd_x11_use_localhost": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sshd_x11_use_localhost",
        "title": "Prevent remote hosts from connecting to the proxy display",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000366"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(b)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000480-GPOS-00227"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010049"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238220r858535_rule"
            ]
          }
        ],
        "description": "The SSH daemon should prevent remote hosts from connecting to the proxy\ndisplay.\n<br>\nThe default SSH configuration for <code>X11UseLocalhost</code> is <code>yes</code>,\nwhich prevents remote hosts from connecting to the proxy display.\n<br>\nTo explicitly prevent remote connections to the proxy display, add or correct\nthe following line in\n\n\n<code>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</code>:\n\n<code>X11UseLocalhost yes</code>\n       ",
        "rationale": "When X11 forwarding is enabled, there may be additional exposure to the\nserver and client displays if the sshd proxy display is configured to listen\non the wildcard address. By default, sshd binds the forwarding server to the\nloopback address and sets the hostname part of the <code>DISPLAY</code>\nenvironment variable to localhost. This prevents remote hosts from\nconnecting to the proxy display.",
        "oval_definition_id": "oval:ssg-sshd_x11_use_localhost:def:1",
        "remediations": [
          {
            "remediation_id": "sshd_x11_use_localhost",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Prevent remote hosts from connecting to the proxy display\n  block:\n\n  - name: Deduplicate values from /etc/ssh/sshd_config\n    lineinfile:\n      path: /etc/ssh/sshd_config\n      create: false\n      regexp: (?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n      state: absent\n\n  - name: Check if /etc/ssh/sshd_config.d exists\n    stat:\n      path: /etc/ssh/sshd_config.d\n    register: _etc_ssh_sshd_config_d_exists\n\n  - name: Check if the parameter X11UseLocalhost is present in /etc/ssh/sshd_config.d\n    find:\n      paths: /etc/ssh/sshd_config.d\n      recurse: 'yes'\n      follow: 'no'\n      contains: (?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n    register: _etc_ssh_sshd_config_d_has_parameter\n    when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir\n\n  - name: Remove parameter from files in /etc/ssh/sshd_config.d\n    lineinfile:\n      path: '{{ item.path }}'\n      create: false\n      regexp: (?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n      state: absent\n    with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'\n    when: _etc_ssh_sshd_config_d_has_parameter.matched\n\n  - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n    lineinfile:\n      path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n      create: true\n      regexp: (?i)^\\s*{{ \"X11UseLocalhost\"| regex_escape }}\\s+\n      line: X11UseLocalhost yes\n      state: present\n      insertbefore: BOF\n      validate: /usr/sbin/sshd -t -f %s\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010049\n  - NIST-800-53-CM-6(b)\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - sshd_x11_use_localhost\n"
          },
          {
            "remediation_id": "sshd_x11_use_localhost",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nmkdir -p /etc/ssh/sshd_config.d\ntouch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\n\nLC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config\"\nLC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf\nif [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nelse\n    touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n\ncp \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n# Insert at the beginning of the file\nprintf '%s\\n' \"X11UseLocalhost yes\" > \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\ncat \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\" >> \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\"\n# Clean up after ourselves.\nrm \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238220",
        "stig_id": "UBTU-20-010049"
      },
      "xccdf_org.ssgproject.content_rule_sssd_offline_cred_expiration": {
        "rule_id": "xccdf_org.ssgproject.content_rule_sssd_offline_cred_expiration",
        "title": "Configure SSSD to Expire Offline Credentials",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "15",
              "16",
              "5"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS05.10",
              "DSS06.03",
              "DSS06.10"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-002007"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.3.2.2",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.6.1",
              "4.3.3.6.2",
              "4.3.3.6.3",
              "4.3.3.6.4",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.3.6.9",
              "4.3.3.7.2",
              "4.3.3.7.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.10",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.18.1.4",
              "A.7.1.1",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.2",
              "A.9.4.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "CM-6(a)",
              "IA-5(13)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "PR.AC-1",
              "PR.AC-6",
              "PR.AC-7"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000383-GPOS-00166"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010441"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238362r853437_rule"
            ]
          }
        ],
        "description": "SSSD should be configured to expire offline credentials after 1 day.\n\nTo configure SSSD to expire offline credentials, set\n<code>offline_credentials_expiration</code> to <code>1</code> under the <code>[pam]</code>\nsection in <code>/etc/sssd/sssd.conf</code>. For example:\n<pre>[pam]\noffline_credentials_expiration = 1\n</pre>\n      ",
        "rationale": "If cached authentication information is out-of-date, the validity of the\nauthentication information may be questionable.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-sssd_offline_cred_expiration:def:1",
        "remediations": [
          {
            "remediation_id": "sssd_offline_cred_expiration",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "configure",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010441\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Test for domain group\n  command: grep '\\s*\\[domain\\/[^]]*]' /etc/sssd/sssd.conf\n  register: test_grep_domain\n  failed_when: false\n  changed_when: false\n  check_mode: false\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010441\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Add default domain group (if no domain there)\n  ini_file:\n    path: /etc/sssd/sssd.conf\n    section: '{{ item.section }}'\n    option: '{{ item.option }}'\n    value: '{{ item.value }}'\n    create: true\n    mode: 384\n  with_items:\n  - section: sssd\n    option: domains\n    value: default\n  - section: domain/default\n    option: id_provider\n    value: files\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - test_grep_domain.stdout is defined\n  - test_grep_domain.stdout | length < 1\n  tags:\n  - DISA-STIG-UBTU-20-010441\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Configure SSD to Expire Offline Credentials\n  ini_file:\n    dest: /etc/sssd/sssd.conf\n    section: pam\n    option: offline_credentials_expiration\n    value: 1\n    create: true\n    mode: 384\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010441\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Find all the conf files inside /etc/sssd/conf.d/\n  find:\n    paths: /etc/sssd/conf.d/\n    patterns: '*.conf'\n  register: sssd_conf_d_files\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010441\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n\n- name: Fix offline_credentials_expiration configuration in /etc/sssd/conf.d/\n  ansible.builtin.replace:\n    path: '{{ item.path }}'\n    regexp: '[^#]*offline_credentials_expiration.*'\n    replace: offline_credentials_expiration = 1\n  with_items: '{{ sssd_conf_d_files.files }}'\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010441\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(13)\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_offline_cred_expiration\n"
          },
          {
            "remediation_id": "sssd_offline_cred_expiration",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "medium",
            "strategy": "configure",
            "fix": "# Remediation is applicable only in certain platforms\nif dpkg-query --show --showformat='${db:Status-Status}\\n' 'sssd-common' 2>/dev/null | grep -q installed && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\n# sssd configuration files must be created with 600 permissions if they don't exist\n# otherwise the sssd module fails to start\nOLD_UMASK=$(umask)\numask u=rw,go=\n\nfound=false\n\n# set value in all files if they contain section or key\nfor f in $(echo -n \"/etc/sssd/sssd.conf /etc/sssd/conf.d/*.conf\"); do\n    if [ ! -e \"$f\" ]; then\n        continue\n    fi\n\n    # find key in section and change value\n    if grep -qzosP \"[[:space:]]*\\[pam\\]([^\\n\\[]*\\n+)+?[[:space:]]*offline_credentials_expiration\" \"$f\"; then\n\n            sed -i \"s/offline_credentials_expiration[^(\\n)]*/offline_credentials_expiration=1/\" \"$f\"\n\n            found=true\n\n    # find section and add key = value to it\n    elif grep -qs \"[[:space:]]*\\[pam\\]\" \"$f\"; then\n\n            sed -i \"/[[:space:]]*\\[pam\\]/a offline_credentials_expiration=1\" \"$f\"\n\n            found=true\n    fi\ndone\n\n# if section not in any file, append section with key = value to FIRST file in files parameter\nif ! $found ; then\n    file=$(echo \"/etc/sssd/sssd.conf /etc/sssd/conf.d/*.conf\" | cut -f1 -d ' ')\n    mkdir -p \"$(dirname \"$file\")\"\n\n    echo -e \"[pam]\\noffline_credentials_expiration=1\" >> \"$file\"\n\nfi\n\numask $OLD_UMASK\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238362",
        "stig_id": "UBTU-20-010441"
      },
      "xccdf_org.ssgproject.content_rule_package_audit-audispd-plugins_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_audit-audispd-plugins_installed",
        "title": "Ensure the default plugins for the audit dispatcher are Installed",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001851"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(5)(ii)(C)",
              "164.310(a)(2)(iv)",
              "164.310(d)(2)(iii)",
              "164.312(b)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000342-GPOS-00133"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010216"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238306r877390_rule"
            ]
          }
        ],
        "description": "The audit-audispd-plugins package should be installed.",
        "rationale": "Information stored in one location is vulnerable to accidental or incidental deletion or alteration. Off-loading is a common process in information systems with limited audit storage capacity.",
        "oval_definition_id": "oval:ssg-package_audit-audispd-plugins_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_audit-audispd-plugins_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure audispd-plugins is installed\n  package:\n    name: audispd-plugins\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010216\n  - PCI-DSS-Req-10.5.3\n  - PCI-DSSv4-10.3.3\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_audit-audispd-plugins_installed\n"
          },
          {
            "remediation_id": "package_audit-audispd-plugins_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_audispd-plugins\n\nclass install_audispd-plugins {\n  package { 'audispd-plugins':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_audit-audispd-plugins_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"audispd-plugins\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_audit-audispd-plugins_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"audispd-plugins\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238306",
        "stig_id": "UBTU-20-010216"
      },
      "xccdf_org.ssgproject.content_rule_package_audit_installed": {
        "rule_id": "xccdf_org.ssgproject.content_rule_package_audit_installed",
        "title": "Ensure the audit Subsystem is Installed",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R33",
              "R73"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.1.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000131",
              "CCI-000132",
              "CCI-000133",
              "CCI-000134",
              "CCI-000135",
              "CCI-000154",
              "CCI-000158",
              "CCI-000169",
              "CCI-000172",
              "CCI-001464",
              "CCI-001487",
              "CCI-001814",
              "CCI-001875",
              "CCI-001876",
              "CCI-001877",
              "CCI-001878",
              "CCI-001879",
              "CCI-001880",
              "CCI-001881",
              "CCI-001882",
              "CCI-001889",
              "CCI-001914",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(5)(ii)(C)",
              "164.310(a)(2)(iv)",
              "164.310(d)(2)(iii)",
              "164.312(b)"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R3.3",
              "CIP-007-3 R6.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-7(a)",
              "AU-12(2)",
              "AU-14",
              "AU-2(a)",
              "AU-7(1)",
              "AU-7(2)",
              "CM-6(a)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000038-GPOS-00016",
              "SRG-OS-000039-GPOS-00017",
              "SRG-OS-000040-GPOS-00018",
              "SRG-OS-000041-GPOS-00019",
              "SRG-OS-000042-GPOS-00021",
              "SRG-OS-000051-GPOS-00024",
              "SRG-OS-000054-GPOS-00025",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000122-GPOS-00063",
              "SRG-OS-000254-GPOS-00095",
              "SRG-OS-000255-GPOS-00096",
              "SRG-OS-000337-GPOS-00129",
              "SRG-OS-000348-GPOS-00136",
              "SRG-OS-000349-GPOS-00137",
              "SRG-OS-000350-GPOS-00138",
              "SRG-OS-000351-GPOS-00139",
              "SRG-OS-000352-GPOS-00140",
              "SRG-OS-000353-GPOS-00141",
              "SRG-OS-000354-GPOS-00142",
              "SRG-OS-000358-GPOS-00145",
              "SRG-OS-000365-GPOS-00152",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000475-GPOS-00220"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.1"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010182"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238298r853421_rule"
            ]
          }
        ],
        "description": "The audit package should be installed.",
        "rationale": "The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparison with potential local access control policy such as SELinux policy.",
        "oval_definition_id": "oval:ssg-package_audit_installed:def:1",
        "remediations": [
          {
            "remediation_id": "package_audit_installed",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Ensure auditd is installed\n  package:\n    name: auditd\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010182\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-AU-12(2)\n  - NIST-800-53-AU-14\n  - NIST-800-53-AU-2(a)\n  - NIST-800-53-AU-7(1)\n  - NIST-800-53-AU-7(2)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.1\n  - PCI-DSSv4-10.2.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_audit_installed\n"
          },
          {
            "remediation_id": "package_audit_installed",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include install_auditd\n\nclass install_auditd {\n  package { 'auditd':\n    ensure => 'installed',\n  }\n}\n"
          },
          {
            "remediation_id": "package_audit_installed",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[[packages]]\nname = \"auditd\"\nversion = \"*\"\n"
          },
          {
            "remediation_id": "package_audit_installed",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nDEBIAN_FRONTEND=noninteractive apt-get install -y \"auditd\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238298",
        "stig_id": "UBTU-20-010182"
      },
      "xccdf_org.ssgproject.content_rule_service_auditd_enabled": {
        "rule_id": "xccdf_org.ssgproject.content_rule_service_auditd_enabled",
        "title": "Enable auditd Service",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R33",
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000095-CTR-000170",
              "SRG-APP-000409-CTR-000990",
              "SRG-APP-000508-CTR-001300",
              "SRG-APP-000510-CTR-001310"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.1.2"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.3.1",
              "3.3.2",
              "3.3.6"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000131",
              "CCI-000132",
              "CCI-000133",
              "CCI-000134",
              "CCI-000135",
              "CCI-000154",
              "CCI-000158",
              "CCI-000169",
              "CCI-000172",
              "CCI-000366",
              "CCI-001464",
              "CCI-001487",
              "CCI-001814",
              "CCI-001875",
              "CCI-001876",
              "CCI-001877",
              "CCI-001878",
              "CCI-001879",
              "CCI-001880",
              "CCI-001881",
              "CCI-001882",
              "CCI-001889",
              "CCI-001914",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(5)(ii)(C)",
              "164.310(a)(2)(iv)",
              "164.310(d)(2)(iii)",
              "164.312(b)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R3.3",
              "CIP-007-3 R6.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(g)",
              "AC-6(9)",
              "AU-10",
              "AU-12(c)",
              "AU-14(1)",
              "AU-2(d)",
              "AU-3",
              "CM-6(a)",
              "SI-4(23)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000038-GPOS-00016",
              "SRG-OS-000039-GPOS-00017",
              "SRG-OS-000040-GPOS-00018",
              "SRG-OS-000041-GPOS-00019",
              "SRG-OS-000042-GPOS-00021",
              "SRG-OS-000051-GPOS-00024",
              "SRG-OS-000054-GPOS-00025",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000122-GPOS-00063",
              "SRG-OS-000254-GPOS-00095",
              "SRG-OS-000255-GPOS-00096",
              "SRG-OS-000337-GPOS-00129",
              "SRG-OS-000348-GPOS-00136",
              "SRG-OS-000349-GPOS-00137",
              "SRG-OS-000350-GPOS-00138",
              "SRG-OS-000351-GPOS-00139",
              "SRG-OS-000352-GPOS-00140",
              "SRG-OS-000353-GPOS-00141",
              "SRG-OS-000354-GPOS-00142",
              "SRG-OS-000358-GPOS-00145",
              "SRG-OS-000365-GPOS-00152",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000475-GPOS-00220"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.1"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010182"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238298r853421_rule"
            ]
          }
        ],
        "description": "The <code>auditd</code> service is an essential userspace component of\nthe Linux Auditing System, as it is responsible for writing audit records to\ndisk.\n\nThe <code>auditd</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable auditd.service</pre>\n     ",
        "rationale": "Without establishing what type of events occurred, it would be difficult\nto establish, correlate, and investigate the events leading up to an outage or attack.\nEnsuring the <code>auditd</code> service is active ensures audit records\ngenerated by the kernel are appropriately recorded.\n<br>\n      <br>\nAdditionally, a properly configured audit subsystem ensures that actions of\nindividual system users can be uniquely traced to those users so they\ncan be held accountable for their actions.",
        "platforms": [
          "#package_audit"
        ],
        "oval_definition_id": "oval:ssg-service_auditd_enabled:def:1",
        "remediations": [
          {
            "remediation_id": "service_auditd_enabled",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010182\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.3.2\n  - NIST-800-171-3.3.6\n  - NIST-800-53-AC-2(g)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-AU-3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-4(23)\n  - PCI-DSS-Req-10.1\n  - PCI-DSSv4-10.2.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_auditd_enabled\n\n- name: Enable auditd Service - Enable service auditd\n  block:\n\n  - name: Gather the package facts\n    package_facts:\n      manager: auto\n\n  - name: Enable auditd Service - Enable Service auditd\n    ansible.builtin.systemd:\n      name: auditd\n      enabled: true\n      state: started\n      masked: false\n    when:\n    - '\"auditd\" in ansible_facts.packages'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"auditd\" in ansible_facts.packages'\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010182\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.3.2\n  - NIST-800-171-3.3.6\n  - NIST-800-53-AC-2(g)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-AU-3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-4(23)\n  - PCI-DSS-Req-10.1\n  - PCI-DSSv4-10.2.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_auditd_enabled\n"
          },
          {
            "remediation_id": "service_auditd_enabled",
            "system": "urn:xccdf:fix:script:puppet",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "include enable_auditd\n\nclass enable_auditd {\n  service {'auditd':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
          },
          {
            "remediation_id": "service_auditd_enabled",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "\n[customizations.services]\nenabled = [\"auditd\"]\n"
          },
          {
            "remediation_id": "service_auditd_enabled",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "enable",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; }; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'auditd.service'\n\"$SYSTEMCTL_EXEC\" start 'auditd.service'\n\"$SYSTEMCTL_EXEC\" enable 'auditd.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238298",
        "stig_id": "UBTU-20-010182"
      },
      "xccdf_org.ssgproject.content_rule_grub2_audit_argument": {
        "rule_id": "xccdf_org.ssgproject.content_rule_grub2_audit_argument",
        "title": "Enable Auditing for Processes Which Start Prior to the Audit Daemon",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "low",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.1.3"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.3.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-001464",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(5)(ii)(C)",
              "164.310(a)(2)(iv)",
              "164.310(d)(2)(iii)",
              "164.312(b)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-17(1)",
              "AU-10",
              "AU-14(1)",
              "CM-6(a)",
              "IR-5(1)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000254-GPOS-00095",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000473-GPOS-00218"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.7.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010198"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238299r654072_rule"
            ]
          }
        ],
        "description": "To ensure all processes can be audited, even those which start\nprior to the audit daemon, add the argument <code>audit=1</code> to the default\nGRUB 2 command line for the Linux operating system.\nTo ensure that <code>audit=1</code> is added as a kernel command line\nargument to newly installed kernels, add <code>audit=1</code> to the\ndefault Grub2 command line for Linux operating systems. Modify the line within\n<code>/etc/default/grub</code> as shown below:\n<pre>GRUB_CMDLINE_LINUX=&quot;... audit=1 ...&quot;</pre>\nRun the following command to update command line for already installed kernels:<pre># update-grub</pre>\n     ",
        "rationale": "Each process on the system carries an &quot;auditable&quot; flag which indicates whether\nits activities can be audited. Although <code>auditd</code> takes care of enabling\nthis for all processes which launch after it does, adding the kernel argument\nensures it is set for every process during boot.",
        "platforms": [
          "#grub2"
        ],
        "oval_definition_id": "oval:ssg-grub2_audit_argument:def:1",
        "remediations": [
          {
            "remediation_id": "grub2_audit_argument",
            "system": "urn:redhat:osbuild:blueprint",
            "fix": "[customizations.kernel]\nappend = \"audit=1\"\n"
          },
          {
            "remediation_id": "grub2_audit_argument",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { dpkg-query --show --showformat='${db:Status-Status}\\n' 'grub2-common' 2>/dev/null | grep -q installed; }; then\n\n# Correct the form of default kernel command line in GRUB\nif grep -q '^\\s*GRUB_CMDLINE_LINUX=.*audit=.*\"'  '/etc/default/grub' ; then\n       # modify the GRUB command-line if an audit= arg already exists\n       sed -i \"s/\\(^\\s*GRUB_CMDLINE_LINUX=\\\".*\\)audit=[^[:space:]]\\+\\(.*\\\"\\)/\\1audit=1\\2/\"  '/etc/default/grub'\n# Add to already existing GRUB_CMDLINE_LINUX parameters\nelif grep -q '^\\s*GRUB_CMDLINE_LINUX='  '/etc/default/grub' ; then\n       # no audit=arg is present, append it\n       sed -i \"s/\\(^\\s*GRUB_CMDLINE_LINUX=\\\".*\\)\\\"/\\1 audit=1\\\"/\"  '/etc/default/grub'\n# Add GRUB_CMDLINE_LINUX parameters line\nelse\n       echo \"GRUB_CMDLINE_LINUX=\\\"audit=1\\\"\" >> '/etc/default/grub'\nfi\nupdate-grub\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238299",
        "stig_id": "UBTU-20-010198"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_session_events_btmp": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_session_events_btmp",
        "title": "Record Attempts to Alter Process and Session Initiation Information btmp",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000172"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-12.1(iv)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000472-GPOS-00217"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010279"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238317r654126_rule"
            ]
          }
        ],
        "description": "The audit system already collects process information for all\nusers and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre>-w /var/log/btmp -p wa -k session</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre>-w /var/log/btmp -p wa -k session</pre>\n      ",
        "rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
        "oval_definition_id": "oval:ssg-audit_rules_session_events_btmp:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_session_events_btmp",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/btmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/btmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/btmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/btmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/btmp\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/btmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/btmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/btmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/btmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238317",
        "stig_id": "UBTU-20-010279"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_session_events_utmp": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_session_events_utmp",
        "title": "Record Attempts to Alter Process and Session Initiation Information utmp",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000172"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-12.1(iv)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000472-GPOS-00217"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010278"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238316r880873_rule"
            ]
          }
        ],
        "description": "The audit system already collects process information for all\nusers and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre>-w /run/utmp -p wa -k session</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre>-w /run/utmp -p wa -k session</pre>\n      ",
        "rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
        "oval_definition_id": "oval:ssg-audit_rules_session_events_utmp:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_session_events_utmp",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/run/utmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/run/utmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/run/utmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /run/utmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/run/utmp\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/run/utmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/run/utmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/run/utmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /run/utmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238316",
        "stig_id": "UBTU-20-010278"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_session_events_wtmp": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_session_events_wtmp",
        "title": "Record Attempts to Alter Process and Session Initiation Information wtmp",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000172"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-12.1(iv)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000472-GPOS-00217"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010277"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238315r654120_rule"
            ]
          }
        ],
        "description": "The audit system already collects process information for all\nusers and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre> -w /var/log/wtmp -p wa -k session</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre> -w /var/log/wtmp -p wa -k session</pre>\n      ",
        "rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
        "oval_definition_id": "oval:ssg-audit_rules_session_events_wtmp:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_session_events_wtmp",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/wtmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/wtmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/wtmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/wtmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/wtmp\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/wtmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/wtmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/wtmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/wtmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238315",
        "stig_id": "UBTU-20-010277"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_suid_privilege_function": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_suid_privilege_function",
        "title": "Record Events When Privileged Executables Are Run",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000343-CTR-000780",
              "SRG-APP-000381-CTR-000905"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.15"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001814",
              "CCI-001875",
              "CCI-001877",
              "CCI-001878",
              "CCI-001879",
              "CCI-001880",
              "CCI-001881",
              "CCI-001882",
              "CCI-001889",
              "CCI-001914",
              "CCI-002233",
              "CCI-002234"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(3)",
              "AU-7(a)",
              "AU-7(b)",
              "AU-8(b)",
              "CM-5(1)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000326-GPOS-00126",
              "SRG-OS-000327-GPOS-00127"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010211"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238304r853422_rule"
            ]
          }
        ],
        "description": "Verify the system generates an audit record when privileged functions are executed.\n\nIf audit is using the &quot;auditctl&quot; tool to load the rules, run the following command:\n\n<pre>$ sudo grep execve /etc/audit/audit.rules</pre>\n\nIf audit is using the &quot;augenrules&quot; tool to load the rules, run the following command:\n\n<pre>$ sudo grep -r execve /etc/audit/rules.d</pre>\n       <pre>-a always,exit -F arch=b32 -S execve -C uid!=euid -F euid=0 -k setuid</pre>\n       <pre>-a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -k setuid</pre>\n       <pre>-a always,exit -F arch=b32 -S execve -C gid!=egid -F egid=0 -k setgid</pre>\n       <pre>-a always,exit -F arch=b64 -S execve -C gid!=egid -F egid=0 -k setgid</pre>\n\n\nIf both the &quot;b32&quot; and &quot;b64&quot; audit rules for &quot;SUID&quot; files are not defined, this is a finding.\nIf both the &quot;b32&quot; and &quot;b64&quot; audit rules for &quot;SGID&quot; files are not defined, this is a finding.",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have\ncompromised information system accounts, is a serious and ongoing concern\nand can have significant adverse impacts on organizations. Auditing the use\nof privileged functions is one way to detect such misuse and identify the\nrisk from insider threats and the advanced persistent threat.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.",
            "category": "general"
          }
        ],
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_suid_privilege_function:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_suid_privilege_function",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\t\n\tOTHER_FILTERS=\"-C uid!=euid -F euid=0\"\n\t\n\tAUID_FILTERS=\"\"\n\tSYSCALL=\"execve\"\n\tKEY=\"setuid\"\n\tSYSCALL_GROUPING=\"\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\t\n\tOTHER_FILTERS=\"-C gid!=egid -F egid=0\"\n\t\n\tAUID_FILTERS=\"\"\n\tSYSCALL=\"execve\"\n\tKEY=\"setgid\"\n\tSYSCALL_GROUPING=\"\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238304",
        "stig_id": "UBTU-20-010211"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group",
        "title": "Record Events that Modify User/Group Information - /etc/group",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000503-CTR-001275"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.4"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.03",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000018",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-001403",
              "CCI-001404",
              "CCI-001405",
              "CCI-001683",
              "CCI-001684",
              "CCI-001685",
              "CCI-001686",
              "CCI-002130",
              "CCI-002132",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.2.2",
              "4.3.3.3.9",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.6.2.1",
              "A.6.2.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-1",
              "PR.AC-3",
              "PR.AC-4",
              "PR.AC-6",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000004-GPOS-00004",
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000239-GPOS-00089",
              "SRG-OS-000240-GPOS-00090",
              "SRG-OS-000241-GPOS-00091",
              "SRG-OS-000303-GPOS-00120",
              "SRG-OS-000304-GPOS-00121",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000470-GPOS-00214",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000476-GPOS-00221"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.5"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010101"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238239r853417_rule"
            ]
          }
        ],
        "description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>\n       <br>\n       <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>\n      ",
        "rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
        "oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_group:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_usergroup_modification_group",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/group already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/group\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient\n    for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/group in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/group -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/group already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/group\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/group in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/group -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010101\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_usergroup_modification_group",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/group\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/group $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/group$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/group -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/group\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/group\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/group $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/group$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/group -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238239",
        "stig_id": "UBTU-20-010101"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow",
        "title": "Record Events that Modify User/Group Information - /etc/gshadow",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000503-CTR-001275"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.4"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.03",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000018",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-001403",
              "CCI-001404",
              "CCI-001405",
              "CCI-001683",
              "CCI-001684",
              "CCI-001685",
              "CCI-001686",
              "CCI-002130",
              "CCI-002132",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.2.2",
              "4.3.3.3.9",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.6.2.1",
              "A.6.2.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-1",
              "PR.AC-3",
              "PR.AC-4",
              "PR.AC-6",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000004-GPOS-00004",
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000239-GPOS-00089",
              "SRG-OS-000240-GPOS-00090",
              "SRG-OS-000241-GPOS-00091",
              "SRG-OS-000303-GPOS-00120",
              "SRG-OS-000304-GPOS-00121",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000470-GPOS-00214",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000476-GPOS-00221"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.5"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010103"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238241r853419_rule"
            ]
          }
        ],
        "description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>\n       <br>\n       <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>\n      ",
        "rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
        "oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_gshadow:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_usergroup_modification_gshadow",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/gshadow already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/gshadow\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient\n    for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/gshadow in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/gshadow already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/gshadow\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/gshadow in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010103\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_usergroup_modification_gshadow",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/gshadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/gshadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/gshadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/gshadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/gshadow\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/gshadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/gshadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/gshadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/gshadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238241",
        "stig_id": "UBTU-20-010103"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd",
        "title": "Record Events that Modify User/Group Information - /etc/security/opasswd",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000496-CTR-001240",
              "SRG-APP-000497-CTR-001245",
              "SRG-APP-000498-CTR-001250",
              "SRG-APP-000503-CTR-001275"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.4"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.03",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000018",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-001403",
              "CCI-001404",
              "CCI-001405",
              "CCI-001683",
              "CCI-001684",
              "CCI-001685",
              "CCI-001686",
              "CCI-002130",
              "CCI-002132",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.2.2",
              "4.3.3.3.9",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.6.2.1",
              "A.6.2.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-1",
              "PR.AC-3",
              "PR.AC-4",
              "PR.AC-6",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000004-GPOS-00004",
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000239-GPOS-00089",
              "SRG-OS-000240-GPOS-00090",
              "SRG-OS-000241-GPOS-00091",
              "SRG-OS-000303-GPOS-00120",
              "SRG-OS-000304-GPOS-00121",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000470-GPOS-00214",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000476-GPOS-00221"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.5"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010104"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238242r853420_rule"
            ]
          }
        ],
        "description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>\n       <br>\n       <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>\n      ",
        "rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
        "oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_opasswd:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_usergroup_modification_opasswd",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/security/opasswd already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/security/opasswd\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient\n    for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/security/opasswd in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/security/opasswd already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/security/opasswd\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/security/opasswd in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010104\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_usergroup_modification_opasswd",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/security/opasswd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/security/opasswd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/security/opasswd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/security/opasswd\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/security/opasswd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/security/opasswd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/security/opasswd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238242",
        "stig_id": "UBTU-20-010104"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd",
        "title": "Record Events that Modify User/Group Information - /etc/passwd",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000503-CTR-001275"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.4"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.03",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000018",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-001403",
              "CCI-001404",
              "CCI-001405",
              "CCI-001683",
              "CCI-001684",
              "CCI-001685",
              "CCI-001686",
              "CCI-002130",
              "CCI-002132",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.2.2",
              "4.3.3.3.9",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.6.2.1",
              "A.6.2.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-1",
              "PR.AC-3",
              "PR.AC-4",
              "PR.AC-6",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000004-GPOS-00004",
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000239-GPOS-00089",
              "SRG-OS-000240-GPOS-00090",
              "SRG-OS-000241-GPOS-00091",
              "SRG-OS-000274-GPOS-00104",
              "SRG-OS-000275-GPOS-00105",
              "SRG-OS-000276-GPOS-00106",
              "SRG-OS-000277-GPOS-00107",
              "SRG-OS-000303-GPOS-00120",
              "SRG-OS-000304-GPOS-00121",
              "SRG-OS-000304-GPOS-00121",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000470-GPOS-00214",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000476-GPOS-00221"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.5"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010100"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238238r853416_rule"
            ]
          }
        ],
        "description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>\n       <br>\n       <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>\n      ",
        "rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
        "oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_passwd:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_usergroup_modification_passwd",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/passwd already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/passwd\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient\n    for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/passwd in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/passwd already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/passwd\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/passwd in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010100\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_usergroup_modification_passwd",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/passwd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/passwd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/passwd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/passwd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/passwd\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/passwd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/passwd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/passwd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/passwd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238238",
        "stig_id": "UBTU-20-010100"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow",
        "title": "Record Events that Modify User/Group Information - /etc/shadow",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000503-CTR-001275"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.4"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "DSS06.03",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000018",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-001403",
              "CCI-001404",
              "CCI-001405",
              "CCI-001683",
              "CCI-001684",
              "CCI-001685",
              "CCI-001686",
              "CCI-002130",
              "CCI-002132",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.2.2",
              "4.3.3.3.9",
              "4.3.3.5.1",
              "4.3.3.5.2",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.3.7.2",
              "4.3.3.7.3",
              "4.3.3.7.4",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.1",
              "SR 1.13",
              "SR 1.2",
              "SR 1.3",
              "SR 1.4",
              "SR 1.5",
              "SR 1.7",
              "SR 1.8",
              "SR 1.9",
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.6.2.1",
              "A.6.2.2",
              "A.7.1.1",
              "A.9.1.2",
              "A.9.2.1",
              "A.9.2.2",
              "A.9.2.3",
              "A.9.2.4",
              "A.9.2.6",
              "A.9.3.1",
              "A.9.4.1",
              "A.9.4.2",
              "A.9.4.3",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-1",
              "PR.AC-3",
              "PR.AC-4",
              "PR.AC-6",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000004-GPOS-00004",
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000239-GPOS-00089",
              "SRG-OS-000240-GPOS-00090",
              "SRG-OS-000241-GPOS-00091",
              "SRG-OS-000303-GPOS-00120",
              "SRG-OS-000304-GPOS-00121",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000470-GPOS-00214",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000476-GPOS-00221"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.5"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010102"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238240r853418_rule"
            ]
          }
        ],
        "description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>\n       <br>\n       <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br>\n       <br>\n       <pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>\n      ",
        "rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
        "oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_shadow:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_usergroup_modification_shadow",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/shadow already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/shadow\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient\n    for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_usergroup_modification.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/shadow in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/shadow already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/shadow\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/shadow in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010102\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - PCI-DSSv4-10.2.1.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_usergroup_modification_shadow",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/shadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/shadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/shadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/shadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/shadow\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/shadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/shadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/shadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/shadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238240",
        "stig_id": "UBTU-20-010102"
      },
      "xccdf_org.ssgproject.content_rule_audit_sudo_log_events": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_sudo_log_events",
        "title": "Record Attempts to perform maintenance activities",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.2",
              "Req-10.2.5.b"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010244"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238309r853427_rule"
            ]
          }
        ],
        "description": "The Ubuntu 20.04 operating system must generate audit records for\nprivileged activities, nonlocal maintenance, diagnostic sessions and\nother system-level access.\n\nVerify the operating system audits activities performed during nonlocal\nmaintenance and diagnostic sessions. Run the following command:\n<pre>$ sudo auditctl -l | grep sudo.log\n-w /var/log/sudo.log -p wa -k maintenance</pre>\n      ",
        "rationale": "If events associated with nonlocal administrative access or diagnostic\nsessions are not logged, a major tool for assessing and investigating\nattacks would not be available.\nThis requirement addresses auditing-related issues associated with\nmaintenance tools used specifically for diagnostic and repair actions\non organizational information systems.\nNonlocal maintenance and diagnostic activities are those activities\nconducted by individuals communicating through a network, either an\nexternal network (e.g., the internet) or an internal network. Local\nmaintenance and diagnostic activities are those activities carried\nout by individuals physically present at the information system or\ninformation system component and not communicating across a network\nconnection.\nThis requirement applies to hardware/software diagnostic test\nequipment or tools. This requirement does not cover hardware/software\ncomponents that may support information system maintenance, yet are a\npart of the system, for example, the software implementing &quot;ping,&quot;\n&quot;ls,&quot; &quot;ipconfig,&quot; or the hardware and software implementing the\nmonitoring port of an Ethernet switch.",
        "oval_definition_id": "oval:ssg-audit_sudo_log_events:def:1",
        "remediations": [
          {
            "remediation_id": "audit_sudo_log_events",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/sudo.log already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/sudo.log\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key logins\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)logins$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/logins.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/logins.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/sudo.log in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/sudo.log -p wa -k logins\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/sudo.log already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/sudo.log\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/sudo.log in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /var/log/sudo.log -p wa -k logins\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010244\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - PCI-DSSv4-10.2.1.3\n  - audit_sudo_log_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_sudo_log_events",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/sudo.log\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/sudo.log $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/sudo.log$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/sudo.log -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/sudo.log\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/sudo.log\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/sudo.log $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/sudo.log$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/sudo.log -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238309",
        "stig_id": "UBTU-20-010244"
      },
      "xccdf_org.ssgproject.content_rule_directory_permissions_var_log_audit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_directory_permissions_var_log_audit",
        "title": "System Audit Logs Must Have Mode 0750 or Less Permissive",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "APO11.04",
              "APO12.06",
              "BAI03.05",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02",
              "MEA02.01"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000162",
              "CCI-000163",
              "CCI-000164"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.7.3",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 5.2",
              "SR 6.1"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.2",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-004-6 R3.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2",
              "CIP-007-3 R6.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "AU-9",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.AC-4",
              "PR.DS-5",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000057-GPOS-00027",
              "SRG-OS-000058-GPOS-00028",
              "SRG-OS-000059-GPOS-00029"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010128"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238248r653919_rule"
            ]
          }
        ],
        "description": "\nIf <code>log_group</code> in <code>/etc/audit/auditd.conf</code> is set to a group other than the <code>root</code>\ngroup account, change the mode of the audit log files with the following command:\n<pre>$ sudo chmod 0750 /var/log/audit</pre>\n       <br>\nOtherwise, change the mode of the audit log files with the following command:\n<pre>$ sudo chmod 0700 /var/log/audit</pre>\n      ",
        "rationale": "If users can write to audit logs, audit trails can be modified or destroyed.",
        "oval_definition_id": "oval:ssg-directory_permissions_var_log_audit:def:1",
        "remediations": [
          {
            "remediation_id": "directory_permissions_var_log_audit",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nif LC_ALL=C grep -iw ^log_file /etc/audit/auditd.conf; then\n  DIR=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ' | rev | cut -d\"/\" -f2- | rev)\nelse\n  DIR=\"/var/log/audit\"\nfi\n\n\nif LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then\n  GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\n  if ! [ \"${GROUP}\" == 'root' ] ; then\n    chmod 0750 $DIR\n  else\n    chmod 0700 $DIR\n  fi\nelse\n  chmod 0700 $DIR\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238248",
        "stig_id": "UBTU-20-010128"
      },
      "xccdf_org.ssgproject.content_rule_file_group_ownership_var_log_audit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_group_ownership_var_log_audit",
        "title": "System Audit Logs Must Be Group Owned By Root",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "APO11.04",
              "APO12.06",
              "BAI03.05",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.3.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000162",
              "CCI-000163",
              "CCI-000164",
              "CCI-001314"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.7.3",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 5.2",
              "SR 6.1"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "AU-9(4)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.AC-4",
              "PR.DS-5",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000057-GPOS-00027",
              "SRG-OS-000058-GPOS-00028",
              "SRG-OS-000059-GPOS-00029",
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.1"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.2"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010124"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238247r832947_rule"
            ]
          }
        ],
        "description": "All audit logs must be group owned by root user. The path for audit log can\nbe configured via <code>log_file</code> parameter in <pre>/etc/audit/auditd.conf</pre>\nor, by default, the path for audit log is <pre>/var/log/audit/</pre>.\n\nTo properly set the group owner of <code>/var/log/audit/*</code>, run the command:\n<pre>$ sudo chgrp root /var/log/audit/*</pre>\n\nIf <code>log_group</code> in <code>/etc/audit/auditd.conf</code> is set to a group other\nthan the <code>root</code> group account, change the group ownership of the audit logs\nto this specific group.",
        "rationale": "Unauthorized disclosure of audit records can reveal system and configuration data to\nattackers, thus compromising its confidentiality.",
        "oval_definition_id": "oval:ssg-file_group_ownership_var_log_audit:def:1",
        "remediations": [
          {
            "remediation_id": "file_group_ownership_var_log_audit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: System Audit Logs Must Be Group Owned By Root - Get Audit Log Files\n  ansible.builtin.command: grep -iw ^log_file /etc/audit/auditd.conf\n  failed_when: false\n  register: log_file_exists\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: System Audit Logs Must Be Group Owned By Root - Set Log File Facts\n  ansible.builtin.set_fact:\n    log_file_line: '{{ log_file_exists.stdout | split('' '') | last }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: System Audit Logs Must Be Group Owned By Root - Set Default log_file if Not\n    Set\n  ansible.builtin.set_fact:\n    log_file: /var/log/audit/audit.log\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - (log_file_exists is undefined) or (log_file_exists.stdout | length == 0)\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: System Audit Logs Must Be Group Owned By Root - Set log_file From log_file_line\n    if Not Set Already\n  ansible.builtin.set_fact:\n    log_file: '{{ log_file_line }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - (log_file_line is defined) and (log_file_line | length > 0)\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: System Audit Logs Must Be Group Owned By Root - List All Log File Backups\n  ansible.builtin.find:\n    path: '{{ log_file | dirname }}'\n    patterns: '{{ log_file | basename }}.*'\n  register: backup_files\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: System Audit Logs Must Be Group Owned By Root - Apply Mode to All Backup Log\n    Files\n  ansible.builtin.file:\n    path: '{{ item }}'\n    group: root\n  failed_when: false\n  loop: '{{ backup_files.files| map(attribute=''path'') | list }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: System Audit Logs Must Be Group Owned By Root - Apply Mode to Log File\n  ansible.builtin.file:\n    path: '{{ log_file }}'\n    group: root\n  failed_when: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010124\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-AU-9(4)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSSv4-10.3.2\n  - file_group_ownership_var_log_audit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "file_group_ownership_var_log_audit",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nif LC_ALL=C grep -iw log_file /etc/audit/auditd.conf; then\n  FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\nelse\n  FILE=\"/var/log/audit/audit.log\"\nfi\n\n\nif LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then\n  GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\n    if ! [ \"${GROUP}\" == 'root' ]; then\n      chgrp ${GROUP} $FILE*\n    else\n      chgrp root $FILE*\n    fi\nelse\n  chgrp root $FILE*\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238247",
        "stig_id": "UBTU-20-010124"
      },
      "xccdf_org.ssgproject.content_rule_file_groupownership_audit_configuration": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_groupownership_audit_configuration",
        "title": "Audit Configuration Files Must Be Owned By Group root",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000171"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000063-GPOS-00032"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010135"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238251r653928_rule"
            ]
          }
        ],
        "description": "All audit configuration files must be owned by group root.\n<pre>chown :root /etc/audit/audit*.{rules,conf} /etc/audit/rules.d/*</pre>\n      ",
        "rationale": "Without the capability to restrict which roles and individuals can\nselect which events are audited, unauthorized personnel may be able\nto prevent the auditing of critical events.\nMisconfigured audits may degrade the system&#x27;s performance by\noverwhelming the audit log. Misconfigured audits may also make it more\ndifficult to establish, correlate, and investigate the events relating\nto an incident or identify those responsible for one.",
        "oval_definition_id": "oval:ssg-file_groupownership_audit_configuration:def:1",
        "remediations": [
          {
            "remediation_id": "file_groupownership_audit_configuration",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010135\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  command: find -H /etc/audit/ -maxdepth 1 -type f ! -group 0 -regextype posix-extended\n    -regex \"^.*audit(\\.rules|d\\.conf)$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010135\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  file:\n    path: '{{ item }}'\n    group: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010135\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  command: find -H /etc/audit/rules.d/ -maxdepth 1 -type f ! -group 0 -regextype posix-extended\n    -regex \"^.*\\.rules$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010135\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner on /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  file:\n    path: '{{ item }}'\n    group: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010135\n  - configure_strategy\n  - file_groupownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_groupownership_audit_configuration",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nfind /etc/audit/ -maxdepth 1 -L -type f ! -group 0 -regextype posix-extended -regex '^.*audit(\\.rules|d\\.conf)$' -exec chgrp -L 0 {} \\;\n\nfind /etc/audit/rules.d/ -maxdepth 1 -L -type f ! -group 0 -regextype posix-extended -regex '^.*\\.rules$' -exec chgrp -L 0 {} \\;\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238251",
        "stig_id": "UBTU-20-010135"
      },
      "xccdf_org.ssgproject.content_rule_file_ownership_audit_configuration": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_ownership_audit_configuration",
        "title": "Audit Configuration Files Must Be Owned By Root",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000171"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000063-GPOS-00032"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010134"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238250r653925_rule"
            ]
          }
        ],
        "description": "All audit configuration files must be owned by root user.\n\nTo properly set the owner of <code>/etc/audit/</code>, run the command:\n<pre>$ sudo chown root /etc/audit/ </pre>\n\nTo properly set the owner of <code>/etc/audit/rules.d/</code>, run the command:\n<pre>$ sudo chown root /etc/audit/rules.d/ </pre>\n      ",
        "rationale": "Without the capability to restrict which roles and individuals can\nselect which events are audited, unauthorized personnel may be able\nto prevent the auditing of critical events.\nMisconfigured audits may degrade the system&#x27;s performance by\noverwhelming the audit log. Misconfigured audits may also make it more\ndifficult to establish, correlate, and investigate the events relating\nto an incident or identify those responsible for one.",
        "oval_definition_id": "oval:ssg-file_ownership_audit_configuration:def:1",
        "remediations": [
          {
            "remediation_id": "file_ownership_audit_configuration",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010134\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  command: find -H /etc/audit/ -maxdepth 1 -type f ! -uid 0 -regextype posix-extended\n    -regex \"^.*audit(\\.rules|d\\.conf)$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010134\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /etc/audit/ file(s) matching ^.*audit(\\.rules|d\\.conf)$\n  file:\n    path: '{{ item }}'\n    owner: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010134\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Find /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  command: find -H /etc/audit/rules.d/ -maxdepth 1 -type f ! -uid 0 -regextype posix-extended\n    -regex \"^.*\\.rules$\"\n  register: files_found\n  changed_when: false\n  failed_when: false\n  check_mode: false\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010134\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner on /etc/audit/rules.d/ file(s) matching ^.*\\.rules$\n  file:\n    path: '{{ item }}'\n    owner: '0'\n    state: file\n  with_items:\n  - '{{ files_found.stdout_lines }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010134\n  - configure_strategy\n  - file_ownership_audit_configuration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "file_ownership_audit_configuration",
            "system": "urn:xccdf:fix:script:sh",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nfind /etc/audit/ -maxdepth 1 -L -type f ! -uid 0 -regextype posix-extended -regex '^.*audit(\\.rules|d\\.conf)$' -exec chown -L 0 {} \\;\n\nfind /etc/audit/rules.d/ -maxdepth 1 -L -type f ! -uid 0 -regextype posix-extended -regex '^.*\\.rules$' -exec chown -L 0 {} \\;\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238250",
        "stig_id": "UBTU-20-010134"
      },
      "xccdf_org.ssgproject.content_rule_file_ownership_var_log_audit_stig": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_ownership_var_log_audit_stig",
        "title": "System Audit Logs Must Be Owned By Root",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "APO11.04",
              "APO12.06",
              "BAI03.05",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.3.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000162",
              "CCI-000163",
              "CCI-000164",
              "CCI-001314"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.7.3",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 5.2",
              "SR 6.1"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "AU-9(4)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.AC-4",
              "PR.DS-5",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000057-GPOS-00027",
              "SRG-OS-000058-GPOS-00028",
              "SRG-OS-000059-GPOS-00029",
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010123"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238246r653913_rule"
            ]
          }
        ],
        "description": "All audit logs must be owned by root user. The path for audit log can be\nconfigured via <code>log_file</code> parameter in <pre>/etc/audit/auditd.conf</pre>\nor by default, the path for audit log is <pre>/var/log/audit/</pre>.\n\nTo properly set the owner of <code>/var/log/audit/*</code>, run the command:\n<pre>$ sudo chown root /var/log/audit/* </pre>\n      ",
        "rationale": "Unauthorized disclosure of audit records can reveal system and configuration data to\nattackers, thus compromising its confidentiality.",
        "oval_definition_id": "oval:ssg-file_ownership_var_log_audit_stig:def:1",
        "remediations": [
          {
            "remediation_id": "file_ownership_var_log_audit_stig",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nif LC_ALL=C grep -iw log_file /etc/audit/auditd.conf; then\n    FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\n    chown root $FILE*\nelse\n    chown root /var/log/audit/audit.log*\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238246",
        "stig_id": "UBTU-20-010123"
      },
      "xccdf_org.ssgproject.content_rule_file_permissions_var_log_audit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_var_log_audit",
        "title": "System Audit Logs Must Have Mode 0640 or Less Permissive",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000118-CTR-000240"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "18",
              "19",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO01.06",
              "APO11.04",
              "APO12.06",
              "BAI03.05",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "DSS06.02",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.3.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000162",
              "CCI-000163",
              "CCI-000164",
              "CCI-001314"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.7.3",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.1",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 5.2",
              "SR 6.1"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.10.1.1",
              "A.11.1.4",
              "A.11.1.5",
              "A.11.2.1",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.1.3",
              "A.13.2.1",
              "A.13.2.3",
              "A.13.2.4",
              "A.14.1.2",
              "A.14.1.3",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.1.2",
              "A.7.1.1",
              "A.7.1.2",
              "A.7.3.1",
              "A.8.2.2",
              "A.8.2.3",
              "A.9.1.1",
              "A.9.1.2",
              "A.9.2.3",
              "A.9.4.1",
              "A.9.4.4",
              "A.9.4.5"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R2.1",
              "CIP-007-3 R2.2",
              "CIP-007-3 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(1)",
              "AU-9(4)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.AC-4",
              "PR.DS-5",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000057-GPOS-00027",
              "SRG-OS-000058-GPOS-00028",
              "SRG-OS-000059-GPOS-00029",
              "SRG-OS-000206-GPOS-00084"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010122"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238245r653910_rule"
            ]
          }
        ],
        "description": "\nIf <code>log_group</code> in <code>/etc/audit/auditd.conf</code> is set to a group other than the\n<code>root</code>\ngroup account, change the mode of the audit log files with the following command:\n<pre>$ sudo chmod 0640 <i>audit_file</i>\n       </pre>\n       <br>\nOtherwise, change the mode of the audit log files with the following command:\n<pre>$ sudo chmod 0600 <i>audit_file</i>\n       </pre>\n      ",
        "rationale": "If users can write to audit logs, audit trails can be modified or destroyed.",
        "oval_definition_id": "oval:ssg-file_permissions_var_log_audit:def:1",
        "remediations": [
          {
            "remediation_id": "file_permissions_var_log_audit",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nif LC_ALL=C grep -iw ^log_file /etc/audit/auditd.conf; then\n    FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\nelse\n    FILE=\"/var/log/audit/audit.log\"\nfi\n\n\nif LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then\n  GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\n  if ! [ \"${GROUP}\" == 'root' ] ; then\n    chmod 0640 $FILE\n    chmod 0440 $FILE.*\n  else\n    chmod 0600 $FILE\n    chmod 0400 $FILE.*\n  fi\nelse\n  chmod 0600 $FILE\n  chmod 0400 $FILE.*\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238245",
        "stig_id": "UBTU-20-010122"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod",
        "title": "Record Events that Modify the System's Discretionary Access Controls - chmod",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010152"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238268r808480_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.  Here the system calls\nhave been placed independent of other system calls.  Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_chmod:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_chmod",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit chmod tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chmod for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chmod for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_chmod",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"chmod\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238268",
        "stig_id": "UBTU-20-010152"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown",
        "title": "Record Events that Modify the System's Discretionary Access Controls - chown",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010148"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238264r808477_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.  Here the system calls\nhave been placed independent of other system calls.  Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_chown:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_chown",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit chown tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chown for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chown for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_chown",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"chown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238264",
        "stig_id": "UBTU-20-010148"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod",
        "title": "Record Events that Modify the System's Discretionary Access Controls - fchmod",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010152"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238268r808480_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchmod:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_fchmod",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchmod tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmod for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmod for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_fchmod",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchmod\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238268",
        "stig_id": "UBTU-20-010152"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat",
        "title": "Record Events that Modify the System's Discretionary Access Controls - fchmodat",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010152"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238268r808480_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchmodat:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_fchmodat",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchmodat tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmodat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmodat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010152\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_fchmodat",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchmodat\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238268",
        "stig_id": "UBTU-20-010152"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown",
        "title": "Record Events that Modify the System's Discretionary Access Controls - fchown",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010148"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238264r808477_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchown:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_fchown",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchown tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchown for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchown for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_fchown",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238264",
        "stig_id": "UBTU-20-010148"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat",
        "title": "Record Events that Modify the System's Discretionary Access Controls - fchownat",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010148"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238264r808477_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchownat:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_fchownat",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchownat tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchownat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchownat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_fchownat",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchownat\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238264",
        "stig_id": "UBTU-20-010148"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr",
        "title": "Record Events that Modify the System's Discretionary Access Controls - fremovexattr",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000496-CTR-001240",
              "SRG-APP-000497-CTR-001245",
              "SRG-APP-000498-CTR-001250",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000463-GPOS-00207",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010147"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br>\n        <br>\nIf the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_fremovexattr:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_fremovexattr",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010147\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fremovexattr tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010147\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fremovexattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010147\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fremovexattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010147\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_fremovexattr",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"fremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": null,
        "stig_id": "UBTU-20-010147"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr",
        "title": "Record Events that Modify the System's Discretionary Access Controls - fsetxattr",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000496-CTR-001240",
              "SRG-APP-000497-CTR-001245",
              "SRG-APP-000498-CTR-001250",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000463-GPOS-00207",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010144"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_fsetxattr:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_fsetxattr",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010144\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fsetxattr tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010144\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fsetxattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010144\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fsetxattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010144\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_fsetxattr",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"fsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": null,
        "stig_id": "UBTU-20-010144"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown",
        "title": "Record Events that Modify the System's Discretionary Access Controls - lchown",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010148"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238264r808477_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_lchown:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_lchown",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lchown tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lchown for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lchown for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010148\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_lchown",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lchown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238264",
        "stig_id": "UBTU-20-010148"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr",
        "title": "Record Events that Modify the System's Discretionary Access Controls - lremovexattr",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000496-CTR-001240",
              "SRG-APP-000497-CTR-001245",
              "SRG-APP-000498-CTR-001250",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000463-GPOS-00207",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010146"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br>\n        <br>\nIf the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_lremovexattr:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_lremovexattr",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010146\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lremovexattr tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010146\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lremovexattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010146\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lremovexattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010146\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_lremovexattr",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"lremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": null,
        "stig_id": "UBTU-20-010146"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr",
        "title": "Record Events that Modify the System's Discretionary Access Controls - lsetxattr",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000496-CTR-001240",
              "SRG-APP-000497-CTR-001245",
              "SRG-APP-000498-CTR-001250",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000463-GPOS-00207",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010143"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_lsetxattr:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_lsetxattr",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010143\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lsetxattr tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010143\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lsetxattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010143\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lsetxattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010143\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_lsetxattr",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"lsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": null,
        "stig_id": "UBTU-20-010143"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr",
        "title": "Record Events that Modify the System's Discretionary Access Controls - removexattr",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000496-CTR-001240",
              "SRG-APP-000497-CTR-001245",
              "SRG-APP-000498-CTR-001250",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000463-GPOS-00207",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000474-GPOS-00219"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010145"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing line to a file with suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>\n        <br>\n        <br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_removexattr:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_removexattr",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit removexattr tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for removexattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for removexattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010145\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_removexattr",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"removexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"removexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": null,
        "stig_id": "UBTU-20-010145"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr",
        "title": "Record Events that Modify the System's Discretionary Access Controls - setxattr",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000091-CTR-000160",
              "SRG-APP-000492-CTR-001220",
              "SRG-APP-000493-CTR-001225",
              "SRG-APP-000494-CTR-001230",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000500-CTR-001260",
              "SRG-APP-000507-CTR-001295"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.9"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.5.5"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.3.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010142"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238258r808474_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n        <pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre>\n       ",
        "rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_dac_modification_setxattr:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_dac_modification_setxattr",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010142\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit setxattr tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010142\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for setxattr for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010142\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for setxattr for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - CJIS-5.4.1.1\n  - DISA-STIG-UBTU-20-010142\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - PCI-DSSv4-10.3.4\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_dac_modification_setxattr",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"setxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"setxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238258",
        "stig_id": "UBTU-20-010142"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_execution_chacl": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_chacl",
        "title": "Record Any Attempts to Run chacl",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010168"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238284r654027_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect any execution attempt\nof the <code>chacl</code> command for all users and root. If the <code>auditd</code>\ndaemon is configured to use the <code>augenrules</code> program to read audit rules\nduring daemon startup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).",
        "oval_definition_id": "oval:ssg-audit_rules_execution_chacl:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_execution_chacl",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010168\n  - audit_rules_execution_chacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/chacl\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chacl -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010168\n  - audit_rules_execution_chacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_execution_chacl",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/chacl -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238284",
        "stig_id": "UBTU-20-010168"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_execution_setfacl": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_setfacl",
        "title": "Record Any Attempts to Run setfacl",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010167"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238283r654024_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect any execution attempt\nof the <code>setfacl</code> command for all users and root. If the <code>auditd</code>\ndaemon is configured to use the <code>augenrules</code> program to read audit rules\nduring daemon startup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).",
        "oval_definition_id": "oval:ssg-audit_rules_execution_setfacl:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_execution_setfacl",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010167\n  - audit_rules_execution_setfacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/setfacl\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/setfacl -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010167\n  - audit_rules_execution_setfacl\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_execution_setfacl",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/setfacl -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238283",
        "stig_id": "UBTU-20-010167"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_execution_chcon": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_chcon",
        "title": "Record Any Attempts to Run chcon",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000496-CTR-001240",
              "SRG-APP-000497-CTR-001245",
              "SRG-APP-000498-CTR-001250",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000463-GPOS-00207",
              "SRG-OS-000465-GPOS-00209",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010165"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238281r654018_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect any execution attempt\nof the <code>chcon</code> command for all users and root. If the <code>auditd</code>\ndaemon is configured to use the <code>augenrules</code> program to read audit rules\nduring daemon startup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_execution_chcon:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_execution_chcon",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_execution_chcon\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/chcon\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chcon -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010165\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_execution_chcon\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_execution_chcon",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/chcon -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238281",
        "stig_id": "UBTU-20-010165"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename",
        "title": "Ensure auditd Collects File Deletion Events by User - rename",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.13"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-000366",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.1.1",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.MA-2",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000467-GPOS-00211",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010267"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238310r832953_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ",
        "rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_rename:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_file_deletion_events_rename",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit rename tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rename for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rename for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_file_deletion_events_rename",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"rename\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238310",
        "stig_id": "UBTU-20-010267"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat",
        "title": "Ensure auditd Collects File Deletion Events by User - renameat",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.13"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-000366",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.1.1",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.MA-2",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000467-GPOS-00211",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010267"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238310r832953_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ",
        "rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
        "oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_renameat:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_file_deletion_events_renameat",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit renameat tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for renameat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for renameat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_file_deletion_events_renameat",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"renameat\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238310",
        "stig_id": "UBTU-20-010267"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rmdir": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rmdir",
        "title": "Ensure auditd Collects File Deletion Events by User - rmdir",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-000366",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.1.1",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.MA-2",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000467-GPOS-00211",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010267"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238310r832953_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ",
        "rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_rmdir:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_file_deletion_events_rmdir",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit rmdir tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rmdir for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rmdir for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_file_deletion_events_rmdir",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"rmdir\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238310",
        "stig_id": "UBTU-20-010267"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink",
        "title": "Ensure auditd Collects File Deletion Events by User - unlink",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.13"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-000366",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.1.1",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.MA-2",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000467-GPOS-00211",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010267"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238310r832953_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ",
        "rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_unlink:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_file_deletion_events_unlink",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit unlink tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlink for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlink for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_file_deletion_events_unlink",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"unlink\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238310",
        "stig_id": "UBTU-20-010267"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat",
        "title": "Ensure auditd Collects File Deletion Events by User - unlinkat",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.13"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-000366",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.5",
              "4.3.3.6.6",
              "4.3.3.6.7",
              "4.3.3.6.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.4",
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.1.1",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.MA-2",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000467-GPOS-00211",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010267"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238310r832953_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\n       ",
        "rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
        "oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_unlinkat:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_file_deletion_events_unlinkat",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit unlinkat tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlinkat for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlinkat for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010267\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - PCI-DSSv4-10.2.1.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_file_deletion_events_unlinkat",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"unlinkat\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238310",
        "stig_id": "UBTU-20-010267"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat",
        "title": "Record Unsuccessful Access Attempts to Files - creat",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000461-GPOS-00205",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.1",
              "Req-10.2.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010155"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238271r808483_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ",
        "rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_creat:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_creat",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit creat tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_creat",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"creat\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238271",
        "stig_id": "UBTU-20-010155"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate",
        "title": "Record Unsuccessful Access Attempts to Files - ftruncate",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000461-GPOS-00205",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.1",
              "Req-10.2.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010155"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238271r808483_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ",
        "rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_ftruncate:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_ftruncate",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit ftruncate tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_ftruncate",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"ftruncate\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238271",
        "stig_id": "UBTU-20-010155"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open",
        "title": "Record Unsuccessful Access Attempts to Files - open",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000461-GPOS-00205",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.1",
              "Req-10.2.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010155"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238271r808483_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ",
        "rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "platforms": [
          "#not_aarch64_arch"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_open:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_open",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit open tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not ( ansible_architecture == \"aarch64\" )\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_open",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed && { ! ( grep -q aarch64 /proc/sys/kernel/osrelease ); }; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"open\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238271",
        "stig_id": "UBTU-20-010155"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at",
        "title": "Record Unsuccessful Access Attempts to Files - open_by_handle_at",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000461-GPOS-00205",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.1",
              "Req-10.2.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010155"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238271r808483_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ",
        "rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_open_by_handle_at:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_open_by_handle_at",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit open_by_handle_at tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EACCES for 32bit\n    platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EACCES for 64bit\n    platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_open_by_handle_at",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"open_by_handle_at\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238271",
        "stig_id": "UBTU-20-010155"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat",
        "title": "Record Unsuccessful Access Attempts to Files - openat",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000461-GPOS-00205",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.1",
              "Req-10.2.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010155"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238271r808483_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ",
        "rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_openat:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_openat",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit openat tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_openat",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"openat\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238271",
        "stig_id": "UBTU-20-010155"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate",
        "title": "Record Unsuccessful Access Attempts to Files - truncate",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.10"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000458-GPOS-00203",
              "SRG-OS-000461-GPOS-00205",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.1",
              "Req-10.2.4"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010155"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238271r808483_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n       ",
        "rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
        "warnings": [
          {
            "text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_truncate:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_truncate",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit truncate tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EACCES for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EACCES for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EPERM for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EPERM for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010155\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_unsuccessful_file_modification_truncate",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"truncate\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238271",
        "stig_id": "UBTU-20-010155"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete",
        "title": "Ensure auditd Collects Information on Kernel Module Unloading - delete_module",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000504-CTR-001280"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.16"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000471-GPOS-00216",
              "SRG-OS-000477-GPOS-00222"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010181"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238297r802387_rule"
            ]
          }
        ],
        "description": "To capture kernel module unloading events, use following line, setting ARCH to\neither b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S delete_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n\n\nPlace to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured\nto use the <code>augenrules</code> program (the default), add the line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,\nadd the line to file <code>/etc/audit/audit.rules</code>.",
        "rationale": "The removal of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.",
        "oval_definition_id": "oval:ssg-audit_rules_kernel_module_loading_delete:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_kernel_module_loading_delete",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010181\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit delete_module tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010181\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for delete_module for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010181\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for delete_module for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010181\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "audit_rules_kernel_module_loading_delete",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\t\n\tSYSCALL=\"delete_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"delete_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238297",
        "stig_id": "UBTU-20-010181"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit",
        "title": "Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000504-CTR-001280"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000471-GPOS-00216",
              "SRG-OS-000477-GPOS-00222"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010179"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238295r808486_rule"
            ]
          }
        ],
        "description": "If the <code>auditd</code> daemon is configured to use the <code>augenrules</code> program\nto read audit rules during daemon startup (the default), add the following lines to a file\nwith suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code> to capture kernel module\nloading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n    If the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility to read audit\nrules during daemon startup, add the following lines to <code>/etc/audit/audit.rules</code> file\nin order to capture kernel module loading and unloading events, setting ARCH to either b32 or\nb64 as appropriate for your system:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n       ",
        "rationale": "The addition/removal of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.",
        "oval_definition_id": "oval:ssg-audit_rules_kernel_module_loading_finit:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_kernel_module_loading_finit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit finit_module tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for finit_module for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for finit_module for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "audit_rules_kernel_module_loading_finit",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\t\n\tSYSCALL=\"finit_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"init_module finit_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238295",
        "stig_id": "UBTU-20-010179"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init",
        "title": "Ensure auditd Collects Information on Kernel Module Loading - init_module",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000504-CTR-001280"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.16"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000471-GPOS-00216",
              "SRG-OS-000477-GPOS-00222"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010179"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238295r808486_rule"
            ]
          }
        ],
        "description": "To capture kernel module loading events, use following line, setting ARCH to\neither b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S init_module -F auid&gt;=1000 -F auid!=unset -F key=modules</pre>\n\n\nPlace to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured\nto use the <code>augenrules</code> program (the default), add the line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,\nadd the line to file <code>/etc/audit/audit.rules</code>.",
        "rationale": "The addition of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.",
        "oval_definition_id": "oval:ssg-audit_rules_kernel_module_loading_init:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_kernel_module_loading_init",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "configure",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit init_module tasks\n  set_fact:\n    audit_arch: b64\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_architecture == \"aarch64\" or ansible_architecture == \"ppc64\" or ansible_architecture\n    == \"ppc64le\" or ansible_architecture == \"s390x\" or ansible_architecture == \"x86_64\"\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for init_module for 32bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for init_module for 64bit platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - audit_arch == \"b64\"\n  tags:\n  - DISA-STIG-UBTU-20-010179\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
          },
          {
            "remediation_id": "audit_rules_kernel_module_loading_init",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\t\n\tSYSCALL=\"init_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"init_module finit_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238295",
        "stig_id": "UBTU-20-010179"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_login_events_faillog": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_faillog",
        "title": "Record Attempts to Alter Logon and Logout Events - faillog",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010170"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238286r654033_rule"
            ]
          }
        ],
        "description": "The audit system already collects login information for all users\nand root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/faillog -p wa -k logins</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for unattempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/faillog -p wa -k logins</pre>\n       ",
        "rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
        "oval_definition_id": "oval:ssg-audit_rules_login_events_faillog:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_login_events_faillog",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/faillog already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/faillog\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key logins\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)logins$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/logins.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/logins.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/faillog in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/faillog -p wa -k logins\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/faillog already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/faillog\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/faillog in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /var/log/faillog -p wa -k logins\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010170\n  - audit_rules_login_events_faillog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_login_events_faillog",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/faillog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/faillog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/faillog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/faillog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/faillog\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/faillog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/faillog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/faillog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/faillog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238286",
        "stig_id": "UBTU-20-010170"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_login_events_lastlog": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_lastlog",
        "title": "Record Attempts to Alter Logon and Logout Events - lastlog",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000503-CTR-001275",
              "SRG-APP-000506-CTR-001290"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.7"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000470-GPOS-00214",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000473-GPOS-00218"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010171"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238287r654036_rule"
            ]
          }
        ],
        "description": "The audit system already collects login information for all users\nand root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/lastlog -p wa -k logins</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for unattempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/lastlog -p wa -k logins</pre>\n       ",
        "rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
        "oval_definition_id": "oval:ssg-audit_rules_login_events_lastlog:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_login_events_lastlog",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/lastlog already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/lastlog\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key logins\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)logins$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/logins.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/logins.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/lastlog in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/lastlog -p wa -k logins\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/lastlog already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/lastlog\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/lastlog in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /var/log/lastlog -p wa -k logins\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010171\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_lastlog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_login_events_lastlog",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/lastlog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/lastlog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/lastlog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/lastlog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/lastlog\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/lastlog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/lastlog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/lastlog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/lastlog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238287",
        "stig_id": "UBTU-20-010171"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_login_events_tallylog": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_tallylog",
        "title": "Record Attempts to Alter Logon and Logout Events - tallylog",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000503-CTR-001275"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.7"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI08.02",
              "DSS01.03",
              "DSS01.04",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS03.05",
              "DSS05.02",
              "DSS05.03",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000126",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.3.6.6",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 1.13",
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.6",
              "SR 2.8",
              "SR 2.9",
              "SR 3.1",
              "SR 3.5",
              "SR 3.8",
              "SR 4.1",
              "SR 4.3",
              "SR 5.1",
              "SR 5.2",
              "SR 5.3",
              "SR 6.1",
              "SR 6.2",
              "SR 7.1",
              "SR 7.6"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.11.2.6",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.13.1.1",
              "A.13.2.1",
              "A.14.1.3",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.6.2.1",
              "A.6.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.AC-3",
              "PR.PT-1",
              "PR.PT-4",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000470-GPOS-00214",
              "SRG-OS-000473-GPOS-00218"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.2.3"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.2.1.3"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010169"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238285r654030_rule"
            ]
          }
        ],
        "description": "The audit system already collects login information for all users\nand root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/tallylog -p wa -k logins</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for unattempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/tallylog -p wa -k logins</pre>\n       ",
        "rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
        "oval_definition_id": "oval:ssg-audit_rules_login_events_tallylog:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_login_events_tallylog",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/tallylog already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/tallylog\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key logins\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)logins$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/logins.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/logins.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/tallylog in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/tallylog -p wa -k logins\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/tallylog already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/tallylog\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/tallylog in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /var/log/tallylog -p wa -k logins\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010169\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - PCI-DSSv4-10.2.1.3\n  - audit_rules_login_events_tallylog\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_login_events_tallylog",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/tallylog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/tallylog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/tallylog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/tallylog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/tallylog\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/tallylog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/tallylog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/tallylog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/tallylog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238285",
        "stig_id": "UBTU-20-010169"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_apparmor_parser": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_apparmor_parser",
        "title": "Record Any Attempts to Run apparmor_parser",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000172"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000064-GPOS-00033"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010166"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238282r654021_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect any execution attempt\nof the <code>apparmor_parser</code> command for all users and root. If\nthe <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add\nthe following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/sbin/apparmor_parser -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following\nlines to <code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F path=/sbin/apparmor_parser -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_apparmor_parser:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_apparmor_parser",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010166\n  - audit_rules_privileged_commands_apparmor_parser\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /sbin/apparmor_parser\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/sbin/apparmor_parser -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/sbin/apparmor_parser -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/apparmor_parser\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/sbin/apparmor_parser -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/sbin/apparmor_parser -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/sbin/apparmor_parser\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010166\n  - audit_rules_privileged_commands_apparmor_parser\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_apparmor_parser",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/sbin/apparmor_parser -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238282",
        "stig_id": "UBTU-20-010166"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chage": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chage",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - chage",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000501-CTR-001265",
              "SRG-APP-000502-CTR-001270"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000468-GPOS-00212",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010175"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238291r654048_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_chage:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_chage",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/chage\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chage -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chage -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chage -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010175\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_chage",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/chage -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238291",
        "stig_id": "UBTU-20-010175"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chfn": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chfn",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - chfn",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(a)",
              "AU-12(c)",
              "AU-3",
              "MA-4(1)(a)"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010137"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238253r653934_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\n\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_chfn:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_chfn",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010137\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_chfn\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/chfn\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chfn -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chfn -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chfn -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010137\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_chfn\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_chfn",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/chfn -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238253",
        "stig_id": "UBTU-20-010137"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chsh": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chsh",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - chsh",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010163"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238279r654012_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_chsh:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_chsh",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010163\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chsh\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/chsh\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/chsh -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chsh -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chsh -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010163\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_chsh\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_chsh",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/chsh -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238279",
        "stig_id": "UBTU-20-010163"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_crontab": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_crontab",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - crontab",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010177"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238293r654054_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_crontab:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_crontab",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010177\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_crontab\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/crontab\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/crontab -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/crontab -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/crontab -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010177\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_crontab\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_crontab",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/crontab -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238293",
        "stig_id": "UBTU-20-010177"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_fdisk": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_fdisk",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - fdisk",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000172"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000477-GPOS-00222"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010298"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238320r832956_rule"
            ]
          }
        ],
        "description": "Configure the operating system to audit the execution of the partition\nmanagement program &quot;fdisk&quot;.",
        "rationale": "Without generating audit records that are specific to the security\nand mission needs of the organization, it would be difficult to\nestablish, correlate, and investigate the events relating to an\nincident or identify those responsible for one.\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_fdisk:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_fdisk",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /sbin/fdisk already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/sbin/fdisk\\s+-p\\s+x(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key modules\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)modules$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/modules.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/modules.rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /sbin/fdisk in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /sbin/fdisk -p x -k modules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /sbin/fdisk already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/sbin/fdisk\\s+-p\\s+x(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /sbin/fdisk in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /sbin/fdisk -p x -k modules\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - DISA-STIG-UBTU-20-010298\n  - audit_rules_privileged_commands_fdisk\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_fdisk",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/fdisk\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/fdisk $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/fdisk$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /sbin/fdisk -p x -k modules\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/modules.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/sbin/fdisk\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/modules.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/modules.rules\"\n    # If the modules.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/fdisk\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/fdisk $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/fdisk$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /sbin/fdisk -p x -k modules\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238320",
        "stig_id": "UBTU-20-010298"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_gpasswd": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_gpasswd",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010174"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238290r654045_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_gpasswd:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_gpasswd",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010174\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_gpasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/gpasswd\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/gpasswd -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/gpasswd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/gpasswd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010174\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_gpasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_gpasswd",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/gpasswd -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238290",
        "stig_id": "UBTU-20-010174"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_kmod": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_kmod",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - kmod",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000504-CTR-001280"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(a)",
              "AU-12.1(ii)",
              "AU-12.1(iv)AU-12(c)",
              "AU-3",
              "AU-3.1",
              "MA-4(1)(a)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215",
              "SRG-OS-000471-GPOS-00216",
              "SRG-OS-000477-GPOS-00222"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010297"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238319r654132_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-w /usr/bin/kmod -p x -k modules</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-w /usr/bin/kmod -p x -k modules</pre>\n       ",
        "rationale": "Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\n\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_kmod:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_kmod",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010297\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12.1(ii)\n  - NIST-800-53-AU-12.1(iv)AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-AU-3.1\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_kmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/kmod\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/kmod -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/kmod -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/kmod -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010297\n  - NIST-800-53-AU-12(a)\n  - NIST-800-53-AU-12.1(ii)\n  - NIST-800-53-AU-12.1(iv)AU-12(c)\n  - NIST-800-53-AU-3\n  - NIST-800-53-AU-3.1\n  - NIST-800-53-MA-4(1)(a)\n  - audit_rules_privileged_commands_kmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_kmod",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/kmod -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238319",
        "stig_id": "UBTU-20-010297"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_modprobe": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_modprobe",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - modprobe",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R73"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.16"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-12(a)",
              "AU-12(c)",
              "AU-12.1(ii)",
              "AU-12.1(iv)",
              "AU-3",
              "AU-3.1",
              "MA-4(1)(a)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010296"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238318r654129_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-w /sbin/modprobe -p x -k modules</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-w /sbin/modprobe -p x -k modules</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "platforms": [
          "#machine"
        ],
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_modprobe:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_modprobe",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/modprobe\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/modprobe $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/modprobe$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /sbin/modprobe -p x -k modules\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/modules.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/sbin/modprobe\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/modules.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/modules.rules\"\n    # If the modules.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/sbin/modprobe\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/sbin/modprobe $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"x\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/sbin/modprobe$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /sbin/modprobe -p x -k modules\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238318",
        "stig_id": "UBTU-20-010296"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_mount": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_mount",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - mount",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010138"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238254r653937_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_mount:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_mount",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010138\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_mount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/mount\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/mount -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/mount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/mount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010138\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_mount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_mount",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/mount -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238254",
        "stig_id": "UBTU-20-010138"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_newgrp": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_newgrp",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - newgrp",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010164"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238280r654015_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_newgrp:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_newgrp",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010164\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_newgrp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/newgrp\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/newgrp -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/newgrp -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/newgrp -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010164\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_newgrp\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_newgrp",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/newgrp -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238280",
        "stig_id": "UBTU-20-010164"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_pam_timestamp_check": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_pam_timestamp_check",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - pam_timestamp_check",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010178"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238294r654057_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/sbin/pam_timestamp_check\n-F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/sbin/pam_timestamp_check\n-F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_pam_timestamp_check:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_pam_timestamp_check",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010178\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_pam_timestamp_check\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/sbin/pam_timestamp_check\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=unset\n        (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/sbin/pam_timestamp_check\n        -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/pam_timestamp_check\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=unset\n        (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000\n        -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/pam_timestamp_check\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010178\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_pam_timestamp_check\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_pam_timestamp_check",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/sbin/pam_timestamp_check -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238294",
        "stig_id": "UBTU-20-010178"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_passwd": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_passwd",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - passwd",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-004-6 R2.2.2",
              "CIP-004-6 R2.2.3",
              "CIP-007-3 R.1.3",
              "CIP-007-3 R5",
              "CIP-007-3 R5.1.1",
              "CIP-007-3 R5.1.3",
              "CIP-007-3 R5.2.1",
              "CIP-007-3 R5.2.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-2(4)",
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010172"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238288r833012_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_passwd:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_passwd",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010172\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/passwd\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/passwd -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/passwd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/passwd -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010172\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_passwd",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/passwd -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238288",
        "stig_id": "UBTU-20-010172"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_agent": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_agent",
        "title": "Record Any Attempts to Run ssh-agent",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010140"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238256r653943_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect any execution attempt\nof the <code>ssh-agent</code> command for all users and root. If the <code>auditd</code>\ndaemon is configured to use the <code>augenrules</code> program to read audit rules\nduring daemon startup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid&gt;=1000 -F auid!=unset -k privileged-ssh-agent</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid&gt;=1000 -F auid!=unset -k privileged-ssh-agent</pre>\n       ",
        "rationale": "Without generating audit records that are specific to the security and\nmission needs of the organization, it would be difficult to establish,\ncorrelate, and investigate the events relating to an incident or identify\nthose responsible for one.\n\nAudit records can be generated from various components within the\ninformation system (e.g., module or policy filter).",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_ssh_agent:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_ssh_agent",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010140\n  - audit_rules_privileged_commands_ssh_agent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/ssh-agent\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/ssh-agent -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/ssh-agent -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/ssh-agent -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010140\n  - audit_rules_privileged_commands_ssh_agent\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_ssh_agent",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/ssh-agent -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238256",
        "stig_id": "UBTU-20-010140"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_keysign": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_keysign",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010141"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238257r653946_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_ssh_keysign:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_ssh_keysign",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010141\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_ssh_keysign\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/lib/openssh/ssh-keysign\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/lib/openssh/ssh-keysign\n        -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/lib/openssh/ssh-keysign\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid>=1000\n        -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/lib/openssh/ssh-keysign\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010141\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_ssh_keysign\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_ssh_keysign",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/lib/openssh/ssh-keysign -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238257",
        "stig_id": "UBTU-20-010141"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_su": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_su",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - su",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-0003",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010136"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238252r653931_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_su:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_su",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010136\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_su\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/su\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/su -F perm=x -F auid>=1000\n        -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/su -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/su -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010136\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_su\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_su",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/su -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238252",
        "stig_id": "UBTU-20-010136"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudo": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudo",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - sudo",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "anssi",
            "href": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
            "ref_ids": [
              "R33"
            ]
          },
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085",
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010161"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238277r654006_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_sudo:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_sudo",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010161\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudo\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/sudo\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/sudo -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudo -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudo -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010161\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudo\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_sudo",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/sudo -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238277",
        "stig_id": "UBTU-20-010161"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudoedit": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudoedit",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010162"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238278r654009_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_sudoedit:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_sudoedit",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010162\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudoedit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/sudoedit\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/sudoedit -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudoedit -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/sudoedit -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010162\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_sudoedit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_sudoedit",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/sudoedit -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238278",
        "stig_id": "UBTU-20-010162"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_umount": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_umount",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - umount",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000029-CTR-000085"
            ]
          },
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.11"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "12",
              "13",
              "14",
              "15",
              "16",
              "2",
              "3",
              "5",
              "6",
              "7",
              "8",
              "9"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO10.01",
              "APO10.03",
              "APO10.04",
              "APO10.05",
              "APO11.04",
              "BAI03.05",
              "DSS01.03",
              "DSS03.05",
              "DSS05.02",
              "DSS05.04",
              "DSS05.05",
              "DSS05.07",
              "MEA01.01",
              "MEA01.02",
              "MEA01.03",
              "MEA01.04",
              "MEA01.05",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.1.7"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.308(a)(1)(ii)(D)",
              "164.308(a)(3)(ii)(A)",
              "164.308(a)(5)(ii)(C)",
              "164.312(a)(2)(i)",
              "164.312(b)",
              "164.312(d)",
              "164.312(e)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.3.2.6.7",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 6.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.14.2.7",
              "A.15.2.1",
              "A.15.2.2"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AC-6(9)",
              "AU-12(c)",
              "AU-2(d)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.CM-1",
              "DE.CM-3",
              "DE.CM-7",
              "ID.SC-4",
              "PR.PT-1"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010139"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238255r653940_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_umount:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_umount",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010139\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_umount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/bin/umount\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/bin/umount -F perm=x -F\n        auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/umount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/umount -F perm=x\n        -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010139\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - audit_rules_privileged_commands_umount\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_umount",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/bin/umount -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238255",
        "stig_id": "UBTU-20-010139"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_update": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_update",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - unix_update",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000064-GPOS-00033",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010173"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238289r654042_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_unix_update:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_unix_update",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010173\n  - audit_rules_privileged_commands_unix_update\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/sbin/unix_update\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/sbin/unix_update -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/unix_update\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/unix_update\n        -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010173\n  - audit_rules_privileged_commands_unix_update\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_unix_update",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/sbin/unix_update -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238289",
        "stig_id": "UBTU-20-010173"
      },
      "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_usermod": {
        "rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_usermod",
        "title": "Ensure auditd Collects Information on the Use of Privileged Commands - usermod",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "app-srg-ctr",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform",
            "ref_ids": [
              "SRG-APP-000495-CTR-001235",
              "SRG-APP-000499-CTR-001255"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000130",
              "CCI-000135",
              "CCI-000169",
              "CCI-000172",
              "CCI-002884"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000037-GPOS-00015",
              "SRG-OS-000042-GPOS-00020",
              "SRG-OS-000062-GPOS-00031",
              "SRG-OS-000392-GPOS-00172",
              "SRG-OS-000462-GPOS-00206",
              "SRG-OS-000466-GPOS-00210",
              "SRG-OS-000471-GPOS-00215"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010176"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238292r654051_rule"
            ]
          }
        ],
        "description": "At a minimum, the audit system should collect the execution of\nprivileged commands for all users and root. If the <code>auditd</code> daemon is\nconfigured to use the <code>augenrules</code> program to read audit rules during\ndaemon startup (the default), add a line of the following form to a file with\nsuffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code>:\n<pre>-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\n       ",
        "rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br>\n        <br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
        "oval_definition_id": "oval:ssg-audit_rules_privileged_commands_usermod:def:1",
        "remediations": [
          {
            "remediation_id": "audit_rules_privileged_commands_usermod",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010176\n  - audit_rules_privileged_commands_usermod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for /usr/sbin/usermod\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/privileged.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F path=/usr/sbin/usermod -F perm=x\n        -F auid>=1000 -F auid!=unset (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls: []\n      syscall_grouping: []\n\n  - name: Check existence of  in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F\n        path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:(\n        -S |,)\\w+)+)( -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F\n        perm=x -F auid>=1000 -F auid!=unset -F key=privileged\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010176\n  - audit_rules_privileged_commands_usermod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "audit_rules_privileged_commands_usermod",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nACTION_ARCH_FILTERS=\"-a always,exit\"\nOTHER_FILTERS=\"-F path=/usr/sbin/usermod -F perm=x\"\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"\"\nKEY=\"privileged\"\nSYSCALL_GROUPING=\"\"\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\nunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238292",
        "stig_id": "UBTU-20-010176"
      },
      "xccdf_org.ssgproject.content_rule_auditd_audispd_configure_remote_server": {
        "rule_id": "xccdf_org.ssgproject.content_rule_auditd_audispd_configure_remote_server",
        "title": "Configure audispd Plugin To Send Logs To Remote Server",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001851"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000342-GPOS-00133",
              "SRG-OS-000479-GPOS-00224"
            ]
          },
          {
            "name": "ospp",
            "href": "https://www.niap-ccevs.org/Profile/PP.cfm",
            "ref_ids": [
              "FAU_GEN.1.1.c"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010216"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238306r877390_rule"
            ]
          }
        ],
        "description": "Configure the audispd plugin to off-load audit records onto a different\nsystem or media from the system being audited.\n\nFirst, set the <code>active</code> option in\n<pre>/etc/audisp/plugins.d/au-remote.conf</pre>\n\nSet the <code>remote_server</code> option in <pre>/etc/audisp/audisp-remote.conf</pre>\nwith an IP address or hostname of the system that the audispd plugin should\nsend audit records to. For example\n<pre>remote_server = <i>logcollector</i>\n       </pre>\n      ",
        "rationale": "Information stored in one location is vulnerable to accidental or incidental\ndeletion or alteration.Off-loading is a common process in information systems\nwith limited audit storage capacity.",
        "oval_definition_id": "oval:ssg-auditd_audispd_configure_remote_server:def:1",
        "remediations": [
          {
            "remediation_id": "auditd_audispd_configure_remote_server",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nvar_audispd_remote_server='logcollector'\n\n\nAUDITCONFIG=/etc/audisp/audisp-remote.conf\n\n\nAUREMOTECONFIG=/etc/audisp/plugins.d/au-remote.conf\n\nif [ -e \"$AUREMOTECONFIG\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*active\\s*=\\s*/Id\" \"$AUREMOTECONFIG\"\nelse\n    printf '%s\\n' \"Path '$AUREMOTECONFIG' wasn't found on this system. Refusing to continue.\" >&2\n    return 1\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"$AUREMOTECONFIG\"\n\ncp \"$AUREMOTECONFIG\" \"$AUREMOTECONFIG.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"active = yes\" >> \"$AUREMOTECONFIG\"\n# Clean up after ourselves.\nrm \"$AUREMOTECONFIG.bak\"\n\n\nif [ -e \"$AUDITCONFIG\" ] ; then\n    \n    LC_ALL=C sed -i \"/^\\s*remote_server\\s*=\\s*/Id\" \"$AUDITCONFIG\"\nelse\n    printf '%s\\n' \"Path '$AUDITCONFIG' wasn't found on this system. Refusing to continue.\" >&2\n    return 1\nfi\n# make sure file has newline at the end\nsed -i -e '$a\\' \"$AUDITCONFIG\"\n\ncp \"$AUDITCONFIG\" \"$AUDITCONFIG.bak\"\n# Insert at the end of the file\nprintf '%s\\n' \"remote_server = $var_audispd_remote_server\" >> \"$AUDITCONFIG\"\n# Clean up after ourselves.\nrm \"$AUDITCONFIG.bak\"\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238306",
        "stig_id": "UBTU-20-010216"
      },
      "xccdf_org.ssgproject.content_rule_auditd_audispd_configure_sufficiently_large_partition": {
        "rule_id": "xccdf_org.ssgproject.content_rule_auditd_audispd_configure_sufficiently_large_partition",
        "title": "Configure a Sufficiently Large Partition for Audit Logs",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001849"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000341-GPOS-00132",
              "SRG-OS-000342-GPOS-00133"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010215"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238305r877391_rule"
            ]
          }
        ],
        "description": "The Ubuntu 20.04 operating system must allocate audit record storage\ncapacity to store at least one weeks worth of audit records when audit\nrecords are not immediately sent to a central audit record storage\nfacility.\n\nThe partition size needed to capture a week&#x27;s worth of audit records is\nbased on the activity level of the system and the total storage capacity\navailable.\n\nIn normal circumstances, 10.0 GB of storage space for audit\nrecords will be sufficient.\n\n\nDetermine which partition the audit records are being written to with the\nfollowing command:\n\n<pre>$ sudo grep log_file /etc/audit/auditd.conf\nlog_file = /var/log/audit/audit.log</pre>\n\nCheck the size of the partition that audit records are written to with the\nfollowing command:\n\n<pre>$ sudo df -h /var/log/audit/\n/dev/sda2 24G 10.4G 13.6G 43% /var/log/audit</pre>\n      ",
        "rationale": "Information stored in one location is vulnerable to accidental or incidental\ndeletion or alteration. Off-loading is a common process in information\nsystems with limited audit storage capacity.",
        "platforms": [
          "#machine"
        ],
        "vuln_id": "SV-238305",
        "stig_id": "UBTU-20-010215"
      },
      "xccdf_org.ssgproject.content_rule_auditd_data_disk_full_action": {
        "rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_disk_full_action",
        "title": "Configure auditd Disk Full Action when Disk Space Is Full",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI04.04",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "MEA02.01"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000140"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 7.1",
              "SR 7.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.3",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.17.2.1"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-5(1)",
              "AU-5(2)",
              "AU-5(4)",
              "AU-5(b)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.DS-4",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000047-GPOS-00023"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010118"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238244r653907_rule"
            ]
          }
        ],
        "description": "The <code>auditd</code> service can be configured to take an action\nwhen disk space is running low but prior to running out of space completely.\nEdit the file <code>/etc/audit/auditd.conf</code>. Add or modify the following line,\nsubstituting <i>ACTION</i> appropriately:\n<pre>disk_full_action = <i>ACTION</i>\n       </pre>\nSet this value to <code>single</code> to cause the system to switch to single-user\nmode for corrective action. Acceptable values also include <code>syslog</code>,\n\n<code>exec</code>,\n\n<code>single</code>, and <code>halt</code>. For certain systems, the need for availability\noutweighs the need to log all actions, and a different setting should be\ndetermined. Details regarding all possible values for <i>ACTION</i> are described in the\n<code>auditd.conf</code> man page.",
        "rationale": "Taking appropriate action in case of a filled audit storage volume will minimize\nthe possibility of losing audit records.",
        "oval_definition_id": "oval:ssg-auditd_data_disk_full_action:def:1",
        "remediations": [
          {
            "remediation_id": "auditd_data_disk_full_action",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nvar_auditd_disk_full_action='halt'\n\n\nvar_auditd_disk_full_action=\"$(echo $var_auditd_disk_full_action | cut -d \\| -f 1)\"\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^disk_full_action\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_disk_full_action\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^disk_full_action\\\\>\" \"/etc/audit/auditd.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^disk_full_action\\\\>.*/$escaped_formatted_output/gi\" \"/etc/audit/auditd.conf\"\nelse\n    if [[ -s \"/etc/audit/auditd.conf\" ]] && [[ -n \"$(tail -c 1 -- \"/etc/audit/auditd.conf\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"/etc/audit/auditd.conf\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/audit/auditd.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238244",
        "stig_id": "UBTU-20-010118"
      },
      "xccdf_org.ssgproject.content_rule_auditd_data_retention_action_mail_acct": {
        "rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_action_mail_acct",
        "title": "Configure auditd mail_acct Action on Low Disk Space",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.2.3"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI04.04",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.3.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-000139",
              "CCI-001855"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.312(a)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 7.1",
              "SR 7.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.3",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.17.2.1"
            ]
          },
          {
            "name": "nerc-cip",
            "href": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
            "ref_ids": [
              "CIP-003-8 R1.3",
              "CIP-003-8 R3",
              "CIP-003-8 R3.1",
              "CIP-003-8 R3.2",
              "CIP-003-8 R3.3",
              "CIP-003-8 R5.1.1",
              "CIP-003-8 R5.3",
              "CIP-004-6 R2.2.3",
              "CIP-004-6 R2.3",
              "CIP-007-3 R5.1",
              "CIP-007-3 R5.1.2",
              "CIP-007-3 R5.2",
              "CIP-007-3 R5.3.1",
              "CIP-007-3 R5.3.2",
              "CIP-007-3 R5.3.3"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-5(2)",
              "AU-5(a)",
              "CM-6(a)",
              "IA-5(1)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.DS-4",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000046-GPOS-00022",
              "SRG-OS-000343-GPOS-00134"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.7.a"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010117"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238243r653904_rule"
            ]
          }
        ],
        "description": "The <code>auditd</code> service can be configured to send email to\na designated account in certain situations. Add or correct the following line\nin <code>/etc/audit/auditd.conf</code> to ensure that administrators are notified\nvia email for those situations:\n<pre>action_mail_acct = root\n       </pre>\n      ",
        "rationale": "Email sent to the root account is typically aliased to the\nadministrators of the system, who can take appropriate action.",
        "oval_definition_id": "oval:ssg-auditd_data_retention_action_mail_acct:def:1",
        "remediations": [
          {
            "remediation_id": "auditd_data_retention_action_mail_acct",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nvar_auditd_action_mail_acct='root'\n\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^action_mail_acct\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_action_mail_acct\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^action_mail_acct\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^action_mail_acct\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    if [[ -s \"$AUDITCONFIG\" ]] && [[ -n \"$(tail -c 1 -- \"$AUDITCONFIG\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"$AUDITCONFIG\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238243",
        "stig_id": "UBTU-20-010117"
      },
      "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action": {
        "rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action",
        "title": "Configure auditd space_left Action on Low Disk Space",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis",
            "href": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
            "ref_ids": [
              "4.1.2.3"
            ]
          },
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cjis",
            "href": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
            "ref_ids": [
              "5.4.1.1"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI04.04",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "MEA02.01"
            ]
          },
          {
            "name": "cui",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
            "ref_ids": [
              "3.3.1"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001855"
            ]
          },
          {
            "name": "hipaa",
            "href": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
            "ref_ids": [
              "164.312(a)(2)(ii)"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 7.1",
              "SR 7.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.3",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.17.2.1"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-5(1)",
              "AU-5(2)",
              "AU-5(4)",
              "AU-5(b)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.DS-4",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000343-GPOS-00134"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.7"
            ]
          },
          {
            "name": "pcidss4",
            "href": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
            "ref_ids": [
              "10.5.1"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010217"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238307r877389_rule"
            ]
          }
        ],
        "description": "The <code>auditd</code> service can be configured to take an action\nwhen disk space <i>starts</i> to run low.\nEdit the file <code>/etc/audit/auditd.conf</code>. Modify the following line,\nsubstituting <i>ACTION</i> appropriately:\n<pre>space_left_action = <i>ACTION</i>\n       </pre>\nPossible values for <i>ACTION</i> are described in the <code>auditd.conf</code> man page.\nThese include:\n<ul><li><code>syslog</code></li><li><code>email</code></li><li><code>exec</code></li><li><code>suspend</code></li><li><code>single</code></li><li><code>halt</code></li></ul>\nSet this to <code>email</code> (instead of the default,\nwhich is <code>suspend</code>) as it is more likely to get prompt attention. Acceptable values\nalso include <code>suspend</code>, <code>single</code>, and <code>halt</code>.",
        "rationale": "Notifying administrators of an impending disk space problem may\nallow them to take corrective action prior to any disruption.",
        "oval_definition_id": "oval:ssg-auditd_data_retention_space_left_action:def:1",
        "remediations": [
          {
            "remediation_id": "auditd_data_retention_space_left_action",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nvar_auditd_space_left_action='email'\n\n\nvar_auditd_space_left_action=\"$(echo $var_auditd_space_left_action | cut -d \\| -f 1)\"\n#\n# If space_left_action present in /etc/audit/auditd.conf, change value\n# to var_auditd_space_left_action, else\n# add \"space_left_action = $var_auditd_space_left_action\" to /etc/audit/auditd.conf\n#\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^space_left_action\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_space_left_action\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^space_left_action\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    LC_ALL=C sed -i --follow-symlinks \"s/^space_left_action\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    if [[ -s \"$AUDITCONFIG\" ]] && [[ -n \"$(tail -c 1 -- \"$AUDITCONFIG\" || true)\" ]]; then\n        LC_ALL=C sed -i --follow-symlinks '$a'\\\\ \"$AUDITCONFIG\"\n    fi\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238307",
        "stig_id": "UBTU-20-010217"
      },
      "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_percentage": {
        "rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_percentage",
        "title": "Configure auditd space_left on Low Disk Space",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "cis-csc",
            "href": "https://www.cisecurity.org/controls/",
            "ref_ids": [
              "1",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "19",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8"
            ]
          },
          {
            "name": "cobit5",
            "href": "https://www.isaca.org/resources/cobit",
            "ref_ids": [
              "APO11.04",
              "APO12.06",
              "APO13.01",
              "BAI03.05",
              "BAI04.04",
              "BAI08.02",
              "DSS02.02",
              "DSS02.04",
              "DSS02.07",
              "DSS03.01",
              "DSS05.04",
              "DSS05.07",
              "MEA02.01"
            ]
          },
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001855"
            ]
          },
          {
            "name": "isa-62443-2009",
            "href": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
            "ref_ids": [
              "4.2.3.10",
              "4.3.3.3.9",
              "4.3.3.5.8",
              "4.3.4.4.7",
              "4.3.4.5.6",
              "4.3.4.5.7",
              "4.3.4.5.8",
              "4.4.2.1",
              "4.4.2.2",
              "4.4.2.4"
            ]
          },
          {
            "name": "isa-62443-2013",
            "href": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
            "ref_ids": [
              "SR 2.10",
              "SR 2.11",
              "SR 2.12",
              "SR 2.8",
              "SR 2.9",
              "SR 6.1",
              "SR 7.1",
              "SR 7.2"
            ]
          },
          {
            "name": "iso27001-2013",
            "href": "https://www.iso.org/contents/data/standard/05/45/54534.html",
            "ref_ids": [
              "A.12.1.3",
              "A.12.4.1",
              "A.12.4.2",
              "A.12.4.3",
              "A.12.4.4",
              "A.12.7.1",
              "A.16.1.4",
              "A.16.1.5",
              "A.16.1.7",
              "A.17.2.1"
            ]
          },
          {
            "name": "nist",
            "href": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
            "ref_ids": [
              "AU-5(1)",
              "AU-5(2)",
              "AU-5(4)",
              "AU-5(b)",
              "CM-6(a)"
            ]
          },
          {
            "name": "nist-csf",
            "href": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
            "ref_ids": [
              "DE.AE-3",
              "DE.AE-5",
              "PR.DS-4",
              "PR.PT-1",
              "RS.AN-1",
              "RS.AN-4"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000343-GPOS-00134"
            ]
          },
          {
            "name": "pcidss",
            "href": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
            "ref_ids": [
              "Req-10.7"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010217"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238307r877389_rule"
            ]
          }
        ],
        "description": "The <code>auditd</code> service can be configured to take an action\nwhen disk space is running low but prior to running out of space completely.\nEdit the file <code>/etc/audit/auditd.conf</code>. Add or modify the following line,\nsubstituting <i>PERCENTAGE</i> appropriately:\n<pre>space_left = <i>PERCENTAGE</i>%</pre>\nSet this value to at least 25 to cause the system to\nnotify the user of an issue.",
        "rationale": "Notifying administrators of an impending disk space problem may allow them to\ntake corrective action prior to any disruption.",
        "oval_definition_id": "oval:ssg-auditd_data_retention_space_left_percentage:def:1",
        "remediations": [
          {
            "remediation_id": "auditd_data_retention_space_left_percentage",
            "system": "urn:xccdf:fix:script:ansible",
            "complexity": "low",
            "disruption": "low",
            "strategy": "restrict",
            "fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - DISA-STIG-UBTU-20-010217\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_space_left_percentage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_space_left_percentage # promote to variable\n  set_fact:\n    var_auditd_space_left_percentage: !!str 25\n  tags:\n    - always\n\n- name: Configure auditd space_left on Low Disk Space\n  lineinfile:\n    dest: /etc/audit/auditd.conf\n    line: space_left = {{ var_auditd_space_left_percentage }}%\n    regexp: ^\\s*space_left\\s*=\\s*.*$\n    state: present\n    create: true\n  when:\n  - '\"auditd\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - DISA-STIG-UBTU-20-010217\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_space_left_percentage\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
          },
          {
            "remediation_id": "auditd_data_retention_space_left_percentage",
            "system": "urn:xccdf:fix:script:sh",
            "fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && dpkg-query --show --showformat='${db:Status-Status}\\n' 'auditd' 2>/dev/null | grep -q installed; then\n\nvar_auditd_space_left_percentage='25'\n\n\ngrep -q \"^space_left[[:space:]]*=.*$\" /etc/audit/auditd.conf && \\\n  sed -i \"s/^space_left[[:space:]]*=.*$/space_left = $var_auditd_space_left_percentage%/g\" /etc/audit/auditd.conf || \\\n  echo \"space_left = $var_auditd_space_left_percentage%\" >> /etc/audit/auditd.conf\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
          }
        ],
        "vuln_id": "SV-238307",
        "stig_id": "UBTU-20-010217"
      },
      "xccdf_org.ssgproject.content_rule_auditd_offload_logs": {
        "rule_id": "xccdf_org.ssgproject.content_rule_auditd_offload_logs",
        "title": "Offload audit Logs to External Media",
        "result": "notapplicable",
        "time": "2025-03-28T16:15:43+00:00",
        "severity": "medium",
        "weight": 1,
        "references": [
          {
            "name": "disa",
            "href": "https://public.cyber.mil/stigs/cci/",
            "ref_ids": [
              "CCI-001851"
            ]
          },
          {
            "name": "os-srg",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
            "ref_ids": [
              "SRG-OS-000479-GPOS-00224"
            ]
          },
          {
            "name": "stigid",
            "href": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
            "ref_ids": [
              "UBTU-20-010300"
            ]
          },
          {
            "name": "stigref",
            "href": "https://public.cyber.mil/stigs/srg-stig-tools/",
            "ref_ids": [
              "SV-238321r853428_rule"
            ]
          }
        ],
        "description": "The operating system must have a crontab script running weekly to\noffload audit events of standalone systems.",
        "rationale": "Information stored in one location is vulnerable to accidental or\nincidental deletion or alteration.\nOffloading is a common process in information systems with limited\naudit storage capacity.",
        "warnings": [
          {
            "text": "Due to different needs and possibilities, automated remediation is not\navailable for this configuration check.",
            "category": "general"
          }
        ],
        "oval_definition_id": "oval:ssg-auditd_offload_logs:def:1",
        "vuln_id": "SV-238321",
        "stig_id": "UBTU-20-010300"
      }
    },
    "references": {
      "anssi": "https://cyber.gouv.fr/sites/default/files/document/linux_configuration-en-v2.pdf",
      "cis": "https://www.cisecurity.org/benchmark/ubuntu_linux/",
      "cis-csc": "https://www.cisecurity.org/controls/",
      "cjis": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
      "cobit5": "https://www.isaca.org/resources/cobit",
      "disa": "https://public.cyber.mil/stigs/cci/",
      "isa-62443-2009": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
      "isa-62443-2013": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
      "ism": "https://www.cyber.gov.au/acsc/view-all-content/ism",
      "iso27001-2013": "https://www.iso.org/contents/data/standard/05/45/54534.html",
      "nist": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
      "nist-csf": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
      "os-srg": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
      "pcidss": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
      "pcidss4": "https://docs-prv.pcisecuritystandards.org/PCI%20DSS/Standard/PCI-DSS-v4_0.pdf",
      "stigid": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cunix-linux",
      "stigref": "https://public.cyber.mil/stigs/srg-stig-tools/",
      "cui": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
      "hipaa": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
      "nerc-cip": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
      "ospp": "https://www.niap-ccevs.org/Profile/PP.cfm",
      "app-srg-ctr": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=container-platform"
    }
  }